# autogenerated from AMD RDNA3.5 ISA PDF by pseudocode.py - do not edit
# instruction name -> {'opcode': int, 'section': str, 'pseudocode': list[str]}
PSEUDOCODE: dict[str, dict] = {
  'S_ABSDIFF_I32': {'opcode': 6, 'section': 'SOP2', 'pseudocode': ['D0.i32 = S0.i32 - S1.i32;', 'if D0.i32 < 0 then', 'D0.i32 = -D0.i32', 'endif;', 'SCC = D0.i32 != 0']},
  'S_ABS_I32': {'opcode': 21, 'section': 'SOP1', 'pseudocode': ['D0.i32 = S0.i32 < 0 ? -S0.i32 : S0.i32;', 'SCC = D0.i32 != 0']},
  'S_ADDC_U32': {'opcode': 4, 'section': 'SOP2', 'pseudocode': ["tmp = 64'U(S0.u32) + 64'U(S1.u32) + SCC.u64;", "SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;", 'D0.u32 = tmp.u32']},
  'S_ADDK_I32': {'opcode': 15, 'section': 'SOPK', 'pseudocode': ['tmp = D0.i32;', "D0.i32 = 32'I(64'I(D0.i32) + signext(SIMM16.i16));", 'SCC = ((tmp[31] == SIMM16.i16[15]) && (tmp[31] != D0.i32[31]));']},
  'S_ADD_F16': {'opcode': 73, 'section': 'SOP2', 'pseudocode': ['D0.f16 = S0.f16 + S1.f16']},
  'S_ADD_F32': {'opcode': 64, 'section': 'SOP2', 'pseudocode': ['D0.f32 = S0.f32 + S1.f32']},
  'S_ADD_I32': {'opcode': 2, 'section': 'SOP2', 'pseudocode': ['tmp = S0.i32 + S1.i32;', 'SCC = ((S0.u32[31] == S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));', 'D0.i32 = tmp.i32']},
  'S_ADD_U32': {'opcode': 0, 'section': 'SOP2', 'pseudocode': ["tmp = 64'U(S0.u32) + 64'U(S1.u32);", "SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;", 'D0.u32 = tmp.u32']},
  'S_AND_B32': {'opcode': 22, 'section': 'SOP2', 'pseudocode': ['D0.u32 = (S0.u32 & S1.u32);', 'SCC = D0.u32 != 0U']},
  'S_AND_B64': {'opcode': 23, 'section': 'SOP2', 'pseudocode': ['D0.u64 = (S0.u64 & S1.u64);', 'SCC = D0.u64 != 0ULL']},
  'S_AND_NOT0_SAVEEXEC_B32': {'opcode': 44, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into', 'the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into', 'saveexec = EXEC.u32;', 'EXEC.u32 = (~S0.u32 & EXEC.u32);', 'D0.u32 = saveexec.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_AND_NOT0_SAVEEXEC_B64': {'opcode': 45, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into', 'the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into', 'saveexec = EXEC.u64;', 'EXEC.u64 = (~S0.u64 & EXEC.u64);', 'D0.u64 = saveexec.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'S_AND_NOT0_WREXEC_B32': {'opcode': 52, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into', 'Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op', 'result. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is', 'EXEC.u32 = (~S0.u32 & EXEC.u32);', 'D0.u32 = EXEC.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_AND_NOT0_WREXEC_B64': {'opcode': 53, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into', 'Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op', 'result. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is', 'EXEC.u64 = (~S0.u64 & EXEC.u64);', 'D0.u64 = EXEC.u64;']},
  'S_AND_NOT1_B64': {'opcode': 35, 'section': 'SOP2', 'pseudocode': ['D0.u64 = (S0.u64 & ~S1.u64);', 'SCC = D0.u64 != 0ULL']},
  'S_AND_NOT1_SAVEEXEC_B32': {'opcode': 48, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into', 'the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into', 'saveexec = EXEC.u32;', 'EXEC.u32 = (S0.u32 & ~EXEC.u32);', 'D0.u32 = saveexec.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_AND_NOT1_SAVEEXEC_B64': {'opcode': 49, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into', 'the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into', 'saveexec = EXEC.u64;', 'EXEC.u64 = (S0.u64 & ~EXEC.u64);', 'D0.u64 = saveexec.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'S_AND_NOT1_WREXEC_B32': {'opcode': 54, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into', 'Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op', 'result. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is', 'EXEC.u32 = (S0.u32 & ~EXEC.u32);', 'D0.u32 = EXEC.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_AND_NOT1_WREXEC_B64': {'opcode': 55, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into', 'Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op', 'result. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is', 'EXEC.u64 = (S0.u64 & ~EXEC.u64);', 'D0.u64 = EXEC.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'S_AND_SAVEEXEC_B32': {'opcode': 32, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar', 'saveexec = EXEC.u32;', 'EXEC.u32 = (S0.u32 & EXEC.u32);', 'D0.u32 = saveexec.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_AND_SAVEEXEC_B64': {'opcode': 33, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar']},
  'S_ASHR_I32': {'opcode': 12, 'section': 'SOP2', 'pseudocode': ["D0.i32 = 32'I(signext(S0.i32) >> S1[4 : 0].u32);", 'SCC = D0.i32 != 0']},
  'S_ASHR_I64': {'opcode': 13, 'section': 'SOP2', 'pseudocode': ['D0.i64 = (signext(S0.i64) >> S1[5 : 0].u32);', 'SCC = D0.i64 != 0LL']},
  'S_BCNT0_I32_B32': {'opcode': 22, 'section': 'SOP1', 'pseudocode': ['tmp = 0;', 'for i in 0 : 31 do', "tmp += S0.u32[i] == 1'0U ? 1 : 0", 'D0.i32 = tmp;', 'SCC = D0.u32 != 0U']},
  'S_BCNT0_I32_B64': {'opcode': 23, 'section': 'SOP1', 'pseudocode': ['tmp = 0;', 'for i in 0 : 63 do', "tmp += S0.u64[i] == 1'0U ? 1 : 0", 'D0.i32 = tmp;', 'SCC = D0.u64 != 0ULL']},
  'S_BCNT1_I32_B64': {'opcode': 25, 'section': 'SOP1', 'pseudocode': ['tmp = 0;', 'for i in 0 : 63 do', "tmp += S0.u64[i] == 1'1U ? 1 : 0", 'D0.i32 = tmp;', 'SCC = D0.u64 != 0ULL']},
  'S_BFE_I32': {'opcode': 39, 'section': 'SOP2', 'pseudocode': ['tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S1[22 : 16].u32) - 1));', 'D0.i32 = signext_from_bit(tmp.i32, S1[22 : 16].u32);', 'SCC = D0.i32 != 0']},
  'S_BFE_I64': {'opcode': 41, 'section': 'SOP2', 'pseudocode': ['tmp.i64 = ((S0.i64 >> S1[5 : 0].u32) & ((1LL << S1[22 : 16].u32) - 1LL));', 'D0.i64 = signext_from_bit(tmp.i64, S1[22 : 16].u32);', 'SCC = D0.i64 != 0LL']},
  'S_BFE_U32': {'opcode': 38, 'section': 'SOP2', 'pseudocode': ['D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1U << S1[22 : 16].u32) - 1U));', 'SCC = D0.u32 != 0U']},
  'S_BFE_U64': {'opcode': 40, 'section': 'SOP2', 'pseudocode': ['D0.u64 = ((S0.u64 >> S1[5 : 0].u32) & ((1ULL << S1[22 : 16].u32) - 1ULL));', 'SCC = D0.u64 != 0ULL']},
  'S_BFM_B32': {'opcode': 42, 'section': 'SOP2', 'pseudocode': ['D0.u32 = (((1U << S0[4 : 0].u32) - 1U) << S1[4 : 0].u32)']},
  'S_BFM_B64': {'opcode': 43, 'section': 'SOP2', 'pseudocode': ['D0.u64 = (((1ULL << S0[5 : 0].u32) - 1ULL) << S1[5 : 0].u32)']},
  'S_BITCMP0_B32': {'opcode': 12, 'section': 'SOPC', 'pseudocode': ["SCC = S0.u32[S1.u32[4 : 0]] == 1'0U"]},
  'S_BITCMP1_B32': {'opcode': 13, 'section': 'SOPC', 'pseudocode': ["SCC = S0.u32[S1.u32[4 : 0]] == 1'1U"]},
  'S_BITCMP1_B64': {'opcode': 15, 'section': 'SOPC', 'pseudocode': ["SCC = S0.u64[S1.u32[5 : 0]] == 1'1U"]},
  'S_BITREPLICATE_B64_B32': {'opcode': 20, 'section': 'SOP1', 'pseudocode': ['tmp = S0.u32;', 'for i in 0 : 31 do', 'D0.u64[i * 2] = tmp[i];', 'D0.u64[i * 2 + 1] = tmp[i]']},
  'S_BITSET0_B32': {'opcode': 16, 'section': 'SOP1', 'pseudocode': ["D0.u32[S0.u32[4 : 0]] = 1'0U"]},
  'S_BITSET0_B64': {'opcode': 17, 'section': 'SOP1', 'pseudocode': ["D0.u64[S0.u32[5 : 0]] = 1'0U"]},
  'S_BITSET1_B64': {'opcode': 19, 'section': 'SOP1', 'pseudocode': ["D0.u64[S0.u32[5 : 0]] = 1'1U"]},
  'S_BREV_B64': {'opcode': 5, 'section': 'SOPK', 'pseudocode': ['D0.u64[63 : 0] = S0.u64[0 : 63]']},
  'S_CALL_B64': {'opcode': 20, 'section': 'SOPK', 'pseudocode': ['D0.i64 = PC + 4LL;']},
  'S_CBRANCH_CDBGSYS': {'opcode': 39, 'section': 'SOPP', 'pseudocode': ['if WAVE_STATUS.COND_DBG_SYS.u32 != 0U then', "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL", 'else', 'PC = PC + 4LL', 'endif']},
  'S_CBRANCH_CDBGSYS_AND_USER': {'opcode': 42, 'section': 'SOPP', 'pseudocode': ['if (WAVE_STATUS.COND_DBG_SYS && WAVE_STATUS.COND_DBG_USER) then', "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL", 'else', 'PC = PC + 4LL', 'endif']},
  'S_CBRANCH_CDBGSYS_OR_USER': {'opcode': 41, 'section': 'SOPP', 'pseudocode': ['if (WAVE_STATUS.COND_DBG_SYS || WAVE_STATUS.COND_DBG_USER) then', "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL", 'else', 'PC = PC + 4LL', 'endif']},
  'S_CBRANCH_EXECNZ': {'opcode': 38, 'section': 'SOPP', 'pseudocode': ["if EXECZ.u1 == 1'0U then", "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL", 'else', 'PC = PC + 4LL', 'endif']},
  'S_CBRANCH_EXECZ': {'opcode': 37, 'section': 'SOPP', 'pseudocode': ["if EXECZ.u1 == 1'1U then", "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL", 'else', 'PC = PC + 4LL', 'endif']},
  'S_CBRANCH_SCC1': {'opcode': 34, 'section': 'SOPP', 'pseudocode': ["if SCC == 1'1U then", "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL", 'else', 'PC = PC + 4LL', 'endif']},
  'S_CBRANCH_VCCNZ': {'opcode': 36, 'section': 'SOPP', 'pseudocode': ['If VCCZ is 0 then jump to a constant offset relative to the current PC.', "if VCCZ.u1 == 1'0U then", "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL", 'else']},
  'S_CBRANCH_VCCZ': {'opcode': 35, 'section': 'SOPP', 'pseudocode': ['If VCCZ is 1 then jump to a constant offset relative to the current PC.', "if VCCZ.u1 == 1'1U then", "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL", 'else', 'PC = PC + 4LL', 'endif']},
  'S_CEIL_F16': {'opcode': 107, 'section': 'SOPC', 'pseudocode': ['D0.f16 = trunc(S0.f16);', "if ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then", "D0.f16 += 16'1.0", 'endif']},
  'S_CEIL_F32': {'opcode': 96, 'section': 'SOP1', 'pseudocode': ['D0.f32 = trunc(S0.f32);', 'if ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then', 'D0.f32 += 1.0F', 'endif']},
  'S_CLS_I32': {'opcode': 12, 'section': 'SOP1', 'pseudocode': ['tmp = -1;', '// Set if all bits are the same', 'for i in 1 : 31 do', '// Search from MSB', 'if S0.u32[31 - i] != S0.u32[31] then', 'tmp = i;', 'endif', 'D0.i32 = tmp']},
  'S_CLS_I32_I64': {'opcode': 13, 'section': 'SOP1', 'pseudocode': ['tmp = -1;', '// Set if all bits are the same', 'for i in 1 : 63 do']},
  'S_CLZ_I32_U32': {'opcode': 10, 'section': 'SOPK', 'pseudocode': ['tmp = -1;', '// Set if no ones are found', 'for i in 0 : 31 do', '// Search from MSB', "if S0.u32[31 - i] == 1'1U then", 'tmp = i;', 'endif', 'D0.i32 = tmp']},
  'S_CLZ_I32_U64': {'opcode': 11, 'section': 'SOPK', 'pseudocode': ['tmp = -1;']},
  'S_CMOVK_I32': {'opcode': 2, 'section': 'SOP2', 'pseudocode': ['if SCC then']},
  'S_CMOV_B32': {'opcode': 2, 'section': 'SOPK', 'pseudocode': ['if SCC then', 'D0.b32 = S0.b32', 'endif']},
  'S_CMOV_B64': {'opcode': 3, 'section': 'SOPK', 'pseudocode': ['if SCC then', 'D0.b64 = S0.b64', 'endif']},
  'S_CMPK_EQ_I32': {'opcode': 3, 'section': 'SOPK', 'pseudocode': ["SCC = 64'I(S0.i32) == signext(SIMM16.i16)"]},
  'S_CMPK_EQ_U32': {'opcode': 9, 'section': 'SOPK', 'pseudocode': ["SCC = S0.u32 == 32'U(SIMM16.u16)"]},
  'S_CMPK_GE_I32': {'opcode': 6, 'section': 'SOPK', 'pseudocode': ["SCC = 64'I(S0.i32) >= signext(SIMM16.i16)"]},
  'S_CMPK_GE_U32': {'opcode': 12, 'section': 'SOPK', 'pseudocode': ["SCC = S0.u32 >= 32'U(SIMM16.u16)"]},
  'S_CMPK_GT_I32': {'opcode': 5, 'section': 'SOPK', 'pseudocode': ["SCC = 64'I(S0.i32) > signext(SIMM16.i16)"]},
  'S_CMPK_GT_U32': {'opcode': 11, 'section': 'SOPK', 'pseudocode': ["SCC = S0.u32 > 32'U(SIMM16.u16)"]},
  'S_CMPK_LE_I32': {'opcode': 8, 'section': 'SOPK', 'pseudocode': ["SCC = 64'I(S0.i32) <= signext(SIMM16.i16)"]},
  'S_CMPK_LE_U32': {'opcode': 14, 'section': 'SOPK', 'pseudocode': ["SCC = S0.u32 <= 32'U(SIMM16.u16)"]},
  'S_CMPK_LG_I32': {'opcode': 4, 'section': 'SOPK', 'pseudocode': ["SCC = 64'I(S0.i32) != signext(SIMM16.i16)"]},
  'S_CMPK_LG_U32': {'opcode': 10, 'section': 'SOPK', 'pseudocode': ["SCC = S0.u32 != 32'U(SIMM16.u16)"]},
  'S_CMPK_LT_I32': {'opcode': 7, 'section': 'SOPK', 'pseudocode': ["SCC = 64'I(S0.i32) < signext(SIMM16.i16)"]},
  'S_CMP_EQ_F16': {'opcode': 82, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f16 == S1.f16']},
  'S_CMP_EQ_F32': {'opcode': 66, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f32 == S1.f32']},
  'S_CMP_EQ_I32': {'opcode': 0, 'section': 'SOPC', 'pseudocode': ['SCC = S0.i32 == S1.i32']},
  'S_CMP_EQ_U32': {'opcode': 6, 'section': 'SOPC', 'pseudocode': ['SCC = S0.u32 == S1.u32']},
  'S_CMP_EQ_U64': {'opcode': 16, 'section': 'SOPC', 'pseudocode': ['SCC = S0.u64 == S1.u64']},
  'S_CMP_GE_F16': {'opcode': 86, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f16 >= S1.f16']},
  'S_CMP_GE_F32': {'opcode': 70, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f32 >= S1.f32']},
  'S_CMP_GE_I32': {'opcode': 3, 'section': 'SOPC', 'pseudocode': ['SCC = S0.i32 >= S1.i32']},
  'S_CMP_GE_U32': {'opcode': 9, 'section': 'SOPC', 'pseudocode': ['SCC = S0.u32 >= S1.u32']},
  'S_CMP_GT_F16': {'opcode': 84, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f16 > S1.f16']},
  'S_CMP_GT_F32': {'opcode': 68, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f32 > S1.f32']},
  'S_CMP_GT_I32': {'opcode': 2, 'section': 'SOPC', 'pseudocode': ['SCC = S0.i32 > S1.i32']},
  'S_CMP_GT_U32': {'opcode': 8, 'section': 'SOPC', 'pseudocode': ['SCC = S0.u32 > S1.u32']},
  'S_CMP_LE_F16': {'opcode': 83, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f16 <= S1.f16']},
  'S_CMP_LE_F32': {'opcode': 67, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f32 <= S1.f32']},
  'S_CMP_LE_I32': {'opcode': 5, 'section': 'SOPC', 'pseudocode': ['SCC = S0.i32 <= S1.i32']},
  'S_CMP_LE_U32': {'opcode': 11, 'section': 'SOPC', 'pseudocode': ['SCC = S0.u32 <= S1.u32']},
  'S_CMP_LG_F16': {'opcode': 85, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f16 <> S1.f16']},
  'S_CMP_LG_F32': {'opcode': 69, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f32 <> S1.f32']},
  'S_CMP_LG_I32': {'opcode': 1, 'section': 'SOPC', 'pseudocode': ['SCC = S0.i32 <> S1.i32']},
  'S_CMP_LG_U32': {'opcode': 7, 'section': 'SOPC', 'pseudocode': ['SCC = S0.u32 <> S1.u32']},
  'S_CMP_LG_U64': {'opcode': 17, 'section': 'SOPC', 'pseudocode': ['SCC = S0.u64 <> S1.u64']},
  'S_CMP_LT_F32': {'opcode': 65, 'section': 'SOPC', 'pseudocode': ['SCC = S0.f32 < S1.f32']},
  'S_CMP_LT_I32': {'opcode': 4, 'section': 'SOPC', 'pseudocode': ['SCC = S0.i32 < S1.i32']},
  'S_CMP_LT_U32': {'opcode': 10, 'section': 'SOPC', 'pseudocode': ['SCC = S0.u32 < S1.u32']},
  'S_CMP_NEQ_F16': {'opcode': 93, 'section': 'SOPP', 'pseudocode': ['SCC = !(S0.f16 == S1.f16);', '// With NAN inputs this is not the same operation as !=']},
  'S_CMP_NEQ_F32': {'opcode': 77, 'section': 'SOPP', 'pseudocode': ['SCC = !(S0.f32 == S1.f32);', '// With NAN inputs this is not the same operation as !=']},
  'S_CMP_NGE_F16': {'opcode': 89, 'section': 'SOPC', 'pseudocode': ['SCC = !(S0.f16 >= S1.f16);', '// With NAN inputs this is not the same operation as <']},
  'S_CMP_NGE_F32': {'opcode': 73, 'section': 'SOPC', 'pseudocode': ['SCC = !(S0.f32 >= S1.f32);', '// With NAN inputs this is not the same operation as <']},
  'S_CMP_NGT_F16': {'opcode': 91, 'section': 'SOPC', 'pseudocode': ['SCC = !(S0.f16 > S1.f16);', '// With NAN inputs this is not the same operation as <=']},
  'S_CMP_NGT_F32': {'opcode': 75, 'section': 'SOPC', 'pseudocode': ['SCC = !(S0.f32 > S1.f32);', '// With NAN inputs this is not the same operation as <=']},
  'S_CMP_NLE_F16': {'opcode': 92, 'section': 'SOPP', 'pseudocode': ['SCC = !(S0.f16 <= S1.f16);', '// With NAN inputs this is not the same operation as >']},
  'S_CMP_NLE_F32': {'opcode': 76, 'section': 'SOPC', 'pseudocode': ['SCC = !(S0.f32 <= S1.f32);', '// With NAN inputs this is not the same operation as >']},
  'S_CMP_NLG_F16': {'opcode': 90, 'section': 'SOPC', 'pseudocode': ['SCC = !(S0.f16 <> S1.f16);', '// With NAN inputs this is not the same operation as ==']},
  'S_CMP_NLG_F32': {'opcode': 74, 'section': 'SOPC', 'pseudocode': ['SCC = !(S0.f32 <> S1.f32);', '// With NAN inputs this is not the same operation as ==']},
  'S_CMP_NLT_F16': {'opcode': 94, 'section': 'SOPP', 'pseudocode': ['SCC = !(S0.f16 < S1.f16);', '// With NAN inputs this is not the same operation as >=']},
  'S_CMP_NLT_F32': {'opcode': 78, 'section': 'SOPP', 'pseudocode': ['SCC = !(S0.f32 < S1.f32);', '// With NAN inputs this is not the same operation as >=']},
  'S_CMP_O_F16': {'opcode': 87, 'section': 'SOPC', 'pseudocode': ["SCC = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)))"]},
  'S_CMP_U_F16': {'opcode': 88, 'section': 'SOPC', 'pseudocode': ["SCC = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)))"]},
  'S_CMP_U_F32': {'opcode': 72, 'section': 'SOPC', 'pseudocode': ["SCC = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)))"]},
  'S_CSELECT_B32': {'opcode': 48, 'section': 'SOP2', 'pseudocode': ['D0.u32 = SCC ? S0.u32 : S1.u32']},
  'S_CSELECT_B64': {'opcode': 49, 'section': 'SOP2', 'pseudocode': ['D0.u64 = SCC ? S0.u64 : S1.u64']},
  'S_CTZ_I32_B32': {'opcode': 8, 'section': 'SOPK', 'pseudocode': ['tmp = -1;', '// Set if no ones are found', 'for i in 0 : 31 do', '// Search from LSB', "if S0.u32[i] == 1'1U then", 'tmp = i;', 'endif', 'D0.i32 = tmp']},
  'S_CVT_F16_F32': {'opcode': 104, 'section': 'SOPC', 'pseudocode': ['D0.f16 = f32_to_f16(S0.f32)']},
  'S_CVT_F32_F16': {'opcode': 105, 'section': 'SOPC', 'pseudocode': ['D0.f32 = f16_to_f32(S0.f16)']},
  'S_CVT_F32_I32': {'opcode': 100, 'section': 'SOP1', 'pseudocode': ['D0.f32 = i32_to_f32(S0.i32)']},
  'S_CVT_I32_F32': {'opcode': 102, 'section': 'SOPC', 'pseudocode': ['D0.i32 = f32_to_i32(S0.f32)']},
  'S_CVT_PK_RTZ_F16_F32': {'opcode': 72, 'section': 'SOP2', 'pseudocode': ['prev_mode = ROUND_MODE;', 'tmp[15 : 0].f16 = f32_to_f16(S0.f32);', 'tmp[31 : 16].f16 = f32_to_f16(S1.f32);']},
  'S_CVT_U32_F32': {'opcode': 103, 'section': 'SOPC', 'pseudocode': ['D0.u32 = f32_to_u32(S0.f32)']},
  'S_FLOOR_F16': {'opcode': 108, 'section': 'SOPC', 'pseudocode': ['D0.f16 = trunc(S0.f16);', "if ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then", "D0.f16 += -16'1.0", 'endif']},
  'S_FLOOR_F32': {'opcode': 97, 'section': 'SOP1', 'pseudocode': ['D0.f32 = trunc(S0.f32);', 'if ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then', 'D0.f32 += -1.0F', 'endif']},
  'S_FMAAK_F32': {'opcode': 69, 'section': 'SOP2', 'pseudocode': ['D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)']},
  'S_FMAC_F16': {'opcode': 78, 'section': 'SOP2', 'pseudocode': ['D0.f16 = fma(S0.f16, S1.f16, D0.f16)']},
  'S_FMAC_F32': {'opcode': 71, 'section': 'SOP2', 'pseudocode': ['D0.f32 = fma(S0.f32, S1.f32, D0.f32)']},
  'S_FMAMK_F32': {'opcode': 70, 'section': 'SOP2', 'pseudocode': ['D0.f32 = fma(S0.f32, SIMM32.f32, S1.f32)']},
  'S_GETPC_B64': {'opcode': 71, 'section': 'SOP1', 'pseudocode': ['D0.i64 = PC + 4LL']},
  'S_LSHL1_ADD_U32': {'opcode': 14, 'section': 'SOP2', 'pseudocode': ["tmp = (64'U(S0.u32) << 1U) + 64'U(S1.u32);", "SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;", 'D0.u32 = tmp.u32']},
  'S_LSHL2_ADD_U32': {'opcode': 15, 'section': 'SOP2', 'pseudocode': ["tmp = (64'U(S0.u32) << 2U) + 64'U(S1.u32);", "SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;", 'D0.u32 = tmp.u32']},
  'S_LSHL3_ADD_U32': {'opcode': 16, 'section': 'SOP2', 'pseudocode': ["tmp = (64'U(S0.u32) << 3U) + 64'U(S1.u32);", "SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;", 'D0.u32 = tmp.u32']},
  'S_LSHL4_ADD_U32': {'opcode': 17, 'section': 'SOP2', 'pseudocode': ["tmp = (64'U(S0.u32) << 4U) + 64'U(S1.u32);", "SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;", 'D0.u32 = tmp.u32']},
  'S_LSHL_B32': {'opcode': 8, 'section': 'SOP2', 'pseudocode': ['D0.u32 = (S0.u32 << S1[4 : 0].u32);', 'SCC = D0.u32 != 0U']},
  'S_LSHL_B64': {'opcode': 9, 'section': 'SOP2', 'pseudocode': ['D0.u64 = (S0.u64 << S1[5 : 0].u32);', 'SCC = D0.u64 != 0ULL']},
  'S_LSHR_B32': {'opcode': 10, 'section': 'SOP2', 'pseudocode': ['D0.u32 = (S0.u32 >> S1[4 : 0].u32);', 'SCC = D0.u32 != 0U']},
  'S_MAX_F16': {'opcode': 76, 'section': 'SOP2', 'pseudocode': ['// Version of comparison where +0.0 > -0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', "if isSignalNAN(64'F(S0.f16)) then", "D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))", "elsif isSignalNAN(64'F(S1.f16)) then", "D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))", "elsif isQuietNAN(64'F(S1.f16)) then", 'D0.f16 = S0.f16', "elsif isQuietNAN(64'F(S0.f16)) then", 'D0.f16 = S1.f16', 'elsif GT_NEG_ZERO(S0.f16, S1.f16) then', '// NOTE: +0>-0 is TRUE in this comparison', 'D0.f16 = S0.f16', 'else', 'D0.f16 = S1.f16', 'endif', 'else', "if isNAN(64'F(S1.f16)) then"]},
  'S_MAX_F32': {'opcode': 67, 'section': 'SOP2', 'pseudocode': ['// Version of comparison where +0.0 > -0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', "if isSignalNAN(64'F(S0.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))", "elsif isSignalNAN(64'F(S1.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))", "elsif isQuietNAN(64'F(S1.f32)) then", 'D0.f32 = S0.f32']},
  'S_MAX_U32': {'opcode': 21, 'section': 'SOP2', 'pseudocode': ['SCC = S0.u32 >= S1.u32;', 'D0.u32 = SCC ? S0.u32 : S1.u32']},
  'S_MIN_F16': {'opcode': 75, 'section': 'SOP2', 'pseudocode': ['// Version of comparison where -0.0 < +0.0, differs from IEEE']},
  'S_MIN_F32': {'opcode': 66, 'section': 'SOP2', 'pseudocode': ['// Version of comparison where -0.0 < +0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', "if isSignalNAN(64'F(S0.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))", "elsif isSignalNAN(64'F(S1.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))", "elsif isQuietNAN(64'F(S1.f32)) then", 'D0.f32 = S0.f32', "elsif isQuietNAN(64'F(S0.f32)) then", 'D0.f32 = S1.f32', 'elsif LT_NEG_ZERO(S0.f32, S1.f32) then', '// NOTE: -0<+0 is TRUE in this comparison', 'D0.f32 = S0.f32', 'else', 'D0.f32 = S1.f32', 'endif', 'else', "if isNAN(64'F(S1.f32)) then", 'D0.f32 = S0.f32', "elsif isNAN(64'F(S0.f32)) then", 'D0.f32 = S1.f32', 'elsif LT_NEG_ZERO(S0.f32, S1.f32) then', '// NOTE: -0<+0 is TRUE in this comparison', 'D0.f32 = S0.f32', 'else', 'D0.f32 = S1.f32', 'endif', 'endif;', '// Inequalities in the above pseudocode behave differently from IEEE']},
  'S_MIN_I32': {'opcode': 18, 'section': 'SOP2', 'pseudocode': ['SCC = S0.i32 < S1.i32;', 'D0.i32 = SCC ? S0.i32 : S1.i32']},
  'S_MIN_U32': {'opcode': 19, 'section': 'SOP2', 'pseudocode': ['SCC = S0.u32 < S1.u32;', 'D0.u32 = SCC ? S0.u32 : S1.u32']},
  'S_MOVK_I32': {'opcode': 0, 'section': 'SOP2', 'pseudocode': ["D0.i32 = 32'I(signext(SIMM16.i16))"]},
  'S_MOVRELD_B32': {'opcode': 66, 'section': 'SOP1', 'pseudocode': ['addr = DST.u32;', '// Raw value from instruction']},
  'S_MOVRELD_B64': {'opcode': 67, 'section': 'SOP1', 'pseudocode': ['addr = DST.u32;', '// Raw value from instruction', 'SGPR[addr].b64 = S0.b64']},
  'S_MOVRELSD_2_B32': {'opcode': 68, 'section': 'SOP1', 'pseudocode': ['addrs = SRC0.u32;', '// Raw value from instruction', 'addrd = DST.u32;', '// Raw value from instruction']},
  'S_MOVRELS_B32': {'opcode': 64, 'section': 'SOP1', 'pseudocode': ['addr = SRC0.u32;', '// Raw value from instruction', 'D0.b32 = SGPR[addr].b32']},
  'S_MOVRELS_B64': {'opcode': 65, 'section': 'SOP1', 'pseudocode': ['addr = SRC0.u32;', '// Raw value from instruction', 'D0.b64 = SGPR[addr].b64']},
  'S_MOV_B32': {'opcode': 0, 'section': 'SOPK', 'pseudocode': ['D0.b32 = S0.b32']},
  'S_MOV_B64': {'opcode': 1, 'section': 'SOPK', 'pseudocode': ['D0.b64 = S0.b64']},
  'S_MULK_I32': {'opcode': 16, 'section': 'SOPK', 'pseudocode': ["D0.i32 = 32'I(64'I(D0.i32) * signext(SIMM16.i16))"]},
  'S_MUL_F16': {'opcode': 77, 'section': 'SOP2', 'pseudocode': ['D0.f16 = S0.f16 * S1.f16']},
  'S_MUL_F32': {'opcode': 68, 'section': 'SOP2', 'pseudocode': ['D0.f32 = S0.f32 * S1.f32']},
  'S_MUL_HI_I32': {'opcode': 46, 'section': 'SOP2', 'pseudocode': ["D0.i32 = 32'I((64'I(S0.i32) * 64'I(S1.i32)) >> 32U)"]},
  'S_MUL_HI_U32': {'opcode': 45, 'section': 'SOP2', 'pseudocode': ["D0.u32 = 32'U((64'U(S0.u32) * 64'U(S1.u32)) >> 32U)"]},
  'S_MUL_I32': {'opcode': 44, 'section': 'SOP2', 'pseudocode': ['D0.i32 = S0.i32 * S1.i32']},
  'S_NAND_B32': {'opcode': 28, 'section': 'SOP2', 'pseudocode': ['D0.u32 = ~(S0.u32 & S1.u32);', 'SCC = D0.u32 != 0U']},
  'S_NAND_SAVEEXEC_B32': {'opcode': 38, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise NAND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar', 'saveexec = EXEC.u32;', 'EXEC.u32 = ~(S0.u32 & EXEC.u32);', 'D0.u32 = saveexec.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_NAND_SAVEEXEC_B64': {'opcode': 39, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise NAND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar', 'saveexec = EXEC.u64;', 'EXEC.u64 = ~(S0.u64 & EXEC.u64);', 'D0.u64 = saveexec.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'S_NOP': {'opcode': 0, 'section': 'SOPP', 'pseudocode': ['for i in 0U : SIMM16.u16[3 : 0].u32 do']},
  'S_NOR_B32': {'opcode': 30, 'section': 'SOP2', 'pseudocode': ['D0.u32 = ~(S0.u32 | S1.u32);', 'SCC = D0.u32 != 0U']},
  'S_NOR_B64': {'opcode': 31, 'section': 'SOP2', 'pseudocode': ['D0.u64 = ~(S0.u64 | S1.u64);', 'SCC = D0.u64 != 0ULL']},
  'S_NOR_SAVEEXEC_B32': {'opcode': 40, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise NOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,']},
  'S_NOR_SAVEEXEC_B64': {'opcode': 41, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise NOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar', 'saveexec = EXEC.u64;', 'EXEC.u64 = ~(S0.u64 | EXEC.u64);', 'D0.u64 = saveexec.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'S_NOT_B32': {'opcode': 30, 'section': 'SOP1', 'pseudocode': ['D0.u32 = ~S0.u32;', 'SCC = D0.u32 != 0U']},
  'S_NOT_B64': {'opcode': 31, 'section': 'SOP1', 'pseudocode': ['D0.u64 = ~S0.u64;', 'SCC = D0.u64 != 0ULL']},
  'S_OR_B32': {'opcode': 24, 'section': 'SOP2', 'pseudocode': ['D0.u32 = (S0.u32 | S1.u32);', 'SCC = D0.u32 != 0U']},
  'S_OR_B64': {'opcode': 25, 'section': 'SOP2', 'pseudocode': ['D0.u64 = (S0.u64 | S1.u64);', 'SCC = D0.u64 != 0ULL']},
  'S_OR_NOT0_SAVEEXEC_B32': {'opcode': 46, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the', 'EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the', 'saveexec = EXEC.u32;', 'EXEC.u32 = (~S0.u32 | EXEC.u32);', 'D0.u32 = saveexec.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_OR_NOT0_SAVEEXEC_B64': {'opcode': 47, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the', 'EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the']},
  'S_OR_NOT1_B32': {'opcode': 36, 'section': 'SOP2', 'pseudocode': ['D0.u32 = (S0.u32 | ~S1.u32);', 'SCC = D0.u32 != 0U']},
  'S_OR_NOT1_B64': {'opcode': 37, 'section': 'SOP2', 'pseudocode': ['D0.u64 = (S0.u64 | ~S1.u64);', 'SCC = D0.u64 != 0ULL']},
  'S_OR_NOT1_SAVEEXEC_B32': {'opcode': 50, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the', 'EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the']},
  'S_OR_NOT1_SAVEEXEC_B64': {'opcode': 51, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the', 'EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the', 'saveexec = EXEC.u64;', 'EXEC.u64 = (S0.u64 | ~EXEC.u64);', 'D0.u64 = saveexec.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'S_OR_SAVEEXEC_B32': {'opcode': 34, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set', 'SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination', 'saveexec = EXEC.u32;', 'EXEC.u32 = (S0.u32 | EXEC.u32);', 'D0.u32 = saveexec.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_OR_SAVEEXEC_B64': {'opcode': 35, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set', 'SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination', 'saveexec = EXEC.u64;', 'EXEC.u64 = (S0.u64 | EXEC.u64);', 'D0.u64 = saveexec.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'S_QUADMASK_B32': {'opcode': 26, 'section': 'SOP1', 'pseudocode': ['tmp = 0U;', 'for i in 0 : 7 do', 'tmp[i] = S0.u32[i * 4 +: 4] != 0U', 'D0.u32 = tmp;', 'SCC = D0.u32 != 0U']},
  'S_QUADMASK_B64': {'opcode': 27, 'section': 'SOP1', 'pseudocode': ['tmp = 0ULL;', 'for i in 0 : 15 do', 'tmp[i] = S0.u64[i * 4 +: 4] != 0ULL', 'D0.u64 = tmp;', 'SCC = D0.u64 != 0ULL']},
  'S_RNDNE_F16': {'opcode': 110, 'section': 'SOPC', 'pseudocode': ["D0.f16 = floor(S0.f16 + 16'0.5);", "if (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then", "D0.f16 -= 16'1.0"]},
  'S_RNDNE_F32': {'opcode': 99, 'section': 'SOP1', 'pseudocode': ['D0.f32 = floor(S0.f32 + 0.5F);', "if (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then", 'D0.f32 -= 1.0F', 'endif']},
  'S_SENDMSG_RTN_B32': {'opcode': 76, 'section': 'SOP1', 'pseudocode': ['If SDST is VCC then VCCZ is undefined.']},
  'S_SENDMSG_RTN_B64': {'opcode': 77, 'section': 'SOP1', 'pseudocode': ['If SDST is VCC then VCCZ is undefined.']},
  'S_SETHALT': {'opcode': 2, 'section': 'SOPP', 'pseudocode': ['When halt type control is set to 1 (FATAL HALT bit select): Set FATAL_HALT bit to value of SIMM16[0]; 1 =', 'fatal_halt, 0 = clear FATAL_HALT bit. Setting the fatal_halt flag halts the shader in or outside of the trap']},
  'S_SETPC_B64': {'opcode': 72, 'section': 'SOP1', 'pseudocode': ['PC = S0.i64']},
  'S_SETREG_B32': {'opcode': 18, 'section': 'SOPK', 'pseudocode': ['offset = SIMM16.u16[10 : 6];', 'size = SIMM16.u16[15 : 11].u32 + 1U;', '// logical size is in range 1:32', 'mask = (1 << size) - 1;', "mask = (mask & 32'I(writeableBitMask(hwRegId.u32, WAVE_STATUS.PRIV)));", '// Mask of bits we are allowed to modify', 'value = ((S0.u32 << offset.u32) & mask.u32);', "value = (value | 32'U(HW_REGISTERS[hwRegId].i32 & ~mask));", '// Side-effects may trigger here if certain bits are modified']},
  'S_SEXT_I32_I16': {'opcode': 15, 'section': 'SOP1', 'pseudocode': ["D0.i32 = 32'I(signext(S0.i16))"]},
  'S_SEXT_I32_I8': {'opcode': 14, 'section': 'SOP1', 'pseudocode': ["D0.i32 = 32'I(signext(S0.i8))"]},
  'S_SUBB_U32': {'opcode': 5, 'section': 'SOP2', 'pseudocode': ['tmp = S0.u32 - S1.u32 - SCC.u32;', "SCC = 64'U(S1.u32) + SCC.u64 > 64'U(S0.u32) ? 1'1U : 1'0U;", 'D0.u32 = tmp.u32']},
  'S_SUB_F16': {'opcode': 74, 'section': 'SOP2', 'pseudocode': ['D0.f16 = S0.f16 - S1.f16']},
  'S_SUB_F32': {'opcode': 65, 'section': 'SOP2', 'pseudocode': ['D0.f32 = S0.f32 - S1.f32']},
  'S_SUB_U32': {'opcode': 1, 'section': 'SOP2', 'pseudocode': ['tmp = S0.u32 - S1.u32;', "SCC = S1.u32 > S0.u32 ? 1'1U : 1'0U;", 'D0.u32 = tmp.u32']},
  'S_SWAPPC_B64': {'opcode': 73, 'section': 'SOP1', 'pseudocode': ['jump_addr = S0.i64;', 'D0.i64 = PC + 4LL;']},
  'S_TRAP': {'opcode': 16, 'section': 'SOPP', 'pseudocode': ['// PC passed into trap handler points to S_TRAP itself,', '// trap base address']},
  'S_TRUNC_F16': {'opcode': 109, 'section': 'SOPC', 'pseudocode': ['D0.f16 = trunc(S0.f16)']},
  'S_TRUNC_F32': {'opcode': 98, 'section': 'SOP1', 'pseudocode': ['D0.f32 = trunc(S0.f32)']},
  'S_VERSION': {'opcode': 1, 'section': 'SOP2', 'pseudocode': ['// Do nothing - for use by tools only']},
  'S_WAITCNT_EXPCNT': {'opcode': 26, 'section': 'SOPK', 'pseudocode': ['expcnt <= S0.u[2:0] + S1.u[2:0].', '// Comparison is 3 bits, no clamping is applied for add overflow']},
  'S_WAITCNT_VMCNT': {'opcode': 25, 'section': 'SOPK', 'pseudocode': ['vmcnt <= S0.u[5:0] + S1.u[5:0].', '// Comparison is 6 bits, no clamping is applied for add overflow']},
  'S_WAITCNT_VSCNT': {'opcode': 24, 'section': 'SOPK', 'pseudocode': ['vscnt <= S0.u[5:0] + S1.u[5:0].']},
  'S_WQM_B32': {'opcode': 28, 'section': 'SOP1', 'pseudocode': ['tmp = 0U;', "declare i : 6'U;", "for i in 6'0U : 6'31U do", "tmp[i] = S0.u32[i & 6'60U +: 6'4U] != 0U", 'D0.u32 = tmp;', 'SCC = D0.u32 != 0U']},
  'S_WQM_B64': {'opcode': 29, 'section': 'SOP1', 'pseudocode': ['tmp = 0ULL;', "declare i : 6'U;", "for i in 6'0U : 6'63U do", "tmp[i] = S0.u64[i & 6'60U +: 6'4U] != 0ULL", 'D0.u64 = tmp;']},
  'S_XNOR_B32': {'opcode': 32, 'section': 'SOP2', 'pseudocode': ['D0.u32 = ~(S0.u32 ^ S1.u32);', 'SCC = D0.u32 != 0U']},
  'S_XNOR_B64': {'opcode': 33, 'section': 'SOP2', 'pseudocode': ['D0.u64 = ~(S0.u64 ^ S1.u64);', 'SCC = D0.u64 != 0ULL']},
  'S_XNOR_SAVEEXEC_B32': {'opcode': 42, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise XNOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar', 'saveexec = EXEC.u32;', 'EXEC.u32 = ~(S0.u32 ^ EXEC.u32);', 'D0.u32 = saveexec.u32;', 'SCC = EXEC.u32 != 0U']},
  'S_XNOR_SAVEEXEC_B64': {'opcode': 43, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise XNOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar', 'saveexec = EXEC.u64;', 'EXEC.u64 = ~(S0.u64 ^ EXEC.u64);', 'D0.u64 = saveexec.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'S_XOR_B32': {'opcode': 26, 'section': 'SOP2', 'pseudocode': ['D0.u32 = (S0.u32 ^ S1.u32);', 'SCC = D0.u32 != 0U']},
  'S_XOR_B64': {'opcode': 27, 'section': 'SOP2', 'pseudocode': ['D0.u64 = (S0.u64 ^ S1.u64);', 'SCC = D0.u64 != 0ULL']},
  'S_XOR_SAVEEXEC_B32': {'opcode': 36, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar', 'saveexec = EXEC.u32;', 'EXEC.u32 = (S0.u32 ^ EXEC.u32);', 'D0.u32 = saveexec.u32;']},
  'S_XOR_SAVEEXEC_B64': {'opcode': 37, 'section': 'SOP1', 'pseudocode': ['Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,', 'set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar', 'saveexec = EXEC.u64;', 'EXEC.u64 = (S0.u64 ^ EXEC.u64);', 'D0.u64 = saveexec.u64;', 'SCC = EXEC.u64 != 0ULL']},
  'V_ADD_CO_CI_U32': {'opcode': 288, 'section': 'VOP2_VOP3', 'pseudocode': ["tmp = 64'U(S0.u32) + 64'U(S1.u32) + VCC.u64[laneId].u64;", "VCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;", '// VCC is an UNSIGNED overflow/carry-out for V_ADD_CO_CI_U32.', 'D0.u32 = tmp.u32']},
  'V_ADD_CO_U32': {'opcode': 768, 'section': 'VOP2_VOP3', 'pseudocode': ["tmp = 64'U(S0.u32) + 64'U(S1.u32);"]},
  'V_ADD_F16': {'opcode': 306, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = S0.f16 + S1.f16']},
  'V_ADD_F32': {'opcode': 259, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = S0.f32 + S1.f32']},
  'V_ADD_F64': {'opcode': 807, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = S0.f64 + S1.f64']},
  'V_ADD_LSHL_U32': {'opcode': 583, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = ((S0.u32 + S1.u32) << S2.u32[4 : 0].u32)']},
  'V_ADD_NC_I32': {'opcode': 806, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = S0.i32 + S1.i32']},
  'V_ADD_NC_U32': {'opcode': 293, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = S0.u32 + S1.u32']},
  'V_ALIGNBIT_B32': {'opcode': 534, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.u32 = 32'U(({ S0.u32, S1.u32 } >> S2.u32[4 : 0].u32) & 0xffffffffLL)"]},
  'V_ALIGNBYTE_B32': {'opcode': 535, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.u32 = 32'U(({ S0.u32, S1.u32 } >> (S2.u32[1 : 0].u32 * 8U)) & 0xffffffffLL)"]},
  'V_AND_B16': {'opcode': 866, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = (S0.u16 & S1.u16)']},
  'V_AND_B32': {'opcode': 283, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (S0.u32 & S1.u32)']},
  'V_AND_OR_B32': {'opcode': 599, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = ((S0.u32 & S1.u32) | S2.u32)']},
  'V_ASHRREV_I16': {'opcode': 826, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i16 = (S1.i16 >> S0[3 : 0].u32)']},
  'V_ASHRREV_I32': {'opcode': 282, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = (S1.i32 >> S0[4 : 0].u32)']},
  'V_ASHRREV_I64': {'opcode': 830, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i64 = (S1.i64 >> S0[5 : 0].u32)']},
  'V_BCNT_U32_B32': {'opcode': 798, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S1.u32;', 'for i in 0 : 31 do', "// count i'th bit", 'D0.u32 = tmp']},
  'V_BFE_I32': {'opcode': 529, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S2[4 : 0].u32) - 1));', 'D0.i32 = signext_from_bit(tmp.i32, S2[4 : 0].u32)']},
  'V_BFI_B32': {'opcode': 530, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = ((S0.u32 & S1.u32) | (~S0.u32 & S2.u32))']},
  'V_BFM_B32': {'opcode': 797, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (((1U << S0[4 : 0].u32) - 1U) << S1[4 : 0].u32)']},
  'V_BFREV_B32': {'opcode': 440, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32[31 : 0] = S0.u32[0 : 31]']},
  'V_CEIL_F16': {'opcode': 476, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = trunc(S0.f16);', "if ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then", "D0.f16 += 16'1.0", 'endif']},
  'V_CEIL_F32': {'opcode': 418, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = trunc(S0.f32);', 'if ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then', 'D0.f32 += 1.0F', 'endif']},
  'V_CEIL_F64': {'opcode': 408, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = trunc(S0.f64);', 'if ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then', 'D0.f64 += 1.0', 'endif']},
  'V_CLS_I32': {'opcode': 443, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = -1;', '// Set if all bits are the same', 'for i in 1 : 31 do', '// Search from MSB']},
  'V_CLZ_I32_U32': {'opcode': 441, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = -1;', '// Set if no ones are found', 'for i in 0 : 31 do', '// Search from MSB', "if S0.u32[31 - i] == 1'1U then", 'D0.i32 = i;', 'endif']},
  'V_CMPX_CLASS_F16': {'opcode': 253, 'section': 'VOP2_VOP3', 'pseudocode': ['S1.u[0] value is a signaling NAN.', 'S1.u[1] value is a quiet NAN.', 'S1.u[2] value is negative infinity.', 'S1.u[3] value is a negative normal value.', 'S1.u[4] value is a negative denormal value.', 'S1.u[5] value is negative zero.', 'S1.u[6] value is positive zero.', 'S1.u[7] value is a positive denormal value.', 'S1.u[8] value is a positive normal value.', 'S1.u[9] value is positive infinity.', "declare result : 1'U;", "if isSignalNAN(64'F(S0.f16)) then", 'result = S1.u32[0]', "elsif isQuietNAN(64'F(S0.f16)) then", 'result = S1.u32[1]', 'elsif exponent(S0.f16) == 31 then', '// +-INF', 'result = S1.u32[sign(S0.f16) ? 2 : 9]', 'elsif exponent(S0.f16) > 0 then', '// +-normal value', 'result = S1.u32[sign(S0.f16) ? 3 : 8]', "elsif 64'F(abs(S0.f16)) > 0.0 then", '// +-denormal value', 'result = S1.u32[sign(S0.f16) ? 4 : 7]', 'else', '// +-0.0', 'result = S1.u32[sign(S0.f16) ? 5 : 6]', 'endif;', 'EXEC.u64[laneId] = result']},
  'V_CMPX_CLASS_F32': {'opcode': 254, 'section': 'VOP2_VOP3', 'pseudocode': ['S1.u[0] value is a signaling NAN.', 'S1.u[1] value is a quiet NAN.', 'S1.u[2] value is negative infinity.', 'S1.u[3] value is a negative normal value.', 'S1.u[4] value is a negative denormal value.', 'S1.u[5] value is negative zero.', 'S1.u[6] value is positive zero.', 'S1.u[7] value is a positive denormal value.', 'S1.u[8] value is a positive normal value.', 'S1.u[9] value is positive infinity.', "declare result : 1'U;", "if isSignalNAN(64'F(S0.f32)) then", 'result = S1.u32[0]', "elsif isQuietNAN(64'F(S0.f32)) then", 'result = S1.u32[1]', 'elsif exponent(S0.f32) == 255 then', '// +-INF', 'result = S1.u32[sign(S0.f32) ? 2 : 9]', 'elsif exponent(S0.f32) > 0 then', '// +-normal value', 'result = S1.u32[sign(S0.f32) ? 3 : 8]', "elsif 64'F(abs(S0.f32)) > 0.0 then", '// +-denormal value', 'result = S1.u32[sign(S0.f32) ? 4 : 7]', 'else', '// +-0.0', 'result = S1.u32[sign(S0.f32) ? 5 : 6]', 'endif;', 'EXEC.u64[laneId] = result']},
  'V_CMPX_CLASS_F64': {'opcode': 255, 'section': 'VOPC', 'pseudocode': ['S1.u[0] value is a signaling NAN.', 'S1.u[1] value is a quiet NAN.', 'S1.u[2] value is negative infinity.', 'S1.u[3] value is a negative normal value.']},
  'V_CMPX_EQ_F16': {'opcode': 130, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.f16 == S1.f16']},
  'V_CMPX_EQ_F32': {'opcode': 146, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.f32 == S1.f32']},
  'V_CMPX_EQ_F64': {'opcode': 162, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.f64 == S1.f64']},
  'V_CMPX_EQ_I16': {'opcode': 178, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.i16 == S1.i16']},
  'V_CMPX_EQ_I32': {'opcode': 194, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.i32 == S1.i32']},
  'V_CMPX_EQ_I64': {'opcode': 210, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.i64 == S1.i64']},
  'V_CMPX_EQ_U16': {'opcode': 186, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.u16 == S1.u16']},
  'V_CMPX_EQ_U32': {'opcode': 202, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.u32 == S1.u32']},
  'V_CMPX_EQ_U64': {'opcode': 218, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC', 'EXEC.u64[laneId] = S0.u64 == S1.u64']},
  'V_CMPX_F_F16': {'opcode': 128, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'0U"]},
  'V_CMPX_F_F32': {'opcode': 144, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'0U"]},
  'V_CMPX_F_F64': {'opcode': 160, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'0U"]},
  'V_CMPX_F_I32': {'opcode': 192, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'0U"]},
  'V_CMPX_F_I64': {'opcode': 208, 'section': 'VOPC', 'pseudocode': ["EXEC.u64[laneId] = 1'0U"]},
  'V_CMPX_F_U32': {'opcode': 200, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'0U"]},
  'V_CMPX_F_U64': {'opcode': 216, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'0U"]},
  'V_CMPX_GE_F16': {'opcode': 134, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = S0.f16 >= S1.f16']},
  'V_CMPX_GE_F32': {'opcode': 150, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f32 >= S1.f32']},
  'V_CMPX_GE_F64': {'opcode': 166, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f64 >= S1.f64']},
  'V_CMPX_GE_I16': {'opcode': 182, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i16 >= S1.i16']},
  'V_CMPX_GE_I32': {'opcode': 198, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i32 >= S1.i32']},
  'V_CMPX_GE_I64': {'opcode': 214, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i64 >= S1.i64']},
  'V_CMPX_GE_U16': {'opcode': 190, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u16 >= S1.u16']},
  'V_CMPX_GE_U32': {'opcode': 206, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u32 >= S1.u32']},
  'V_CMPX_GE_U64': {'opcode': 222, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u64 >= S1.u64']},
  'V_CMPX_GT_F16': {'opcode': 132, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f16 > S1.f16']},
  'V_CMPX_GT_F32': {'opcode': 148, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f32 > S1.f32']},
  'V_CMPX_GT_F64': {'opcode': 164, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f64 > S1.f64']},
  'V_CMPX_GT_I16': {'opcode': 180, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i16 > S1.i16']},
  'V_CMPX_GT_I32': {'opcode': 196, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i32 > S1.i32']},
  'V_CMPX_GT_I64': {'opcode': 212, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i64 > S1.i64']},
  'V_CMPX_GT_U16': {'opcode': 188, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = S0.u16 > S1.u16']},
  'V_CMPX_GT_U32': {'opcode': 204, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = S0.u32 > S1.u32']},
  'V_CMPX_GT_U64': {'opcode': 220, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u64 > S1.u64']},
  'V_CMPX_LE_F16': {'opcode': 131, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f16 <= S1.f16']},
  'V_CMPX_LE_F32': {'opcode': 147, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f32 <= S1.f32']},
  'V_CMPX_LE_F64': {'opcode': 163, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = S0.f64 <= S1.f64']},
  'V_CMPX_LE_I16': {'opcode': 179, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i16 <= S1.i16']},
  'V_CMPX_LE_I32': {'opcode': 195, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i32 <= S1.i32']},
  'V_CMPX_LE_I64': {'opcode': 211, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i64 <= S1.i64']},
  'V_CMPX_LE_U16': {'opcode': 187, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u16 <= S1.u16']},
  'V_CMPX_LE_U32': {'opcode': 203, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u32 <= S1.u32']},
  'V_CMPX_LE_U64': {'opcode': 219, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = S0.u64 <= S1.u64']},
  'V_CMPX_LG_F16': {'opcode': 133, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f16 <> S1.f16']},
  'V_CMPX_LG_F32': {'opcode': 149, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f32 <> S1.f32']},
  'V_CMPX_LG_F64': {'opcode': 165, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f64 <> S1.f64']},
  'V_CMPX_LT_F16': {'opcode': 129, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f16 < S1.f16']},
  'V_CMPX_LT_F32': {'opcode': 145, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = S0.f32 < S1.f32']},
  'V_CMPX_LT_F64': {'opcode': 161, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.f64 < S1.f64']},
  'V_CMPX_LT_I16': {'opcode': 177, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i16 < S1.i16']},
  'V_CMPX_LT_I32': {'opcode': 193, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = S0.i32 < S1.i32']},
  'V_CMPX_LT_I64': {'opcode': 209, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i64 < S1.i64']},
  'V_CMPX_LT_U16': {'opcode': 185, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u16 < S1.u16']},
  'V_CMPX_LT_U32': {'opcode': 201, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u32 < S1.u32']},
  'V_CMPX_LT_U64': {'opcode': 217, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u64 < S1.u64']},
  'V_CMPX_NEQ_F16': {'opcode': 141, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f16 == S1.f16);']},
  'V_CMPX_NEQ_F32': {'opcode': 157, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f32 == S1.f32);', '// With NAN inputs this is not the same operation as !=']},
  'V_CMPX_NEQ_F64': {'opcode': 173, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f64 == S1.f64);', '// With NAN inputs this is not the same operation as !=']},
  'V_CMPX_NE_I16': {'opcode': 181, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i16 <> S1.i16']},
  'V_CMPX_NE_I32': {'opcode': 197, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i32 <> S1.i32']},
  'V_CMPX_NE_I64': {'opcode': 213, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.i64 <> S1.i64']},
  'V_CMPX_NE_U16': {'opcode': 189, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u16 <> S1.u16']},
  'V_CMPX_NE_U32': {'opcode': 205, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u32 <> S1.u32']},
  'V_CMPX_NE_U64': {'opcode': 221, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = S0.u64 <> S1.u64']},
  'V_CMPX_NGE_F16': {'opcode': 137, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f16 >= S1.f16);', '// With NAN inputs this is not the same operation as <']},
  'V_CMPX_NGE_F32': {'opcode': 153, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f32 >= S1.f32);', '// With NAN inputs this is not the same operation as <']},
  'V_CMPX_NGE_F64': {'opcode': 169, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f64 >= S1.f64);', '// With NAN inputs this is not the same operation as <']},
  'V_CMPX_NGT_F16': {'opcode': 139, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f16 > S1.f16);', '// With NAN inputs this is not the same operation as <=']},
  'V_CMPX_NGT_F32': {'opcode': 155, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f32 > S1.f32);', '// With NAN inputs this is not the same operation as <=']},
  'V_CMPX_NGT_F64': {'opcode': 171, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f64 > S1.f64);', '// With NAN inputs this is not the same operation as <=']},
  'V_CMPX_NLE_F16': {'opcode': 140, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f16 <= S1.f16);', '// With NAN inputs this is not the same operation as >']},
  'V_CMPX_NLE_F32': {'opcode': 156, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f32 <= S1.f32);', '// With NAN inputs this is not the same operation as >']},
  'V_CMPX_NLE_F64': {'opcode': 172, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f64 <= S1.f64);', '// With NAN inputs this is not the same operation as >']},
  'V_CMPX_NLG_F16': {'opcode': 138, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f16 <> S1.f16);', '// With NAN inputs this is not the same operation as ==']},
  'V_CMPX_NLG_F32': {'opcode': 154, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f32 <> S1.f32);', '// With NAN inputs this is not the same operation as ==']},
  'V_CMPX_NLG_F64': {'opcode': 170, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f64 <> S1.f64);', '// With NAN inputs this is not the same operation as ==']},
  'V_CMPX_NLT_F16': {'opcode': 142, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f16 < S1.f16);', '// With NAN inputs this is not the same operation as >=']},
  'V_CMPX_NLT_F32': {'opcode': 158, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f32 < S1.f32);', '// With NAN inputs this is not the same operation as >=']},
  'V_CMPX_NLT_F64': {'opcode': 174, 'section': 'VOPC', 'pseudocode': ['EXEC.u64[laneId] = !(S0.f64 < S1.f64);', '// With NAN inputs this is not the same operation as >=']},
  'V_CMPX_O_F16': {'opcode': 135, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)))"]},
  'V_CMPX_O_F32': {'opcode': 151, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)))"]},
  'V_CMPX_O_F64': {'opcode': 167, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64))']},
  'V_CMPX_T_F16': {'opcode': 143, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'1U"]},
  'V_CMPX_T_F32': {'opcode': 159, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'1U"]},
  'V_CMPX_T_F64': {'opcode': 175, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'1U"]},
  'V_CMPX_T_I32': {'opcode': 199, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'1U"]},
  'V_CMPX_T_I64': {'opcode': 215, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'1U"]},
  'V_CMPX_T_U32': {'opcode': 207, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'1U"]},
  'V_CMPX_T_U64': {'opcode': 223, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = 1'1U"]},
  'V_CMPX_U_F16': {'opcode': 136, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)))"]},
  'V_CMPX_U_F32': {'opcode': 152, 'section': 'VOP2_VOP3', 'pseudocode': ["EXEC.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)))"]},
  'V_CMPX_U_F64': {'opcode': 168, 'section': 'VOP2_VOP3', 'pseudocode': ['EXEC.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64))']},
  'V_CMP_CLASS_F16': {'opcode': 125, 'section': 'VOP2_VOP3', 'pseudocode': ['half-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar', 'S1.u[0] value is a signaling NAN.', 'S1.u[1] value is a quiet NAN.', 'S1.u[2] value is negative infinity.', 'S1.u[3] value is a negative normal value.', 'S1.u[4] value is a negative denormal value.', 'S1.u[5] value is negative zero.', 'S1.u[6] value is positive zero.', 'S1.u[7] value is a positive denormal value.', 'S1.u[8] value is a positive normal value.', 'S1.u[9] value is positive infinity.', "declare result : 1'U;"]},
  'V_CMP_CLASS_F32': {'opcode': 126, 'section': 'VOP2_VOP3', 'pseudocode': ['single-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar', 'S1.u[0] value is a signaling NAN.', 'S1.u[1] value is a quiet NAN.', 'S1.u[2] value is negative infinity.', 'S1.u[3] value is a negative normal value.', 'S1.u[4] value is a negative denormal value.', 'S1.u[5] value is negative zero.', 'S1.u[6] value is positive zero.', 'S1.u[7] value is a positive denormal value.', 'S1.u[8] value is a positive normal value.', 'S1.u[9] value is positive infinity.', "declare result : 1'U;", "if isSignalNAN(64'F(S0.f32)) then", 'result = S1.u32[0]', "elsif isQuietNAN(64'F(S0.f32)) then", 'result = S1.u32[1]', 'elsif exponent(S0.f32) == 255 then', '// +-INF']},
  'V_CMP_CLASS_F64': {'opcode': 127, 'section': 'VOP2_VOP3', 'pseudocode': ['double-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar', 'S1.u[0] value is a signaling NAN.', 'S1.u[1] value is a quiet NAN.', 'S1.u[2] value is negative infinity.', 'S1.u[3] value is a negative normal value.', 'S1.u[4] value is a negative denormal value.', 'S1.u[5] value is negative zero.', 'S1.u[6] value is positive zero.', 'S1.u[7] value is a positive denormal value.', 'S1.u[8] value is a positive normal value.', 'S1.u[9] value is positive infinity.', "declare result : 1'U;", 'if isSignalNAN(S0.f64) then', 'result = S1.u32[0]', 'elsif isQuietNAN(S0.f64) then', 'result = S1.u32[1]', 'elsif exponent(S0.f64) == 2047 then', '// +-INF', 'result = S1.u32[sign(S0.f64) ? 2 : 9]', 'elsif exponent(S0.f64) > 0 then', '// +-normal value', 'result = S1.u32[sign(S0.f64) ? 3 : 8]', 'elsif abs(S0.f64) > 0.0 then', '// +-denormal value']},
  'V_CMP_EQ_F16': {'opcode': 2, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.f16 == S1.f16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_EQ_F32': {'opcode': 18, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.f32 == S1.f32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_EQ_F64': {'opcode': 34, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.f64 == S1.f64;']},
  'V_CMP_EQ_I16': {'opcode': 50, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.i16 == S1.i16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_EQ_I32': {'opcode': 66, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.i32 == S1.i32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_EQ_I64': {'opcode': 82, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.i64 == S1.i64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_EQ_U16': {'opcode': 58, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.u16 == S1.u16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_EQ_U32': {'opcode': 74, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.u32 == S1.u32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_EQ_U64': {'opcode': 90, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.u64 == S1.u64;']},
  'V_CMP_F_F16': {'opcode': 0, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 0. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'0U;"]},
  'V_CMP_F_F32': {'opcode': 16, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 0. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'0U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_F_F64': {'opcode': 32, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 0. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'0U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_F_I32': {'opcode': 64, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 0. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'0U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_F_I64': {'opcode': 80, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 0. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'0U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_F_U32': {'opcode': 72, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 0. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'0U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_F_U64': {'opcode': 88, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 0. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'0U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_F16': {'opcode': 6, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f16 >= S1.f16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_F32': {'opcode': 22, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f32 >= S1.f32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_F64': {'opcode': 38, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f64 >= S1.f64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_I16': {'opcode': 54, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.i16 >= S1.i16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_I32': {'opcode': 70, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.i32 >= S1.i32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_I64': {'opcode': 86, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.i64 >= S1.i64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_U16': {'opcode': 62, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.u16 >= S1.u16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_U32': {'opcode': 78, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.u32 >= S1.u32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GE_U64': {'opcode': 94, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.u64 >= S1.u64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GT_F16': {'opcode': 4, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.f16 > S1.f16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GT_F32': {'opcode': 20, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.f32 > S1.f32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GT_F64': {'opcode': 36, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.f64 > S1.f64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GT_I16': {'opcode': 52, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.i16 > S1.i16;']},
  'V_CMP_GT_I32': {'opcode': 68, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.i32 > S1.i32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GT_I64': {'opcode': 84, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.i64 > S1.i64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GT_U16': {'opcode': 60, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.u16 > S1.u16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_GT_U32': {'opcode': 76, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.u32 > S1.u32;']},
  'V_CMP_GT_U64': {'opcode': 92, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC', 'D0.u64[laneId] = S0.u64 > S1.u64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LE_F16': {'opcode': 3, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f16 <= S1.f16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LE_F32': {'opcode': 19, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f32 <= S1.f32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LE_F64': {'opcode': 35, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f64 <= S1.f64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LE_I16': {'opcode': 51, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.i16 <= S1.i16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LE_I32': {'opcode': 67, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.i32 <= S1.i32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LE_I64': {'opcode': 83, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.i64 <= S1.i64;']},
  'V_CMP_LE_U16': {'opcode': 59, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.u16 <= S1.u16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LE_U32': {'opcode': 75, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.u32 <= S1.u32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LE_U64': {'opcode': 91, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.u64 <= S1.u64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LG_F16': {'opcode': 5, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f16 <> S1.f16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LG_F32': {'opcode': 21, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f32 <> S1.f32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LG_F64': {'opcode': 37, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = S0.f64 <> S1.f64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LT_F16': {'opcode': 1, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.f16 < S1.f16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LT_F32': {'opcode': 17, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.f32 < S1.f32;']},
  'V_CMP_LT_F64': {'opcode': 33, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.f64 < S1.f64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LT_I16': {'opcode': 49, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.i16 < S1.i16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LT_I32': {'opcode': 65, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.i32 < S1.i32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LT_I64': {'opcode': 81, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.i64 < S1.i64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LT_U16': {'opcode': 57, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.u16 < S1.u16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LT_U32': {'opcode': 73, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.u32 < S1.u32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_LT_U64': {'opcode': 89, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a', 'D0.u64[laneId] = S0.u64 < S1.u64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NEQ_F16': {'opcode': 13, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC', 'D0.u64[laneId] = !(S0.f16 == S1.f16);', '// With NAN inputs this is not the same operation as !=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NEQ_F32': {'opcode': 29, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC', 'D0.u64[laneId] = !(S0.f32 == S1.f32);', '// With NAN inputs this is not the same operation as !=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NEQ_F64': {'opcode': 45, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC', 'D0.u64[laneId] = !(S0.f64 == S1.f64);', '// With NAN inputs this is not the same operation as !=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NE_I16': {'opcode': 53, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC', 'D0.u64[laneId] = S0.i16 <> S1.i16;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NE_I32': {'opcode': 69, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC']},
  'V_CMP_NE_I64': {'opcode': 85, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC', 'D0.u64[laneId] = S0.i64 <> S1.i64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NE_U16': {'opcode': 61, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC']},
  'V_CMP_NE_U32': {'opcode': 77, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC', 'D0.u64[laneId] = S0.u32 <> S1.u32;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NE_U64': {'opcode': 93, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC', 'D0.u64[laneId] = S0.u64 <> S1.u64;', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NGE_F16': {'opcode': 9, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = !(S0.f16 >= S1.f16);', '// With NAN inputs this is not the same operation as <', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NGE_F32': {'opcode': 25, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = !(S0.f32 >= S1.f32);', '// With NAN inputs this is not the same operation as <', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NGE_F64': {'opcode': 41, 'section': 'VOPC', 'pseudocode': ['D0.u64[laneId] = !(S0.f64 >= S1.f64);', '// With NAN inputs this is not the same operation as <', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NGT_F16': {'opcode': 11, 'section': 'VOP2_VOP3', 'pseudocode': ['VCC or a scalar register.', 'D0.u64[laneId] = !(S0.f16 > S1.f16);', '// With NAN inputs this is not the same operation as <=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NGT_F32': {'opcode': 27, 'section': 'VOP2_VOP3', 'pseudocode': ['VCC or a scalar register.', 'D0.u64[laneId] = !(S0.f32 > S1.f32);', '// With NAN inputs this is not the same operation as <=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NGT_F64': {'opcode': 43, 'section': 'VOP2_VOP3', 'pseudocode': ['VCC or a scalar register.', 'D0.u64[laneId] = !(S0.f64 > S1.f64);', '// With NAN inputs this is not the same operation as <=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLE_F16': {'opcode': 12, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = !(S0.f16 <= S1.f16);', '// With NAN inputs this is not the same operation as >', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLE_F32': {'opcode': 28, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = !(S0.f32 <= S1.f32);', '// With NAN inputs this is not the same operation as >', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLE_F64': {'opcode': 44, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = !(S0.f64 <= S1.f64);', '// With NAN inputs this is not the same operation as >', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLG_F16': {'opcode': 10, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = !(S0.f16 <> S1.f16);', '// With NAN inputs this is not the same operation as ==', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLG_F32': {'opcode': 26, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = !(S0.f32 <> S1.f32);', '// With NAN inputs this is not the same operation as ==', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLG_F64': {'opcode': 42, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64[laneId] = !(S0.f64 <> S1.f64);', '// With NAN inputs this is not the same operation as ==', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLT_F16': {'opcode': 14, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC', 'D0.u64[laneId] = !(S0.f16 < S1.f16);', '// With NAN inputs this is not the same operation as >=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLT_F32': {'opcode': 30, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC', 'D0.u64[laneId] = !(S0.f32 < S1.f32);', '// With NAN inputs this is not the same operation as >=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_NLT_F64': {'opcode': 46, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC', 'D0.u64[laneId] = !(S0.f64 < S1.f64);', '// With NAN inputs this is not the same operation as >=', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_O_F16': {'opcode': 7, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC']},
  'V_CMP_O_F32': {'opcode': 23, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC', "D0.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)));", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_O_F64': {'opcode': 39, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC', 'D0.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64));', '// D0 = VCC in VOPC encoding.']},
  'V_CMP_T_F16': {'opcode': 15, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'1U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_T_F32': {'opcode': 31, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'1U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_T_F64': {'opcode': 47, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'1U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_T_I32': {'opcode': 71, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'1U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_T_I64': {'opcode': 87, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'1U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_T_U32': {'opcode': 79, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'1U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_T_U64': {'opcode': 95, 'section': 'VOP2_VOP3', 'pseudocode': ['Set the per-lane condition code to 1. Store the result into VCC or a scalar register.', "D0.u64[laneId] = 1'1U;", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_U_F16': {'opcode': 8, 'section': 'VOP2_VOP3', 'pseudocode': ['VCC or a scalar register.', "D0.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)));", '// D0 = VCC in VOPC encoding.']},
  'V_CMP_U_F32': {'opcode': 24, 'section': 'VOP2_VOP3', 'pseudocode': ['VCC or a scalar register.']},
  'V_CMP_U_F64': {'opcode': 40, 'section': 'VOP2_VOP3', 'pseudocode': ['VCC or a scalar register.', 'D0.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64));', '// D0 = VCC in VOPC encoding.']},
  'V_CNDMASK_B16': {'opcode': 605, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = VCC.u64[laneId] ? S1.u16 : S0.u16']},
  'V_CNDMASK_B32': {'opcode': 257, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = VCC.u64[laneId] ? S1.u32 : S0.u32']},
  'V_COS_F16': {'opcode': 97, 'section': 'VOP1', 'pseudocode': ["D0.f16 = cos(S0.f16 * 16'F(PI * 2.0))"]},
  'V_COS_F32': {'opcode': 438, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f32 = cos(S0.f32 * 32'F(PI * 2.0))"]},
  'V_CTZ_I32_B32': {'opcode': 442, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = -1;', '// Set if no ones are found', 'for i in 0 : 31 do', '// Search from LSB', "if S0.u32[i] == 1'1U then", 'D0.i32 = i;', 'endif']},
  'V_CUBEID_F32': {'opcode': 524, 'section': 'VOP2_VOP3', 'pseudocode': ['// Set D0.f = cubemap face ID ({0.0, 1.0, ..., 5.0}).', '// XYZ coordinate is given in (S0.f, S1.f, S2.f).', '// S0.f = x', '// S1.f = y', '// S2.f = z', 'if ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then', 'if S2.f32 < 0.0F then', 'D0.f32 = 5.0F', 'else', 'D0.f32 = 4.0F', 'endif', 'elsif abs(S1.f32) >= abs(S0.f32) then', 'if S1.f32 < 0.0F then', 'D0.f32 = 3.0F', 'else', 'D0.f32 = 2.0F', 'endif', 'else', 'if S0.f32 < 0.0F then', 'D0.f32 = 1.0F', 'else', 'D0.f32 = 0.0F', 'endif', 'endif']},
  'V_CUBEMA_F32': {'opcode': 527, 'section': 'VOP2_VOP3', 'pseudocode': ['// D0.f = 2.0 * cubemap major axis.', '// XYZ coordinate is given in (S0.f, S1.f, S2.f).', '// S0.f = x', '// S1.f = y', '// S2.f = z', 'if ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then', 'D0.f32 = S2.f32 * 2.0F', 'elsif abs(S1.f32) >= abs(S0.f32) then', 'D0.f32 = S1.f32 * 2.0F', 'else', 'D0.f32 = S0.f32 * 2.0F', 'endif']},
  'V_CUBESC_F32': {'opcode': 525, 'section': 'VOP2_VOP3', 'pseudocode': ['// D0.f = cubemap S coordinate.', '// XYZ coordinate is given in (S0.f, S1.f, S2.f).', '// S0.f = x', '// S1.f = y', '// S2.f = z', 'if ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then', 'if S2.f32 < 0.0F then', 'D0.f32 = -S0.f32', 'else', 'D0.f32 = S0.f32', 'endif', 'elsif abs(S1.f32) >= abs(S0.f32) then', 'D0.f32 = S0.f32', 'else', 'if S0.f32 < 0.0F then', 'D0.f32 = S2.f32']},
  'V_CUBETC_F32': {'opcode': 526, 'section': 'VOP2_VOP3', 'pseudocode': ['// D0.f = cubemap T coordinate.', '// XYZ coordinate is given in (S0.f, S1.f, S2.f).', '// S0.f = x', '// S1.f = y', '// S2.f = z', 'if ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then', 'D0.f32 = -S1.f32', 'elsif abs(S1.f32) >= abs(S0.f32) then', 'if S1.f32 < 0.0F then', 'D0.f32 = -S2.f32', 'else', 'D0.f32 = S2.f32', 'endif', 'else', 'D0.f32 = -S1.f32', 'endif']},
  'V_CVT_F16_F32': {'opcode': 394, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = f32_to_f16(S0.f32)']},
  'V_CVT_F16_I16': {'opcode': 465, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = i16_to_f16(S0.i16)']},
  'V_CVT_F16_U16': {'opcode': 464, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = u16_to_f16(S0.u16)']},
  'V_CVT_F32_F16': {'opcode': 395, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = f16_to_f32(S0.f16)']},
  'V_CVT_F32_F64': {'opcode': 399, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = f64_to_f32(S0.f64)']},
  'V_CVT_F32_I32': {'opcode': 389, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = i32_to_f32(S0.i32)']},
  'V_CVT_F32_U32': {'opcode': 390, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = u32_to_f32(S0.u32)']},
  'V_CVT_F32_UBYTE0': {'opcode': 401, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = u32_to_f32(S0[7 : 0].u32)']},
  'V_CVT_F32_UBYTE1': {'opcode': 18, 'section': 'VOP1', 'pseudocode': ['D0.f32 = u32_to_f32(S0[15 : 8].u32)']},
  'V_CVT_F32_UBYTE2': {'opcode': 403, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = u32_to_f32(S0[23 : 16].u32)']},
  'V_CVT_F32_UBYTE3': {'opcode': 404, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = u32_to_f32(S0[31 : 24].u32)']},
  'V_CVT_F64_F32': {'opcode': 400, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = f32_to_f64(S0.f32)']},
  'V_CVT_F64_I32': {'opcode': 4, 'section': 'VOP1', 'pseudocode': ['D0.f64 = i32_to_f64(S0.i32)']},
  'V_CVT_F64_U32': {'opcode': 406, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = u32_to_f64(S0.u32)']},
  'V_CVT_FLOOR_I32_F32': {'opcode': 397, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = f32_to_i32(floor(S0.f32))']},
  'V_CVT_I16_F16': {'opcode': 83, 'section': 'VOP1', 'pseudocode': ['D0.i16 = f16_to_i16(S0.f16)']},
  'V_CVT_I32_F32': {'opcode': 392, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = f32_to_i32(S0.f32)']},
  'V_CVT_I32_F64': {'opcode': 387, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = f64_to_i32(S0.f64)']},
  'V_CVT_I32_I16': {'opcode': 490, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.i32 = 32'I(signext(S0.i16))"]},
  'V_CVT_NEAREST_I32_F32': {'opcode': 396, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = f32_to_i32(floor(S0.f32 + 0.5F))']},
  'V_CVT_NORM_I16_F16': {'opcode': 483, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i16 = f16_to_snorm(S0.f16)']},
  'V_CVT_NORM_U16_F16': {'opcode': 484, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = f16_to_unorm(S0.f16)']},
  'V_CVT_OFF_F32_I4': {'opcode': 14, 'section': 'VOP1', 'pseudocode': ["declare CVT_OFF_TABLE : 32'F[16];", 'D0.f32 = CVT_OFF_TABLE[S0.u32[3 : 0]]']},
  'V_CVT_PK_I16_F32': {'opcode': 774, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B;", "tmp[31 : 16] = 16'B(v_cvt_i16_f32(S1.f32));", "tmp[15 : 0] = 16'B(v_cvt_i16_f32(S0.f32));"]},
  'V_CVT_PK_I16_I32': {'opcode': 804, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B;", 'tmp[15 : 0].i16 = i32_to_i16(S0.i32);', 'tmp[31 : 16].i16 = i32_to_i16(S1.i32);']},
  'V_CVT_PK_NORM_I16_F16': {'opcode': 786, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B;", 'tmp[15 : 0].i16 = f16_to_snorm(S0.f16);', 'tmp[31 : 16].i16 = f16_to_snorm(S1.f16);']},
  'V_CVT_PK_NORM_I16_F32': {'opcode': 801, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B;", 'tmp[15 : 0].i16 = f32_to_snorm(S0.f32);', 'tmp[31 : 16].i16 = f32_to_snorm(S1.f32);']},
  'V_CVT_PK_NORM_U16_F32': {'opcode': 802, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B;", 'tmp[15 : 0].u16 = f32_to_unorm(S0.f32);', 'tmp[31 : 16].u16 = f32_to_unorm(S1.f32);']},
  'V_CVT_PK_RTZ_F16_F32': {'opcode': 303, 'section': 'VOP2_VOP3', 'pseudocode': ['prev_mode = ROUND_MODE;', 'tmp[15 : 0].f16 = f32_to_f16(S0.f32);', 'tmp[31 : 16].f16 = f32_to_f16(S1.f32);']},
  'V_CVT_PK_U16_F32': {'opcode': 775, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B;", "tmp[31 : 16] = 16'B(v_cvt_u16_f32(S1.f32));", "tmp[15 : 0] = 16'B(v_cvt_u16_f32(S0.f32));"]},
  'V_CVT_PK_U16_U32': {'opcode': 803, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B;", 'tmp[15 : 0].u16 = u32_to_u16(S0.u32);', 'tmp[31 : 16].u16 = u32_to_u16(S1.u32);']},
  'V_CVT_PK_U8_F32': {'opcode': 550, 'section': 'VOP2_VOP3', 'pseudocode': ["tmp = (S2.u32 & 32'U(~(0xff << (S1.u32[1 : 0].u32 * 8U))));", "tmp = (tmp | ((32'U(f32_to_u8(S0.f32)) & 255U) << (S1.u32[1 : 0].u32 * 8U)));", 'D0.u32 = tmp']},
  'V_CVT_U16_F16': {'opcode': 466, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = f16_to_u16(S0.f16)']},
  'V_CVT_U32_F32': {'opcode': 391, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = f32_to_u32(S0.f32)']},
  'V_CVT_U32_F64': {'opcode': 405, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = f64_to_u32(S0.f64)']},
  'V_CVT_U32_U16': {'opcode': 491, 'section': 'VOP2_VOP3', 'pseudocode': ["D0 = { 16'0, S0.u16 }"]},
  'V_DIV_FIXUP_F16': {'opcode': 596, 'section': 'VOP2_VOP3', 'pseudocode': ['sign_out = (sign(S1.f16) ^ sign(S2.f16));', "if isNAN(64'F(S2.f16)) then", "D0.f16 = 16'F(cvtToQuietNAN(64'F(S2.f16)))", "elsif isNAN(64'F(S1.f16)) then", "D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))", "elsif ((64'F(S1.f16) == 0.0) && (64'F(S2.f16) == 0.0)) then", '// 0/0', "D0.f16 = 16'F(0xfe00)", "elsif ((64'F(abs(S1.f16)) == +INF) && (64'F(abs(S2.f16)) == +INF)) then", '// inf/inf', "D0.f16 = 16'F(0xfe00)", "elsif ((64'F(S1.f16) == 0.0) || (64'F(abs(S2.f16)) == +INF)) then", '// x/0, or inf/y', 'D0.f16 = sign_out ? -INF.f16 : +INF.f16', "elsif ((64'F(abs(S1.f16)) == +INF) || (64'F(S2.f16) == 0.0)) then", '// x/inf, 0/y', "D0.f16 = sign_out ? -16'0.0 : 16'0.0", 'else', 'D0.f16 = sign_out ? -abs(S0.f16) : abs(S0.f16)', 'endif']},
  'V_DIV_FIXUP_F32': {'opcode': 551, 'section': 'VOP2_VOP3', 'pseudocode': ['sign_out = (sign(S1.f32) ^ sign(S2.f32));', "if isNAN(64'F(S2.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S2.f32)))"]},
  'V_DIV_FIXUP_F64': {'opcode': 552, 'section': 'VOP2_VOP3', 'pseudocode': ['sign_out = (sign(S1.f64) ^ sign(S2.f64));', 'if isNAN(S2.f64) then', 'D0.f64 = cvtToQuietNAN(S2.f64)', 'elsif isNAN(S1.f64) then', 'D0.f64 = cvtToQuietNAN(S1.f64)', 'elsif ((S1.f64 == 0.0) && (S2.f64 == 0.0)) then', '// 0/0', "D0.f64 = 64'F(0xfff8000000000000LL)", 'elsif ((abs(S1.f64) == +INF) && (abs(S2.f64) == +INF)) then', '// inf/inf', "D0.f64 = 64'F(0xfff8000000000000LL)", 'elsif ((S1.f64 == 0.0) || (abs(S2.f64) == +INF)) then', '// x/0, or inf/y', 'D0.f64 = sign_out ? -INF : +INF', 'elsif ((abs(S1.f64) == +INF) || (S2.f64 == 0.0)) then', '// x/inf, 0/y']},
  'V_DIV_FMAS_F32': {'opcode': 567, 'section': 'VOP2_VOP3', 'pseudocode': ['if VCC.u64[laneId] then', 'D0.f32 = 2.0F ** 32 * fma(S0.f32, S1.f32, S2.f32)', 'else', 'D0.f32 = fma(S0.f32, S1.f32, S2.f32)', 'endif']},
  'V_DIV_FMAS_F64': {'opcode': 568, 'section': 'VOP2_VOP3', 'pseudocode': ['if VCC.u64[laneId] then', 'D0.f64 = 2.0 ** 64 * fma(S0.f64, S1.f64, S2.f64)']},
  'V_DIV_SCALE_F32': {'opcode': 764, 'section': 'VOP2_VOP3', 'pseudocode': ['VCC = 0x0LL;', "if ((64'F(S2.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then", 'D0.f32 = NAN.f32', 'elsif exponent(S2.f32) - exponent(S1.f32) >= 96 then', '// N/D near MAX_FLOAT_F32', 'VCC = 0x1LL;', 'if S0.f32 == S1.f32 then', '// Only scale the denominator', 'D0.f32 = ldexp(S0.f32, 64)', 'endif', 'elsif S1.f32 == DENORM.f32 then', 'D0.f32 = ldexp(S0.f32, 64)', "elsif ((1.0 / 64'F(S1.f32) == DENORM.f64) && (S2.f32 / S1.f32 == DENORM.f32)) then", 'VCC = 0x1LL;', 'if S0.f32 == S1.f32 then', '// Only scale the denominator', 'D0.f32 = ldexp(S0.f32, 64)', 'endif', "elsif 1.0 / 64'F(S1.f32) == DENORM.f64 then", 'D0.f32 = ldexp(S0.f32, -64)', 'elsif S2.f32 / S1.f32 == DENORM.f32 then', 'VCC = 0x1LL;', 'if S0.f32 == S2.f32 then']},
  'V_DIV_SCALE_F64': {'opcode': 765, 'section': 'VOP2_VOP3', 'pseudocode': ['VCC = 0x0LL;', 'if ((S2.f64 == 0.0) || (S1.f64 == 0.0)) then', 'D0.f64 = NAN.f64', 'elsif exponent(S2.f64) - exponent(S1.f64) >= 768 then', '// N/D near MAX_FLOAT_F64', 'VCC = 0x1LL;', 'if S0.f64 == S1.f64 then', '// Only scale the denominator', 'D0.f64 = ldexp(S0.f64, 128)', 'endif', 'elsif S1.f64 == DENORM.f64 then', 'D0.f64 = ldexp(S0.f64, 128)', 'elsif ((1.0 / S1.f64 == DENORM.f64) && (S2.f64 / S1.f64 == DENORM.f64)) then', 'VCC = 0x1LL;', 'if S0.f64 == S1.f64 then', '// Only scale the denominator', 'D0.f64 = ldexp(S0.f64, 128)', 'endif', 'elsif 1.0 / S1.f64 == DENORM.f64 then', 'D0.f64 = ldexp(S0.f64, -128)', 'elsif S2.f64 / S1.f64 == DENORM.f64 then', 'VCC = 0x1LL;', 'if S0.f64 == S2.f64 then', '// Only scale the numerator']},
  'V_DOT2ACC_F32_F16': {'opcode': 2, 'section': 'SMEM', 'pseudocode': ['tmp = D0.f32;', 'D0.f32 = tmp']},
  'V_DOT2_BF16_BF16': {'opcode': 615, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S2.bf16;', 'D0.bf16 = tmp']},
  'V_DOT2_F16_F16': {'opcode': 614, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S2.f16;', 'D0.f16 = tmp']},
  'V_DOT2_F32_BF16': {'opcode': 26, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S2.f32;', 'D0.f32 = tmp']},
  'V_DOT2_F32_F16': {'opcode': 19, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S2.f32;', 'D0.f32 = tmp']},
  'V_DOT4_I32_IU8': {'opcode': 22, 'section': 'VOP2_VOP3', 'pseudocode': ["declare A : 32'I[4];"]},
  'V_DOT4_U32_U8': {'opcode': 23, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S2.u32;', 'D0.u32 = tmp']},
  'V_DOT8_I32_IU4': {'opcode': 24, 'section': 'VOP2_VOP3', 'pseudocode': ["declare A : 32'I[8];", "declare B : 32'I[8];"]},
  'V_DOT8_U32_U4': {'opcode': 25, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S2.u32;', 'D0.u32 = tmp']},
  'V_DUAL_DOT2ACC_F32_BF16': {'opcode': 13, 'section': 'VOP2_VOP3', 'pseudocode': ['Dot product of packed brain-float values, accumulate with destination. The initial value in D is used as S2.']},
  'V_EXP_F16': {'opcode': 472, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f16 = pow(16'2.0, S0.f16)"]},
  'V_EXP_F32': {'opcode': 421, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = pow(2.0F, S0.f32)']},
  'V_FLOOR_F16': {'opcode': 475, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = trunc(S0.f16);', "if ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then", "D0.f16 += -16'1.0", 'endif']},
  'V_FLOOR_F32': {'opcode': 420, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = trunc(S0.f32);', 'if ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then', 'D0.f32 += -1.0F', 'endif']},
  'V_FLOOR_F64': {'opcode': 410, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = trunc(S0.f64);', 'if ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then', 'D0.f64 += -1.0', 'endif']},
  'V_FMAAK_F16': {'opcode': 56, 'section': 'SMEM', 'pseudocode': ['D0.f16 = fma(S0.f16, S1.f16, SIMM32.f16)']},
  'V_FMAAK_F32': {'opcode': 45, 'section': 'SMEM', 'pseudocode': ['D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)']},
  'V_FMAC_DX9_ZERO_F32': {'opcode': 262, 'section': 'VOP2_VOP3', 'pseudocode': ["if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then", '// DX9 rules, 0.0 * x = 0.0', 'D0.f32 = S2.f32', 'else', 'D0.f32 = fma(S0.f32, S1.f32, D0.f32)', 'endif']},
  'V_FMAC_F16': {'opcode': 54, 'section': 'SMEM', 'pseudocode': ['D0.f16 = fma(S0.f16, S1.f16, D0.f16)']},
  'V_FMAC_F32': {'opcode': 299, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = fma(S0.f32, S1.f32, D0.f32)']},
  'V_FMAMK_F16': {'opcode': 55, 'section': 'SMEM', 'pseudocode': ['D0.f16 = fma(S0.f16, SIMM32.f16, S1.f16)']},
  'V_FMA_DX9_ZERO_F32': {'opcode': 521, 'section': 'VOP2_VOP3', 'pseudocode': ["if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then", '// DX9 rules, 0.0 * x = 0.0', 'D0.f32 = S2.f32', 'else', 'D0.f32 = fma(S0.f32, S1.f32, S2.f32)', 'endif']},
  'V_FMA_F16': {'opcode': 584, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = fma(S0.f16, S1.f16, S2.f16)']},
  'V_FMA_F32': {'opcode': 531, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = fma(S0.f32, S1.f32, S2.f32)']},
  'V_FMA_F64': {'opcode': 532, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = fma(S0.f64, S1.f64, S2.f64)']},
  'V_FMA_MIXLO_F16': {'opcode': 33, 'section': 'VOP2_VOP3', 'pseudocode': ["declare in : 32'F[3];", "declare S : 32'B[3];", 'for i in 0 : 2 do', 'if !OPSEL_HI.u3[i] then', 'in[i] = S[i].f32', 'elsif OPSEL.u3[i] then', 'in[i] = f16_to_f32(S[i][31 : 16].f16)', 'else', 'in[i] = f16_to_f32(S[i][15 : 0].f16)', 'endif']},
  'V_FRACT_F16': {'opcode': 479, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = S0.f16 + -floor(S0.f16)']},
  'V_FRACT_F32': {'opcode': 416, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = S0.f32 + -floor(S0.f32)']},
  'V_FRACT_F64': {'opcode': 446, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = S0.f64 + -floor(S0.f64)']},
  'V_FREXP_EXP_I16_F16': {'opcode': 474, 'section': 'VOP2_VOP3', 'pseudocode': ["if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then", "D0.i16 = 16'0", 'else', "D0.i16 = 16'I(exponent(S0.f16) - 15 + 1)", 'endif']},
  'V_FREXP_EXP_I32_F32': {'opcode': 447, 'section': 'VOP2_VOP3', 'pseudocode': ["if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then", 'D0.i32 = 0', 'else', 'D0.i32 = exponent(S0.f32) - 127 + 1', 'endif']},
  'V_FREXP_EXP_I32_F64': {'opcode': 444, 'section': 'VOP2_VOP3', 'pseudocode': ['if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then', 'D0.i32 = 0', 'else', 'D0.i32 = exponent(S0.f64) - 1023 + 1', 'endif']},
  'V_FREXP_MANT_F16': {'opcode': 473, 'section': 'VOP2_VOP3', 'pseudocode': ["if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then", 'D0.f16 = S0.f16', 'else', 'D0.f16 = mantissa(S0.f16)', 'endif']},
  'V_FREXP_MANT_F32': {'opcode': 64, 'section': 'VOP1', 'pseudocode': ["if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then", 'D0.f32 = S0.f32', 'else', 'D0.f32 = mantissa(S0.f32)', 'endif']},
  'V_FREXP_MANT_F64': {'opcode': 445, 'section': 'VOP2_VOP3', 'pseudocode': ['if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then', 'D0.f64 = S0.f64', 'else', 'D0.f64 = mantissa(S0.f64)']},
  'V_INTERP_P10_F16_F32': {'opcode': 2, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f32 = fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 1U][SRC0.u32].f16), S1.f32, 32'F(VGPR[laneId.u32 &"]},
  'V_INTERP_P10_F32': {'opcode': 0, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = fma(VGPR[(laneId.u32 & 0xfffffffcU) + 1U][SRC0.u32].f32, S1.f32, VGPR[laneId.u32 &']},
  'V_INTERP_P2_F16_F32': {'opcode': 3, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f16 = 16'F(fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 2U][SRC0.u32].f16), S1.f32, S2.f32))"]},
  'V_INTERP_P2_RTZ_F16_F32': {'opcode': 5, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f32 = fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 2U][SRC0.u32].f16), S1.f32, S2.f32)"]},
  'V_LDEXP_F16': {'opcode': 59, 'section': 'SMEM', 'pseudocode': ["D0.f16 = S0.f16 * 16'F(2.0F ** 32'I(S1.i16))"]},
  'V_LDEXP_F32': {'opcode': 796, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = S0.f32 * 2.0F ** S1.i32']},
  'V_LERP_U8': {'opcode': 533, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = ((S0.u32[31 : 24] + S1.u32[31 : 24] + S2.u32[24].u8) >> 1U << 24U);', 'tmp += ((S0.u32[23 : 16] + S1.u32[23 : 16] + S2.u32[16].u8) >> 1U << 16U);', 'tmp += ((S0.u32[15 : 8] + S1.u32[15 : 8] + S2.u32[8].u8) >> 1U << 8U);', 'tmp += ((S0.u32[7 : 0] + S1.u32[7 : 0] + S2.u32[0].u8) >> 1U);', 'D0.u32 = tmp.u32']},
  'V_LOG_F16': {'opcode': 471, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = log2(S0.f16)']},
  'V_LOG_F32': {'opcode': 423, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = log2(S0.f32)']},
  'V_LSHLREV_B16': {'opcode': 824, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = (S1.u16 << S0[3 : 0].u32)']},
  'V_LSHLREV_B32': {'opcode': 280, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (S1.u32 << S0[4 : 0].u32)']},
  'V_LSHLREV_B64': {'opcode': 828, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64 = (S1.u64 << S0[5 : 0].u32)']},
  'V_LSHL_ADD_U32': {'opcode': 582, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (S0.u32 << S1.u32[4 : 0].u32) + S2.u32']},
  'V_LSHL_OR_B32': {'opcode': 598, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = ((S0.u32 << S1.u32[4 : 0].u32) | S2.u32)']},
  'V_LSHRREV_B32': {'opcode': 281, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (S1.u32 >> S0[4 : 0].u32)']},
  'V_LSHRREV_B64': {'opcode': 829, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u64 = (S1.u64 >> S0[5 : 0].u32)']},
  'V_MAD_I32_I16': {'opcode': 602, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.i32 = 32'I(S0.i16) * 32'I(S1.i16) + S2.i32"]},
  'V_MAD_I32_I24': {'opcode': 522, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.i32 = 32'I(S0.i24) * 32'I(S1.i24) + S2.i32"]},
  'V_MAD_I64_I32': {'opcode': 767, 'section': 'VOP2_VOP3', 'pseudocode': ["{ D1.i1, D0.i64 } = 65'B(65'I(S0.i32) * 65'I(S1.i32) + 65'I(S2.i64))"]},
  'V_MAD_U32_U16': {'opcode': 601, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.u32 = 32'U(S0.u16) * 32'U(S1.u16) + S2.u32"]},
  'V_MAD_U32_U24': {'opcode': 523, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.u32 = 32'U(S0.u24) * 32'U(S1.u24) + S2.u32"]},
  'V_MAD_U64_U32': {'opcode': 766, 'section': 'VOP2_VOP3', 'pseudocode': ["{ D1.u1, D0.u64 } = 65'B(65'U(S0.u32) * 65'U(S1.u32) + 65'U(S2.u64))"]},
  'V_MAX3_F16': {'opcode': 588, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = v_max_f16(v_max_f16(S0.f16, S1.f16), S2.f16)']},
  'V_MAX3_F32': {'opcode': 540, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = v_max_f32(v_max_f32(S0.f32, S1.f32), S2.f32)']},
  'V_MAX3_I16': {'opcode': 589, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i16 = v_max_i16(v_max_i16(S0.i16, S1.i16), S2.i16)']},
  'V_MAX3_I32': {'opcode': 541, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = v_max_i32(v_max_i32(S0.i32, S1.i32), S2.i32)']},
  'V_MAX3_U32': {'opcode': 542, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = v_max_u32(v_max_u32(S0.u32, S1.u32), S2.u32)']},
  'V_MAXMIN_F16': {'opcode': 608, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = v_min_f16(v_max_f16(S0.f16, S1.f16), S2.f16)']},
  'V_MAXMIN_F32': {'opcode': 606, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = v_min_f32(v_max_f32(S0.f32, S1.f32), S2.f32)']},
  'V_MAXMIN_I32': {'opcode': 612, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = v_min_i32(v_max_i32(S0.i32, S1.i32), S2.i32)']},
  'V_MAX_F16': {'opcode': 313, 'section': 'VOP2_VOP3', 'pseudocode': ['// Version of comparison where +0.0 > -0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', "if isSignalNAN(64'F(S0.f16)) then", "D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))", "elsif isSignalNAN(64'F(S1.f16)) then", "D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))", "elsif isQuietNAN(64'F(S1.f16)) then", 'D0.f16 = S0.f16', "elsif isQuietNAN(64'F(S0.f16)) then", 'D0.f16 = S1.f16', 'elsif GT_NEG_ZERO(S0.f16, S1.f16) then', '// NOTE: +0>-0 is TRUE in this comparison', 'D0.f16 = S0.f16', 'else', 'D0.f16 = S1.f16', 'endif', 'else', "if isNAN(64'F(S1.f16)) then", 'D0.f16 = S0.f16', "elsif isNAN(64'F(S0.f16)) then", 'D0.f16 = S1.f16', 'elsif GT_NEG_ZERO(S0.f16, S1.f16) then', '// NOTE: +0>-0 is TRUE in this comparison', 'D0.f16 = S0.f16', 'else', 'D0.f16 = S1.f16', 'endif', 'endif;', '// Inequalities in the above pseudocode behave differently from IEEE']},
  'V_MAX_F32': {'opcode': 272, 'section': 'VOP2_VOP3', 'pseudocode': ['// Version of comparison where +0.0 > -0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', "if isSignalNAN(64'F(S0.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))", "elsif isSignalNAN(64'F(S1.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))", "elsif isQuietNAN(64'F(S1.f32)) then", 'D0.f32 = S0.f32', "elsif isQuietNAN(64'F(S0.f32)) then", 'D0.f32 = S1.f32', 'elsif GT_NEG_ZERO(S0.f32, S1.f32) then', '// NOTE: +0>-0 is TRUE in this comparison', 'D0.f32 = S0.f32', 'else', 'D0.f32 = S1.f32', 'endif', 'else', "if isNAN(64'F(S1.f32)) then", 'D0.f32 = S0.f32', "elsif isNAN(64'F(S0.f32)) then", 'D0.f32 = S1.f32', 'elsif GT_NEG_ZERO(S0.f32, S1.f32) then', '// NOTE: +0>-0 is TRUE in this comparison', 'D0.f32 = S0.f32', 'else', 'D0.f32 = S1.f32', 'endif', 'endif;', '// Inequalities in the above pseudocode behave differently from IEEE']},
  'V_MAX_F64': {'opcode': 810, 'section': 'VOP2_VOP3', 'pseudocode': ['// Version of comparison where +0.0 > -0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', 'if isSignalNAN(S0.f64) then', 'D0.f64 = cvtToQuietNAN(S0.f64)', 'elsif isSignalNAN(S1.f64) then', 'D0.f64 = cvtToQuietNAN(S1.f64)', 'elsif isQuietNAN(S1.f64) then', 'D0.f64 = S0.f64', 'elsif isQuietNAN(S0.f64) then', 'D0.f64 = S1.f64', 'elsif GT_NEG_ZERO(S0.f64, S1.f64) then', '// NOTE: +0>-0 is TRUE in this comparison', 'D0.f64 = S0.f64', 'else', 'D0.f64 = S1.f64', 'endif', 'else', 'if isNAN(S1.f64) then', 'D0.f64 = S0.f64', 'elsif isNAN(S0.f64) then', 'D0.f64 = S1.f64', 'elsif GT_NEG_ZERO(S0.f64, S1.f64) then', '// NOTE: +0>-0 is TRUE in this comparison', 'D0.f64 = S0.f64', 'else', 'D0.f64 = S1.f64', 'endif', 'endif;', '// Inequalities in the above pseudocode behave differently from IEEE']},
  'V_MAX_I16': {'opcode': 778, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i16 = S0.i16 >= S1.i16 ? S0.i16 : S1.i16']},
  'V_MAX_I32': {'opcode': 274, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = S0.i32 >= S1.i32 ? S0.i32 : S1.i32']},
  'V_MAX_U16': {'opcode': 777, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = S0.u16 >= S1.u16 ? S0.u16 : S1.u16']},
  'V_MAX_U32': {'opcode': 276, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = S0.u32 >= S1.u32 ? S0.u32 : S1.u32']},
  'V_MBCNT_HI_U32_B32': {'opcode': 800, 'section': 'VOP2_VOP3', 'pseudocode': ['MaskedValue = (S0.u32 & ThreadMask[63 : 32].u32);', 'tmp = S1.u32;', 'for i in 0 : 31 do', 'D0.u32 = tmp']},
  'V_MED3_F16': {'opcode': 591, 'section': 'VOP2_VOP3', 'pseudocode': ["if (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)) || isNAN(64'F(S2.f16))) then", 'D0.f16 = v_min3_f16(S0.f16, S1.f16, S2.f16)', 'elsif v_max3_f16(S0.f16, S1.f16, S2.f16) == S0.f16 then', 'D0.f16 = v_max_f16(S1.f16, S2.f16)', 'elsif v_max3_f16(S0.f16, S1.f16, S2.f16) == S1.f16 then', 'D0.f16 = v_max_f16(S0.f16, S2.f16)', 'else', 'D0.f16 = v_max_f16(S0.f16, S1.f16)', 'endif']},
  'V_MED3_F32': {'opcode': 543, 'section': 'VOP2_VOP3', 'pseudocode': ["if (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)) || isNAN(64'F(S2.f32))) then", 'D0.f32 = v_min3_f32(S0.f32, S1.f32, S2.f32)', 'elsif v_max3_f32(S0.f32, S1.f32, S2.f32) == S0.f32 then', 'D0.f32 = v_max_f32(S1.f32, S2.f32)', 'elsif v_max3_f32(S0.f32, S1.f32, S2.f32) == S1.f32 then', 'D0.f32 = v_max_f32(S0.f32, S2.f32)', 'else', 'D0.f32 = v_max_f32(S0.f32, S1.f32)', 'endif']},
  'V_MED3_I16': {'opcode': 592, 'section': 'VOP2_VOP3', 'pseudocode': ['if v_max3_i16(S0.i16, S1.i16, S2.i16) == S0.i16 then', 'D0.i16 = v_max_i16(S1.i16, S2.i16)', 'elsif v_max3_i16(S0.i16, S1.i16, S2.i16) == S1.i16 then', 'D0.i16 = v_max_i16(S0.i16, S2.i16)', 'else', 'D0.i16 = v_max_i16(S0.i16, S1.i16)', 'endif']},
  'V_MED3_I32': {'opcode': 544, 'section': 'VOP2_VOP3', 'pseudocode': ['if v_max3_i32(S0.i32, S1.i32, S2.i32) == S0.i32 then', 'D0.i32 = v_max_i32(S1.i32, S2.i32)', 'elsif v_max3_i32(S0.i32, S1.i32, S2.i32) == S1.i32 then', 'D0.i32 = v_max_i32(S0.i32, S2.i32)', 'else', 'D0.i32 = v_max_i32(S0.i32, S1.i32)', 'endif']},
  'V_MED3_U16': {'opcode': 593, 'section': 'VOP2_VOP3', 'pseudocode': ['if v_max3_u16(S0.u16, S1.u16, S2.u16) == S0.u16 then', 'D0.u16 = v_max_u16(S1.u16, S2.u16)', 'elsif v_max3_u16(S0.u16, S1.u16, S2.u16) == S1.u16 then', 'D0.u16 = v_max_u16(S0.u16, S2.u16)', 'else', 'D0.u16 = v_max_u16(S0.u16, S1.u16)', 'endif']},
  'V_MIN3_F16': {'opcode': 585, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = v_min_f16(v_min_f16(S0.f16, S1.f16), S2.f16)']},
  'V_MIN3_F32': {'opcode': 537, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = v_min_f32(v_min_f32(S0.f32, S1.f32), S2.f32)']},
  'V_MIN3_I16': {'opcode': 586, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i16 = v_min_i16(v_min_i16(S0.i16, S1.i16), S2.i16)']},
  'V_MIN3_I32': {'opcode': 538, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = v_min_i32(v_min_i32(S0.i32, S1.i32), S2.i32)']},
  'V_MIN3_U16': {'opcode': 587, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = v_min_u16(v_min_u16(S0.u16, S1.u16), S2.u16)']},
  'V_MIN3_U32': {'opcode': 539, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = v_min_u32(v_min_u32(S0.u32, S1.u32), S2.u32)']},
  'V_MINMAX_F16': {'opcode': 609, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = v_max_f16(v_min_f16(S0.f16, S1.f16), S2.f16)']},
  'V_MINMAX_F32': {'opcode': 607, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = v_max_f32(v_min_f32(S0.f32, S1.f32), S2.f32)']},
  'V_MINMAX_I32': {'opcode': 613, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = v_max_i32(v_min_i32(S0.i32, S1.i32), S2.i32)']},
  'V_MINMAX_U32': {'opcode': 611, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = v_max_u32(v_min_u32(S0.u32, S1.u32), S2.u32)']},
  'V_MIN_F16': {'opcode': 314, 'section': 'VOP2_VOP3', 'pseudocode': ['// Version of comparison where -0.0 < +0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', "if isSignalNAN(64'F(S0.f16)) then", "D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))", "elsif isSignalNAN(64'F(S1.f16)) then", "D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))", "elsif isQuietNAN(64'F(S1.f16)) then", 'D0.f16 = S0.f16', "elsif isQuietNAN(64'F(S0.f16)) then", 'D0.f16 = S1.f16', 'elsif LT_NEG_ZERO(S0.f16, S1.f16) then', '// NOTE: -0<+0 is TRUE in this comparison', 'D0.f16 = S0.f16', 'else', 'D0.f16 = S1.f16', 'endif', 'else', "if isNAN(64'F(S1.f16)) then", 'D0.f16 = S0.f16', "elsif isNAN(64'F(S0.f16)) then", 'D0.f16 = S1.f16', 'elsif LT_NEG_ZERO(S0.f16, S1.f16) then', '// NOTE: -0<+0 is TRUE in this comparison', 'D0.f16 = S0.f16', 'else', 'D0.f16 = S1.f16', 'endif', 'endif;', '// Inequalities in the above pseudocode behave differently from IEEE']},
  'V_MIN_F32': {'opcode': 271, 'section': 'VOP2_VOP3', 'pseudocode': ['// Version of comparison where -0.0 < +0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', "if isSignalNAN(64'F(S0.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))", "elsif isSignalNAN(64'F(S1.f32)) then", "D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))", "elsif isQuietNAN(64'F(S1.f32)) then", 'D0.f32 = S0.f32', "elsif isQuietNAN(64'F(S0.f32)) then", 'D0.f32 = S1.f32', 'elsif LT_NEG_ZERO(S0.f32, S1.f32) then', '// NOTE: -0<+0 is TRUE in this comparison', 'D0.f32 = S0.f32', 'else', 'D0.f32 = S1.f32', 'endif', 'else', "if isNAN(64'F(S1.f32)) then", 'D0.f32 = S0.f32', "elsif isNAN(64'F(S0.f32)) then", 'D0.f32 = S1.f32', 'elsif LT_NEG_ZERO(S0.f32, S1.f32) then', '// NOTE: -0<+0 is TRUE in this comparison', 'D0.f32 = S0.f32', 'else', 'D0.f32 = S1.f32', 'endif', 'endif;', '// Inequalities in the above pseudocode behave differently from IEEE']},
  'V_MIN_F64': {'opcode': 809, 'section': 'VOP2_VOP3', 'pseudocode': ['// Version of comparison where -0.0 < +0.0, differs from IEEE', 'if WAVE_MODE.IEEE then', 'if isSignalNAN(S0.f64) then', 'D0.f64 = cvtToQuietNAN(S0.f64)', 'elsif isSignalNAN(S1.f64) then', 'D0.f64 = cvtToQuietNAN(S1.f64)', 'elsif isQuietNAN(S1.f64) then', 'D0.f64 = S0.f64', 'elsif isQuietNAN(S0.f64) then', 'D0.f64 = S1.f64', 'elsif LT_NEG_ZERO(S0.f64, S1.f64) then', '// NOTE: -0<+0 is TRUE in this comparison', 'D0.f64 = S0.f64', 'else', 'D0.f64 = S1.f64', 'endif', 'else', 'if isNAN(S1.f64) then', 'D0.f64 = S0.f64', 'elsif isNAN(S0.f64) then', 'D0.f64 = S1.f64', 'elsif LT_NEG_ZERO(S0.f64, S1.f64) then', '// NOTE: -0<+0 is TRUE in this comparison', 'D0.f64 = S0.f64', 'else', 'D0.f64 = S1.f64', 'endif', 'endif;', '// Inequalities in the above pseudocode behave differently from IEEE']},
  'V_MIN_I16': {'opcode': 780, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i16 = S0.i16 < S1.i16 ? S0.i16 : S1.i16']},
  'V_MIN_I32': {'opcode': 273, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = S0.i32 < S1.i32 ? S0.i32 : S1.i32']},
  'V_MIN_U16': {'opcode': 779, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = S0.u16 < S1.u16 ? S0.u16 : S1.u16']},
  'V_MIN_U32': {'opcode': 275, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = S0.u32 < S1.u32 ? S0.u32 : S1.u32']},
  'V_MOVRELD_B32': {'opcode': 450, 'section': 'VOP2_VOP3', 'pseudocode': ['addr = DST.u32;', '// Raw value from instruction', 'VGPR[laneId][addr].b32 = S0.b32']},
  'V_MOVRELSD_2_B32': {'opcode': 456, 'section': 'VOP2_VOP3', 'pseudocode': ['addrs = SRC0.u32;', '// Raw value from instruction', 'addrd = DST.u32;', '// Raw value from instruction']},
  'V_MOVRELSD_B32': {'opcode': 452, 'section': 'VOP2_VOP3', 'pseudocode': ['addrs = SRC0.u32;', '// Raw value from instruction', 'addrd = DST.u32;', '// Raw value from instruction']},
  'V_MOVRELS_B32': {'opcode': 451, 'section': 'VOP2_VOP3', 'pseudocode': ['addr = SRC0.u32;', '// Raw value from instruction', 'D0.b32 = VGPR[laneId][addr].b32']},
  'V_MOV_B16': {'opcode': 412, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b16 = S0.b16']},
  'V_MOV_B32': {'opcode': 385, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = S0.b32']},
  'V_MQSAD_PK_U16_U8': {'opcode': 571, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b64 = tmp.b64']},
  'V_MQSAD_U32_U8': {'opcode': 573, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b128 = tmp.b128']},
  'V_MSAD_U8': {'opcode': 569, 'section': 'VOP2_VOP3', 'pseudocode': ['// UNSIGNED comparison', 'tmp = S2.u32;', "tmp += S1.u32[7 : 0] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]));", "tmp += S1.u32[15 : 8] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]));", "tmp += S1.u32[23 : 16] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]));", "tmp += S1.u32[31 : 24] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]));", 'D0.u32 = tmp']},
  'V_MUL_DX9_ZERO_F32': {'opcode': 263, 'section': 'VOP2_VOP3', 'pseudocode': ["if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then", '// DX9 rules, 0.0 * x = 0.0', 'D0.f32 = 0.0F', 'else', 'D0.f32 = S0.f32 * S1.f32', 'endif']},
  'V_MUL_F16': {'opcode': 309, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = S0.f16 * S1.f16']},
  'V_MUL_F32': {'opcode': 264, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = S0.f32 * S1.f32']},
  'V_MUL_F64': {'opcode': 808, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = S0.f64 * S1.f64']},
  'V_MUL_HI_I32': {'opcode': 814, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.i32 = 32'I((64'I(S0.i32) * 64'I(S1.i32)) >> 32U)"]},
  'V_MUL_HI_I32_I24': {'opcode': 266, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.i32 = 32'I((64'I(S0.i24) * 64'I(S1.i24)) >> 32U)"]},
  'V_MUL_HI_U32': {'opcode': 813, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.u32 = 32'U((64'U(S0.u32) * 64'U(S1.u32)) >> 32U)"]},
  'V_MUL_HI_U32_U24': {'opcode': 268, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.u32 = 32'U((64'U(S0.u24) * 64'U(S1.u24)) >> 32U)"]},
  'V_MUL_I32_I24': {'opcode': 265, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.i32 = 32'I(S0.i24) * 32'I(S1.i24)"]},
  'V_MUL_LO_U16': {'opcode': 773, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = S0.u16 * S1.u16']},
  'V_MUL_LO_U32': {'opcode': 812, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = S0.u32 * S1.u32']},
  'V_MUL_U32_U24': {'opcode': 267, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.u32 = 32'U(S0.u24) * 32'U(S1.u24)"]},
  'V_NOT_B16': {'opcode': 489, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = ~S0.u16']},
  'V_NOT_B32': {'opcode': 439, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = ~S0.u32']},
  'V_OR3_B32': {'opcode': 600, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (S0.u32 | S1.u32 | S2.u32)']},
  'V_OR_B16': {'opcode': 867, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = (S0.u16 | S1.u16)']},
  'V_OR_B32': {'opcode': 284, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (S0.u32 | S1.u32)']},
  'V_PACK_B32_F16': {'opcode': 785, 'section': 'VOP2_VOP3', 'pseudocode': ['D0[31 : 16].f16 = S1.f16;', 'D0[15 : 0].f16 = S0.f16']},
  'V_PERMLANE16_B32': {'opcode': 603, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B[64];", 'lanesel = { S2.u32, S1.u32 };', '// Concatenate lane select bits', 'for i in 0 : WAVE32 ? 31 : 63 do', '// Copy original S0 in case D==S0', 'for row in 0 : WAVE32 ? 1 : 3 do', '// Implement arbitrary swizzle within each row', 'for i in 0 : 15 do', 'if EXEC[row * 16 + i].u1 then', "VGPR[row * 16 + i][VDST.u32] = tmp[64'B(row * 16) + lanesel[i * 4 + 3 : i * 4]]", 'endif']},
  'V_PERMLANE64_B32': {'opcode': 103, 'section': 'VOP1', 'pseudocode': ["declare tmp : 32'B[64];", "declare lane : 32'U;", 'if WAVE32 then', '// Supported in wave64 ONLY; treated as scalar NOP in wave32', 'else', 'for lane in 0U : 63U do', '// Copy original S0 in case D==S0', 'tmp[lane] = VGPR[lane][SRC0.u32]', 'for lane in 0U : 63U do', 'altlane = { ~lane[5], lane[4 : 0] };', '// 0<->32, ..., 31<->63', 'if EXEC[lane].u1 then', 'VGPR[lane][VDST.u32] = tmp[altlane]', 'endif']},
  'V_PERMLANEX16_B32': {'opcode': 604, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B[64];", 'lanesel = { S2.u32, S1.u32 };', '// Concatenate lane select bits', 'for i in 0 : WAVE32 ? 31 : 63 do', '// Copy original S0 in case D==S0', 'for row in 0 : WAVE32 ? 1 : 3 do', '// Implement arbitrary swizzle across two rows', 'altrow = { row[1], ~row[0] };', '// 1<->0, 3<->2', 'for i in 0 : 15 do', 'if EXEC[row * 16 + i].u1 then', "VGPR[row * 16 + i][VDST.u32] = tmp[64'B(altrow.i32 * 16) + lanesel[i * 4 + 3 : i * 4]]", 'endif']},
  'V_PERM_B32': {'opcode': 580, 'section': 'VOP2_VOP3', 'pseudocode': ["declare in : 8'B[8];", 'for i in 0 : 7 do', 'if sel.u32 >= 13U then', 'elsif sel.u32 == 12U then', 'elsif sel.u32 == 11U then', 'elsif sel.u32 == 10U then', 'elsif sel.u32 == 9U then', 'elsif sel.u32 == 8U then', 'else', 'endif);', 'D0[31 : 24] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[31 : 24]);', 'D0[23 : 16] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[23 : 16]);', 'D0[15 : 8] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[15 : 8]);', 'D0[7 : 0] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[7 : 0])']},
  'V_PK_ADD_F16': {'opcode': 15, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_ADD_I16': {'opcode': 2, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_ADD_U16': {'opcode': 10, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_ASHRREV_I16': {'opcode': 6, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp[31 : 16].i16 = (S1[31 : 16].i16 >> S0.u32[19 : 16].u32);', 'tmp[15 : 0].i16 = (S1[15 : 0].i16 >> S0.u32[3 : 0].u32);', 'D0.b32 = tmp.b32']},
  'V_PK_FMA_F16': {'opcode': 14, 'section': 'VOP2_VOP3', 'pseudocode': ["declare tmp : 32'B;", 'D0.b32 = tmp']},
  'V_PK_LSHLREV_B16': {'opcode': 4, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp[31 : 16].u16 = (S1[31 : 16].u16 << S0.u32[19 : 16].u32);', 'tmp[15 : 0].u16 = (S1[15 : 0].u16 << S0.u32[3 : 0].u32);', 'D0.b32 = tmp.b32']},
  'V_PK_LSHRREV_B16': {'opcode': 5, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp[31 : 16].u16 = (S1[31 : 16].u16 >> S0.u32[19 : 16].u32);', 'tmp[15 : 0].u16 = (S1[15 : 0].u16 >> S0.u32[3 : 0].u32);', 'D0.b32 = tmp.b32']},
  'V_PK_MAD_I16': {'opcode': 0, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_MAD_U16': {'opcode': 9, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_MAX_F16': {'opcode': 18, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_MAX_I16': {'opcode': 7, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_MIN_F16': {'opcode': 17, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_MIN_I16': {'opcode': 8, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_MIN_U16': {'opcode': 13, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_MUL_LO_U16': {'opcode': 1, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_PK_SUB_U16': {'opcode': 11, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.b32 = tmp.b32']},
  'V_RCP_F16': {'opcode': 468, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f16 = 16'1.0 / S0.f16"]},
  'V_RCP_F32': {'opcode': 426, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = 1.0F / S0.f32']},
  'V_RCP_F64': {'opcode': 431, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = 1.0 / S0.f64']},
  'V_RCP_IFLAG_F32': {'opcode': 427, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = 1.0F / S0.f32;', '// Can only raise integer DIV_BY_ZERO exception']},
  'V_READFIRSTLANE_B32': {'opcode': 386, 'section': 'VOP2_VOP3', 'pseudocode': ["declare lane : 32'U;", 'if WAVE64 then', '// 64 lanes', 'if EXEC == 0x0LL then', 'lane = 0U;', '// Force lane 0 if all lanes are disabled', 'else', "lane = 32'U(s_ff1_i32_b64(EXEC));", '// Lowest active lane', 'endif', 'else', '// 32 lanes', 'if EXEC_LO.i32 == 0 then', 'lane = 0U;', '// Force lane 0 if all lanes are disabled', 'else', "lane = 32'U(s_ff1_i32_b32(EXEC_LO));", '// Lowest active lane', 'endif', 'endif;', 'D0.b32 = VGPR[lane][SRC0.u32]']},
  'V_READLANE_B32': {'opcode': 864, 'section': 'VOP2_VOP3', 'pseudocode': ["declare lane : 32'U;", 'if WAVE32 then', 'lane = S1.u32[4 : 0].u32;', '// Lane select for wave32', 'else', 'lane = S1.u32[5 : 0].u32;', '// Lane select for wave64', 'endif;', 'D0.b32 = VGPR[lane][SRC0.u32]']},
  'V_RNDNE_F16': {'opcode': 478, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f16 = floor(S0.f16 + 16'0.5);", "if (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then", "D0.f16 -= 16'1.0"]},
  'V_RNDNE_F32': {'opcode': 419, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = floor(S0.f32 + 0.5F);', "if (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then", 'D0.f32 -= 1.0F', 'endif']},
  'V_RNDNE_F64': {'opcode': 409, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = floor(S0.f64 + 0.5);', 'if (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then', 'D0.f64 -= 1.0', 'endif']},
  'V_RSQ_F16': {'opcode': 470, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f16 = 16'1.0 / sqrt(S0.f16)"]},
  'V_RSQ_F32': {'opcode': 430, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = 1.0F / sqrt(S0.f32)']},
  'V_RSQ_F64': {'opcode': 433, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = 1.0 / sqrt(S0.f64)']},
  'V_SAD_HI_U8': {'opcode': 547, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.u32 = (32'U(v_sad_u8(S0, S1, 0U)) << 16U) + S2.u32"]},
  'V_SAD_U32': {'opcode': 549, 'section': 'VOP2_VOP3', 'pseudocode': ['// UNSIGNED comparison', 'D0.u32 = ABSDIFF(S0.u32, S1.u32) + S2.u32']},
  'V_SAD_U8': {'opcode': 546, 'section': 'VOP2_VOP3', 'pseudocode': ['// UNSIGNED comparison', 'tmp = S2.u32;', "tmp += 32'U(ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]));", "tmp += 32'U(ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]));", "tmp += 32'U(ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]));", "tmp += 32'U(ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]));", 'D0.u32 = tmp']},
  'V_SAT_PK_U8_I16': {'opcode': 482, 'section': 'VOP2_VOP3', 'pseudocode': ['if n.i32 <= 0 then', "elsif n >= 16'I(0xff) then", 'else', 'endif);', 'D0.b16 = { SAT8(S0[31 : 16].i16), SAT8(S0[15 : 0].i16) }']},
  'V_SIN_F16': {'opcode': 480, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f16 = sin(S0.f16 * 16'F(PI * 2.0))"]},
  'V_SIN_F32': {'opcode': 437, 'section': 'VOP2_VOP3', 'pseudocode': ["D0.f32 = sin(S0.f32 * 32'F(PI * 2.0))"]},
  'V_SQRT_F16': {'opcode': 469, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = sqrt(S0.f16)']},
  'V_SQRT_F32': {'opcode': 435, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = sqrt(S0.f32)']},
  'V_SQRT_F64': {'opcode': 436, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = sqrt(S0.f64)']},
  'V_SUBREV_CO_CI_U32': {'opcode': 290, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S1.u32 - S0.u32 - VCC.u64[laneId].u32;', "VCC.u64[laneId] = 64'U(S0.u32) + VCC.u64[laneId].u64 > 64'U(S1.u32) ? 1'1U : 1'0U;", '// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.', 'D0.u32 = tmp.u32']},
  'V_SUBREV_CO_U32': {'opcode': 770, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S1.u32 - S0.u32;', "VCC.u64[laneId] = S0.u32 > S1.u32 ? 1'1U : 1'0U;", '// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.', 'D0.u32 = tmp.u32']},
  'V_SUBREV_F16': {'opcode': 308, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = S1.f16 - S0.f16']},
  'V_SUBREV_F32': {'opcode': 5, 'section': 'SMEM', 'pseudocode': ['D0.f32 = S1.f32 - S0.f32']},
  'V_SUBREV_NC_U32': {'opcode': 295, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = S1.u32 - S0.u32']},
  'V_SUB_CO_CI_U32': {'opcode': 289, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S0.u32 - S1.u32 - VCC.u64[laneId].u32;', "VCC.u64[laneId] = 64'U(S1.u32) + VCC.u64[laneId].u64 > 64'U(S0.u32) ? 1'1U : 1'0U;", '// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.', 'D0.u32 = tmp.u32']},
  'V_SUB_CO_U32': {'opcode': 769, 'section': 'VOP2_VOP3', 'pseudocode': ['tmp = S0.u32 - S1.u32;', "VCC.u64[laneId] = S1.u32 > S0.u32 ? 1'1U : 1'0U;", '// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.', 'D0.u32 = tmp.u32']},
  'V_SUB_F16': {'opcode': 307, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = S0.f16 - S1.f16']},
  'V_SUB_F32': {'opcode': 260, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = S0.f32 - S1.f32']},
  'V_SUB_NC_I16': {'opcode': 782, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i16 = S0.i16 - S1.i16']},
  'V_SUB_NC_I32': {'opcode': 805, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.i32 = S0.i32 - S1.i32']},
  'V_SUB_NC_U16': {'opcode': 772, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = S0.u16 - S1.u16']},
  'V_SUB_NC_U32': {'opcode': 294, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = S0.u32 - S1.u32']},
  'V_SWAPREL_B32': {'opcode': 104, 'section': 'VOP1', 'pseudocode': ['addrs = SRC0.u32;', '// Raw value from instruction', 'addrd = DST.u32;', '// Raw value from instruction', 'tmp = VGPR[laneId][addrd].b32;']},
  'V_SWAP_B16': {'opcode': 102, 'section': 'VOP1', 'pseudocode': ['tmp = D0.b16;', 'D0.b16 = S0.b16;', 'S0.b16 = tmp']},
  'V_SWAP_B32': {'opcode': 101, 'section': 'VOP1', 'pseudocode': ['tmp = D0.b32;', 'D0.b32 = S0.b32;', 'S0.b32 = tmp']},
  'V_TRIG_PREOP_F64': {'opcode': 815, 'section': 'VOP2_VOP3', 'pseudocode': ["shift = 32'I(S1[4 : 0].u32) * 53;", 'if exponent(S0.f64) > 1077 then', 'shift += exponent(S0.f64) - 1077', 'endif;', '// (2.0/PI) == 0.{b_1200, b_1199, b_1198, ..., b_1, b_0}', '// b_1200 is the MSB of the fractional part of 2.0/PI', '// Left shift operation indicates which bits are brought', "result = 64'F((1201'B(2.0 / PI)[1200 : 0] << shift.u32) & 1201'0x1fffffffffffff);", 'scale = -53 - shift;', 'if exponent(S0.f64) >= 1968 then', 'scale += 128', 'endif;', 'D0.f64 = ldexp(result, scale)']},
  'V_TRUNC_F16': {'opcode': 477, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f16 = trunc(S0.f16)']},
  'V_TRUNC_F32': {'opcode': 417, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f32 = trunc(S0.f32)']},
  'V_TRUNC_F64': {'opcode': 407, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.f64 = trunc(S0.f64)']},
  'V_WMMA_BF16_16X16X16_BF16': {'opcode': 67, 'section': 'VOP2_VOP3', 'pseudocode': ['saved_exec = EXEC;', "EXEC = 64'B(-1);", 'eval "D0.bf16(16x16) = S0.bf16(16x16) * S1.bf16(16x16) + S2.bf16(16x16)";']},
  'V_WMMA_F16_16X16X16_F16': {'opcode': 66, 'section': 'VOP2_VOP3', 'pseudocode': ['saved_exec = EXEC;', "EXEC = 64'B(-1);", 'eval "D0.f16(16x16) = S0.f16(16x16) * S1.f16(16x16) + S2.f16(16x16)";', 'EXEC = saved_exec']},
  'V_WMMA_F32_16X16X16_F16': {'opcode': 64, 'section': 'VOP2_VOP3', 'pseudocode': ['saved_exec = EXEC;', "EXEC = 64'B(-1);", 'eval "D0.f32(16x16) = S0.f16(16x16) * S1.f16(16x16) + S2.f32(16x16)";', 'EXEC = saved_exec']},
  'V_WMMA_I32_16X16X16_IU4': {'opcode': 69, 'section': 'VOP2_VOP3', 'pseudocode': ['saved_exec = EXEC;', "EXEC = 64'B(-1);", 'eval "D0.i32(16x16) = S0.iu4(16x16) * S1.iu4(16x16) + S2.i32(16x16)";', 'EXEC = saved_exec']},
  'V_WMMA_I32_16X16X16_IU8': {'opcode': 68, 'section': 'VOP2_VOP3', 'pseudocode': ['saved_exec = EXEC;', "EXEC = 64'B(-1);", 'eval "D0.i32(16x16) = S0.iu8(16x16) * S1.iu8(16x16) + S2.i32(16x16)";', 'EXEC = saved_exec']},
  'V_WRITELANE_B32': {'opcode': 865, 'section': 'VOP2_VOP3', 'pseudocode': ["declare lane : 32'U;", 'if WAVE32 then', 'lane = S1.u32[4 : 0].u32;', '// Lane select for wave32', 'else', 'lane = S1.u32[5 : 0].u32;', '// Lane select for wave64', 'endif;', 'VGPR[lane][VDST.u32] = S0.b32']},
  'V_XAD_U32': {'opcode': 581, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (S0.u32 ^ S1.u32) + S2.u32']},
  'V_XNOR_B32': {'opcode': 286, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = ~(S0.u32 ^ S1.u32)']},
  'V_XOR3_B32': {'opcode': 576, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u32 = (S0.u32 ^ S1.u32 ^ S2.u32)']},
  'V_XOR_B16': {'opcode': 868, 'section': 'VOP2_VOP3', 'pseudocode': ['D0.u16 = (S0.u16 ^ S1.u16)']},
  'V_XOR_B32': {'opcode': 29, 'section': 'SMEM', 'pseudocode': ['D0.u32 = (S0.u32 ^ S1.u32)']},
}