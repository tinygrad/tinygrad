#!/usr/bin/env python3
"""Extract and parse pseudocode from AMD RDNA3.5 ISA PDF for emulation."""
import re, pathlib
from typing import Any

PDF_URL = "https://docs.amd.com/api/khub/documents/UVVZM22UN7tMUeiW_4ShTQ/content"
INST_PATTERN = re.compile(r'^([SV]_[A-Z0-9_]+)\s+(\d+)\s*$', re.M)

# Op enum classes that have pseudocode in the PDF
from extra.assembly.rdna3.autogen import SOP1Op, SOP2Op, SOPCOp, SOPKOp, SOPPOp, VOP1Op, VOP2Op, VOP3Op, VOP3SDOp, VOP3POp, VOPCOp
_OP_ENUMS = [SOP1Op, SOP2Op, SOPCOp, SOPKOp, SOPPOp, VOP1Op, VOP2Op, VOP3Op, VOP3SDOp, VOP3POp, VOPCOp]

def _get_defined_ops() -> dict[tuple[str, int], tuple[type, Any]]:
  """Get all ops defined in autogen/__init__.py as {(name, opcode): (enum_cls, enum_val)}."""
  ops = {}
  for enum_cls in _OP_ENUMS:
    for op in enum_cls:
      if op.name.startswith(('S_', 'V_')): ops[(op.name, op.value)] = (enum_cls, op)
  return ops

def extract_pseudocode(text: str) -> str | None:
  """Extract pseudocode from an instruction description snippet. Returns single string or None."""
  lines, result, depth = text.split('\n'), [], 0
  for line in lines:
    s = line.strip()
    if not s: continue
    # Skip page headers/footers
    if re.match(r'^\d+ of \d+$', s): continue
    if re.match(r'^\d+\.\d+\..*Instructions', s): continue
    if s.startswith('"RDNA') or s.startswith('AMD '): continue
    # Stop at notes/examples sections
    if s.startswith('Notes') or s.startswith('Functional examples'): break
    # Track control flow depth
    if s.startswith('if '): depth += 1
    elif s.startswith('endif'): depth = max(0, depth - 1)
    # Skip prose sentences
    if s.endswith('.') and not any(p in s for p in ['D0', 'D1', 'S0', 'S1', 'S2', 'SCC', 'VCC', 'tmp', '=']): continue
    if re.match(r'^[a-z].*\.$', s) and '=' not in s: continue
    # Detect code lines
    is_code = (
      any(p in s for p in ['D0.', 'D1.', 'S0.', 'S1.', 'S2.', 'SCC =', 'SCC ?', 'VCC', 'EXEC', 'tmp =', 'tmp[', 'lane =']) or
      any(p in s for p in ['D0[', 'D1[', 'S0[', 'S1[', 'S2[']) or  # VOP3P packed bit range access
      s.startswith(('if ', 'else', 'elsif', 'endif', 'declare ', 'for ', '//')) or
      re.match(r'^[a-z_]+\s*=', s) or re.match(r'^[a-z_]+\[', s) or (depth > 0 and '=' in s)
    )
    if is_code: result.append(s)
  if not result: return None
  return '\n'.join(result)

def parse_pseudocode(pdf_path: str | None = None) -> dict[type, dict[Any, str]]:
  """Parse pseudocode from PDF for all ops defined in autogen/__init__.py. Returns {enum_cls: {op: pseudocode}}."""
  import pdfplumber
  from tinygrad.helpers import fetch

  defined_ops = _get_defined_ops()
  pdf = pdfplumber.open(fetch(PDF_URL) if pdf_path is None else pdf_path)

  # Concatenate all instruction pages into one text blob
  all_text = '\n'.join(pdf.pages[i].extract_text() or '' for i in range(195, 560))

  # Find all instruction headers and their positions
  matches = list(INST_PATTERN.finditer(all_text))
  # Use separate dicts per enum class to avoid IntEnum hash collisions
  instructions: dict[type, dict[Any, str]] = {cls: {} for cls in _OP_ENUMS}

  for i, match in enumerate(matches):
    name, opcode = match.group(1), int(match.group(2))
    # Only process if this op is defined in __init__.py with matching opcode
    key = (name, opcode)
    if key not in defined_ops: continue
    enum_cls, enum_val = defined_ops[key]

    # Extract text until next instruction header
    start = match.end()
    end = matches[i + 1].start() if i + 1 < len(matches) else start + 2000
    snippet = all_text[start:end].strip()
    if (pseudocode := extract_pseudocode(snippet)): instructions[enum_cls][enum_val] = pseudocode

  return instructions

def generate(output_path: pathlib.Path | str | None = None) -> dict[type, dict[Any, str]]:
  """Generate pseudocode data file from PDF. Returns {enum_cls: {op: pseudocode}}."""
  by_cls = parse_pseudocode()

  # Print coverage stats
  total_found, total_ops = 0, 0
  for enum_cls in _OP_ENUMS:
    total = sum(1 for op in enum_cls if op.name.startswith(('S_', 'V_')))
    found = len(by_cls.get(enum_cls, {}))
    total_found += found
    total_ops += total
    print(f"{enum_cls.__name__}: {found}/{total} ({100*found//total if total else 0}%)")
  print(f"Total: {total_found}/{total_ops} ({100*total_found//total_ops}%)")

  if output_path is not None:
    lines = [
      "# autogenerated from AMD RDNA3.5 ISA PDF by pseudocode_generate.py - do not edit",
      "# to regenerate: python -m extra.assembly.rdna3.pseudocode_generate",
      "from extra.assembly.rdna3.autogen import SOP1Op, SOP2Op, SOPCOp, SOPKOp, SOPPOp, VOP1Op, VOP2Op, VOP3Op, VOP3SDOp, VOP3POp, VOPCOp",
      "",
    ]
    for enum_cls in _OP_ENUMS:
      if not by_cls.get(enum_cls): continue
      lines.append(f"{enum_cls.__name__}_PSEUDOCODE = {{")
      for op in sorted(by_cls[enum_cls].keys(), key=lambda x: x.value):
        lines.append(f"  {enum_cls.__name__}.{op.name}: {by_cls[enum_cls][op]!r},")
      lines.append("}")
      lines.append("")
    pathlib.Path(output_path).write_text('\n'.join(lines) + '\n')
    print(f"Generated {output_path} with {total_found} instructions")

  return by_cls

if __name__ == "__main__":
  generate("extra/assembly/rdna3/autogen/pseudocode_data.py")
