# autogenerated by pcode.py - do not edit
# to regenerate: python -m extra.assembly.amd.pcode --arch cdna
# ruff: noqa: E501,F405,F403
# mypy: ignore-errors
from extra.assembly.amd.autogen.cdna import SOP1Op, SOP2Op, SOPCOp, SOPKOp, SOPPOp, VOP1Op, VOP2Op, VOP3POp, VOPCOp, VOP3AOp, VOP3BOp
from extra.assembly.amd.pcode import *

def _SOP1Op_S_MOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b32 = S0.b32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b32 = S0.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_MOV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b64 = S0.b64
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b64 = S0.b64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_CMOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if SCC then
  # D0.b32 = S0.b32
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  if SCC:
    D0.b32 = S0.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP1Op_S_CMOV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if SCC then
  # D0.b64 = S0.b64
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  if SCC:
    D0.b64 = S0.b64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_NOT_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ~S0.u32;
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = ~S0.u32
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP1Op_S_NOT_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = ~S0.u64;
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = ~S0.u64
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_BREV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32[31 : 0] = S0.u32[0 : 31]
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32[31 : 0] = S0.u32[0 : 31]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_BREV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[63 : 0] = S0.u64[0 : 63]
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u64[63 : 0] = S0.u64[0 : 63]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_BCNT0_I32_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 0;
  # for i in 0 : 31 do
  # tmp += S0.u32[i] == 1'0U ? 1 : 0
  # endfor;
  # D0.i32 = tmp;
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(0)
  for i in range(0, int(31)+1):
    tmp += ((1) if (S0.u32[i] == 0) else (0))
  D0.i32 = tmp
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP1Op_S_BCNT0_I32_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 0;
  # for i in 0 : 63 do
  # tmp += S0.u64[i] == 1'0U ? 1 : 0
  # endfor;
  # D0.i32 = tmp;
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(0)
  for i in range(0, int(63)+1):
    tmp += ((1) if (S0.u64[i] == 0) else (0))
  D0.i32 = tmp
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_BCNT1_I32_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 0;
  # for i in 0 : 31 do
  # tmp += S0.u32[i] == 1'1U ? 1 : 0
  # endfor;
  # D0.i32 = tmp;
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(0)
  for i in range(0, int(31)+1):
    tmp += ((1) if (S0.u32[i] == 1) else (0))
  D0.i32 = tmp
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP1Op_S_BCNT1_I32_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 0;
  # for i in 0 : 63 do
  # tmp += S0.u64[i] == 1'1U ? 1 : 0
  # endfor;
  # D0.i32 = tmp;
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(0)
  for i in range(0, int(63)+1):
    tmp += ((1) if (S0.u64[i] == 1) else (0))
  D0.i32 = tmp
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_FF0_I32_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = -1;
  # // Set if no zeros are found
  # for i in 0 : 31 do
  # // Search from LSB
  # if S0.u32[i] == 1'0U then
  # tmp = i;
  # endif
  # endfor;
  # D0.i32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(-1)
  for i in range(0, int(31)+1):
    if S0.u32[i] == 0:
      tmp = Reg(i)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_FF0_I32_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = -1;
  # // Set if no zeros are found
  # for i in 0 : 63 do
  # // Search from LSB
  # if S0.u64[i] == 1'0U then
  # tmp = i;
  # endif
  # endfor;
  # D0.i32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(-1)
  for i in range(0, int(63)+1):
    if S0.u64[i] == 0:
      tmp = Reg(i)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_FF1_I32_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = -1;
  # // Set if no ones are found
  # for i in 0 : 31 do
  # // Search from LSB
  # if S0.u32[i] == 1'1U then
  # tmp = i;
  # endif
  # endfor;
  # D0.i32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(-1)
  for i in range(0, int(31)+1):
    if S0.u32[i] == 1:
      tmp = Reg(i)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_FF1_I32_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = -1;
  # // Set if no ones are found
  # for i in 0 : 63 do
  # // Search from LSB
  # if S0.u64[i] == 1'1U then
  # tmp = i;
  # endif
  # endfor;
  # D0.i32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(-1)
  for i in range(0, int(63)+1):
    if S0.u64[i] == 1:
      tmp = Reg(i)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_FLBIT_I32_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = -1;
  # // Set if no ones are found
  # for i in 0 : 31 do
  # // Search from MSB
  # if S0.u32[31 - i] == 1'1U then
  # tmp = i;
  # endif
  # endfor;
  # D0.i32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(-1)
  for i in range(0, int(31)+1):
    if S0.u32[31 - i] == 1:
      tmp = Reg(i)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_FLBIT_I32_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = -1;
  # // Set if no ones are found
  # for i in 0 : 63 do
  # // Search from MSB
  # if S0.u64[63 - i] == 1'1U then
  # tmp = i;
  # endif
  # endfor;
  # D0.i32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(-1)
  for i in range(0, int(63)+1):
    if S0.u64[63 - i] == 1:
      tmp = Reg(i)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_FLBIT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = -1;
  # // Set if all bits are the same
  # for i in 1 : 31 do
  # // Search from MSB
  # if S0.u32[31 - i] != S0.u32[31] then
  # tmp = i;
  # endif
  # endfor;
  # D0.i32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(-1)
  for i in range(1, int(31)+1):
    if S0.u32[31 - i] != S0.u32[31]:
      tmp = Reg(i)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_FLBIT_I32_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = -1;
  # // Set if all bits are the same
  # for i in 1 : 63 do
  # // Search from MSB
  # if S0.u64[63 - i] != S0.u64[63] then
  # tmp = i;
  # endif
  # endfor;
  # D0.i32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(-1)
  for i in range(1, int(63)+1):
    if S0.u64[63 - i] != S0.u64[63]:
      tmp = Reg(i)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_SEXT_I32_I8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(signext(S0.i8))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (signext(S0.i8))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_SEXT_I32_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(signext(S0.i16))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (signext(S0.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_BITSET0_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32[S0.u32[4 : 0]] = 1'0U
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32[S0.u32[4 : 0]] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_BITSET0_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[S0.u32[5 : 0]] = 1'0U
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u64[S0.u32[5 : 0]] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_BITSET1_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32[S0.u32[4 : 0]] = 1'1U
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32[S0.u32[4 : 0]] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_BITSET1_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[S0.u32[5 : 0]] = 1'1U
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u64[S0.u32[5 : 0]] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_AND_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,
  # set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar
  # saveexec = EXEC.u64;
  # EXEC.u64 = (S0.u64 & EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = (S0.u64 & EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_OR_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set
  # SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination
  # saveexec = EXEC.u64;
  # EXEC.u64 = (S0.u64 | EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = (S0.u64 | EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_XOR_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,
  # set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar
  # saveexec = EXEC.u64;
  # EXEC.u64 = (S0.u64 ^ EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = (S0.u64 ^ EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_ANDN2_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into
  # the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into
  # saveexec = EXEC.u64;
  # EXEC.u64 = (S0.u64 & ~EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = (S0.u64 & ~EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_ORN2_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the
  # EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the
  # saveexec = EXEC.u64;
  # EXEC.u64 = (S0.u64 | ~EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = (S0.u64 | ~EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_NAND_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise NAND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,
  # set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar
  # saveexec = EXEC.u64;
  # EXEC.u64 = ~(S0.u64 & EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = ~(S0.u64 & EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_NOR_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise NOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,
  # set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar
  # saveexec = EXEC.u64;
  # EXEC.u64 = ~(S0.u64 | EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = ~(S0.u64 | EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_XNOR_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise XNOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask,
  # set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar
  # saveexec = EXEC.u64;
  # EXEC.u64 = ~(S0.u64 ^ EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = ~(S0.u64 ^ EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_ABS_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 < 0 ? -S0.i32 : S0.i32;
  # SCC = D0.i32 != 0
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.i32 = ((-S0.i32) if (S0.i32 < 0) else (S0.i32))
  SCC = Reg(D0.i32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP1Op_S_SET_GPR_IDX_IDX(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # M0[7 : 0] = S0.u32[7 : 0].b8
  S0 = Reg(s0)
  # --- compiled pseudocode ---
  M0[7 : 0] = S0.u32[7 : 0].b8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _SOP1Op_S_ANDN1_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into
  # the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into
  # saveexec = EXEC.u64;
  # EXEC.u64 = (~S0.u64 & EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = (~S0.u64 & EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_ORN1_SAVEEXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the
  # EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the
  # saveexec = EXEC.u64;
  # EXEC.u64 = (~S0.u64 | EXEC.u64);
  # D0.u64 = saveexec.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  saveexec = Reg(exec_mask)
  # --- compiled pseudocode ---
  saveexec = Reg(EXEC.u64)
  EXEC.u64 = (~S0.u64 | EXEC.u64)
  D0.u64 = saveexec.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_ANDN1_WREXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into
  # Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op
  # result. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is
  # EXEC.u64 = (~S0.u64 & EXEC.u64);
  # D0.u64 = EXEC.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  # --- compiled pseudocode ---
  EXEC.u64 = (~S0.u64 & EXEC.u64)
  D0.u64 = EXEC.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_ANDN2_WREXEC_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into
  # Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op
  # result. EXEC and the destination SGPRs have the same value at the end of this instruction. This instruction is
  # EXEC.u64 = (S0.u64 & ~EXEC.u64);
  # D0.u64 = EXEC.u64;
  # SCC = EXEC.u64 != 0ULL
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  EXEC = Reg(exec_mask)
  # --- compiled pseudocode ---
  EXEC.u64 = (S0.u64 & ~EXEC.u64)
  D0.u64 = EXEC.u64
  SCC = Reg(EXEC.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _SOP1Op_S_BITREPLICATE_B64_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32;
  # for i in 0 : 31 do
  # D0.u64[i * 2] = tmp[i];
  # D0.u64[i * 2 + 1] = tmp[i]
  # endfor
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32)
  for i in range(0, int(31)+1):
    D0.u64[i * 2] = tmp[i]
    D0.u64[i * 2 + 1] = tmp[i]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

SOP1Op_FUNCTIONS = {
  SOP1Op.S_MOV_B32: _SOP1Op_S_MOV_B32,
  SOP1Op.S_MOV_B64: _SOP1Op_S_MOV_B64,
  SOP1Op.S_CMOV_B32: _SOP1Op_S_CMOV_B32,
  SOP1Op.S_CMOV_B64: _SOP1Op_S_CMOV_B64,
  SOP1Op.S_NOT_B32: _SOP1Op_S_NOT_B32,
  SOP1Op.S_NOT_B64: _SOP1Op_S_NOT_B64,
  SOP1Op.S_BREV_B32: _SOP1Op_S_BREV_B32,
  SOP1Op.S_BREV_B64: _SOP1Op_S_BREV_B64,
  SOP1Op.S_BCNT0_I32_B32: _SOP1Op_S_BCNT0_I32_B32,
  SOP1Op.S_BCNT0_I32_B64: _SOP1Op_S_BCNT0_I32_B64,
  SOP1Op.S_BCNT1_I32_B32: _SOP1Op_S_BCNT1_I32_B32,
  SOP1Op.S_BCNT1_I32_B64: _SOP1Op_S_BCNT1_I32_B64,
  SOP1Op.S_FF0_I32_B32: _SOP1Op_S_FF0_I32_B32,
  SOP1Op.S_FF0_I32_B64: _SOP1Op_S_FF0_I32_B64,
  SOP1Op.S_FF1_I32_B32: _SOP1Op_S_FF1_I32_B32,
  SOP1Op.S_FF1_I32_B64: _SOP1Op_S_FF1_I32_B64,
  SOP1Op.S_FLBIT_I32_B32: _SOP1Op_S_FLBIT_I32_B32,
  SOP1Op.S_FLBIT_I32_B64: _SOP1Op_S_FLBIT_I32_B64,
  SOP1Op.S_FLBIT_I32: _SOP1Op_S_FLBIT_I32,
  SOP1Op.S_FLBIT_I32_I64: _SOP1Op_S_FLBIT_I32_I64,
  SOP1Op.S_SEXT_I32_I8: _SOP1Op_S_SEXT_I32_I8,
  SOP1Op.S_SEXT_I32_I16: _SOP1Op_S_SEXT_I32_I16,
  SOP1Op.S_BITSET0_B32: _SOP1Op_S_BITSET0_B32,
  SOP1Op.S_BITSET0_B64: _SOP1Op_S_BITSET0_B64,
  SOP1Op.S_BITSET1_B32: _SOP1Op_S_BITSET1_B32,
  SOP1Op.S_BITSET1_B64: _SOP1Op_S_BITSET1_B64,
  SOP1Op.S_AND_SAVEEXEC_B64: _SOP1Op_S_AND_SAVEEXEC_B64,
  SOP1Op.S_OR_SAVEEXEC_B64: _SOP1Op_S_OR_SAVEEXEC_B64,
  SOP1Op.S_XOR_SAVEEXEC_B64: _SOP1Op_S_XOR_SAVEEXEC_B64,
  SOP1Op.S_ANDN2_SAVEEXEC_B64: _SOP1Op_S_ANDN2_SAVEEXEC_B64,
  SOP1Op.S_ORN2_SAVEEXEC_B64: _SOP1Op_S_ORN2_SAVEEXEC_B64,
  SOP1Op.S_NAND_SAVEEXEC_B64: _SOP1Op_S_NAND_SAVEEXEC_B64,
  SOP1Op.S_NOR_SAVEEXEC_B64: _SOP1Op_S_NOR_SAVEEXEC_B64,
  SOP1Op.S_XNOR_SAVEEXEC_B64: _SOP1Op_S_XNOR_SAVEEXEC_B64,
  SOP1Op.S_ABS_I32: _SOP1Op_S_ABS_I32,
  SOP1Op.S_SET_GPR_IDX_IDX: _SOP1Op_S_SET_GPR_IDX_IDX,
  SOP1Op.S_ANDN1_SAVEEXEC_B64: _SOP1Op_S_ANDN1_SAVEEXEC_B64,
  SOP1Op.S_ORN1_SAVEEXEC_B64: _SOP1Op_S_ORN1_SAVEEXEC_B64,
  SOP1Op.S_ANDN1_WREXEC_B64: _SOP1Op_S_ANDN1_WREXEC_B64,
  SOP1Op.S_ANDN2_WREXEC_B64: _SOP1Op_S_ANDN2_WREXEC_B64,
  SOP1Op.S_BITREPLICATE_B64_B32: _SOP1Op_S_BITREPLICATE_B64_B32,
}

def _SOP2Op_S_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 64'U(S0.u32) + 64'U(S1.u32);
  # SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg((S0.u32) + (S1.u32))
  SCC = Reg(((1) if (tmp >= 0x100000000) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_SUB_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32 - S1.u32;
  # SCC = S1.u32 > S0.u32 ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32 - S1.u32)
  SCC = Reg(((1) if (S1.u32 > S0.u32) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_ADD_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.i32 + S1.i32;
  # SCC = ((S0.u32[31] == S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));
  # D0.i32 = tmp.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.i32 + S1.i32)
  SCC = Reg(((S0.u32[31] == S1.u32[31])  and  (S0.u32[31] != tmp.u32[31])))
  D0.i32 = tmp.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_SUB_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.i32 - S1.i32;
  # SCC = ((S0.u32[31] != S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));
  # D0.i32 = tmp.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.i32 - S1.i32)
  SCC = Reg(((S0.u32[31] != S1.u32[31])  and  (S0.u32[31] != tmp.u32[31])))
  D0.i32 = tmp.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_ADDC_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 64'U(S0.u32) + 64'U(S1.u32) + SCC.u64;
  # SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg((S0.u32) + (S1.u32) + SCC.u64)
  SCC = Reg(((1) if (tmp >= 0x100000000) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_SUBB_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32 - S1.u32 - SCC.u32;
  # SCC = 64'U(S1.u32) + SCC.u64 > 64'U(S0.u32) ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32 - S1.u32 - SCC.u32)
  SCC = Reg(((1) if ((S1.u32) + SCC.u64 > (S0.u32)) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_MIN_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 < S1.i32;
  # D0.i32 = SCC ? S0.i32 : S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 < S1.i32)
  D0.i32 = ((S0.i32) if (SCC) else (S1.i32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_MIN_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 < S1.u32;
  # D0.u32 = SCC ? S0.u32 : S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 < S1.u32)
  D0.u32 = ((S0.u32) if (SCC) else (S1.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_MAX_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 >= S1.i32;
  # D0.i32 = SCC ? S0.i32 : S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 >= S1.i32)
  D0.i32 = ((S0.i32) if (SCC) else (S1.i32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_MAX_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 >= S1.u32;
  # D0.u32 = SCC ? S0.u32 : S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 >= S1.u32)
  D0.u32 = ((S0.u32) if (SCC) else (S1.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_CSELECT_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = SCC ? S0.u32 : S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32) if (SCC) else (S1.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_CSELECT_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = SCC ? S0.u64 : S1.u64
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = ((S0.u64) if (SCC) else (S1.u64))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_AND_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 & S1.u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 & S1.u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_AND_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S0.u64 & S1.u64);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = (S0.u64 & S1.u64)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_OR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 | S1.u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 | S1.u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_OR_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S0.u64 | S1.u64);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = (S0.u64 | S1.u64)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_XOR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 ^ S1.u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 ^ S1.u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_XOR_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S0.u64 ^ S1.u64);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = (S0.u64 ^ S1.u64)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_ANDN2_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 & ~S1.u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 & ~S1.u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_ANDN2_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S0.u64 & ~S1.u64);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = (S0.u64 & ~S1.u64)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_ORN2_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 | ~S1.u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 | ~S1.u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_ORN2_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S0.u64 | ~S1.u64);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = (S0.u64 | ~S1.u64)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_NAND_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ~(S0.u32 & S1.u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = ~(S0.u32 & S1.u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_NAND_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = ~(S0.u64 & S1.u64);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = ~(S0.u64 & S1.u64)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_NOR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ~(S0.u32 | S1.u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = ~(S0.u32 | S1.u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_NOR_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = ~(S0.u64 | S1.u64);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = ~(S0.u64 | S1.u64)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_XNOR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ~(S0.u32 ^ S1.u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = ~(S0.u32 ^ S1.u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_XNOR_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = ~(S0.u64 ^ S1.u64);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = ~(S0.u64 ^ S1.u64)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_LSHL_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 << S1[4 : 0].u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 << S1[4 : 0].u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_LSHL_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S0.u64 << S1[5 : 0].u32);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = (S0.u64 << S1[5 : 0].u32)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_LSHR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 >> S1[4 : 0].u32);
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 >> S1[4 : 0].u32)
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_LSHR_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S0.u64 >> S1[5 : 0].u32);
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = (S0.u64 >> S1[5 : 0].u32)
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_ASHR_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(signext(S0.i32) >> S1[4 : 0].u32);
  # SCC = D0.i32 != 0
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.i32 = (signext(S0.i32) >> S1[4 : 0].u32)
  SCC = Reg(D0.i32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_ASHR_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i64 = (signext(S0.i64) >> S1[5 : 0].u32);
  # SCC = D0.i64 != 0LL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.i64 = (signext(S0.i64) >> S1[5 : 0].u32)
  SCC = Reg(D0.i64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_BFM_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (((1U << S0[4 : 0].u32) - 1U) << S1[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (((1 << S0[4 : 0].u32) - 1) << S1[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP2Op_S_BFM_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (((1ULL << S0[5 : 0].u32) - 1ULL) << S1[5 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u64 = (((1 << S0[5 : 0].u32) - 1) << S1[5 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_MUL_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 * S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = S0.i32 * S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP2Op_S_BFE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1U << S1[22 : 16].u32) - 1U));
  # SCC = D0.u32 != 0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1 << S1[22 : 16].u32) - 1))
  SCC = Reg(D0.u32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_BFE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S1[22 : 16].u32) - 1));
  # D0.i32 = signext_from_bit(tmp.i32, S1[22 : 16].u32);
  # SCC = D0.i32 != 0
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S1[22 : 16].u32) - 1))
  D0.i32 = signext_from_bit(tmp.i32, S1[22 : 16].u32)
  SCC = Reg(D0.i32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_BFE_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = ((S0.u64 >> S1[5 : 0].u32) & ((1ULL << S1[22 : 16].u32) - 1ULL));
  # SCC = D0.u64 != 0ULL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.u64 = ((S0.u64 >> S1[5 : 0].u32) & ((1 << S1[22 : 16].u32) - 1))
  SCC = Reg(D0.u64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_BFE_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp.i64 = ((S0.i64 >> S1[5 : 0].u32) & ((1LL << S1[22 : 16].u32) - 1LL));
  # D0.i64 = signext_from_bit(tmp.i64, S1[22 : 16].u32);
  # SCC = D0.i64 != 0LL
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp.i64 = ((S0.i64 >> S1[5 : 0].u32) & ((1 << S1[22 : 16].u32) - 1))
  D0.i64 = signext_from_bit(tmp.i64, S1[22 : 16].u32)
  SCC = Reg(D0.i64 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

def _SOP2Op_S_ABSDIFF_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 - S1.i32;
  # if D0.i32 < 0 then
  # D0.i32 = -D0.i32
  # endif;
  # SCC = D0.i32 != 0
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  D0.i32 = S0.i32 - S1.i32
  if D0.i32 < 0:
    D0.i32 = -D0.i32
  SCC = Reg(D0.i32 != 0)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_MUL_HI_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U((64'U(S0.u32) * 64'U(S1.u32)) >> 32U)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (((S0.u32) * (S1.u32)) >> 32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP2Op_S_MUL_HI_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I((64'I(S0.i32) * 64'I(S1.i32)) >> 32U)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (((S0.i32) * (S1.i32)) >> 32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP2Op_S_LSHL1_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = (64'U(S0.u32) << 1U) + 64'U(S1.u32);
  # SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(((S0.u32) << 1) + (S1.u32))
  SCC = Reg(((1) if (tmp >= 0x100000000) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_LSHL2_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = (64'U(S0.u32) << 2U) + 64'U(S1.u32);
  # SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(((S0.u32) << 2) + (S1.u32))
  SCC = Reg(((1) if (tmp >= 0x100000000) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_LSHL3_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = (64'U(S0.u32) << 3U) + 64'U(S1.u32);
  # SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(((S0.u32) << 3) + (S1.u32))
  SCC = Reg(((1) if (tmp >= 0x100000000) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_LSHL4_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = (64'U(S0.u32) << 4U) + 64'U(S1.u32);
  # SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(((S0.u32) << 4) + (S1.u32))
  SCC = Reg(((1) if (tmp >= 0x100000000) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_PACK_LL_B32_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0 = { S1[15 : 0].u16, S0[15 : 0].u16 }
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0 = Reg(_pack(S1[15 : 0].u16, S0[15 : 0].u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP2Op_S_PACK_LH_B32_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0 = { S1[31 : 16].u16, S0[15 : 0].u16 }
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0 = Reg(_pack(S1[31 : 16].u16, S0[15 : 0].u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP2Op_S_PACK_HH_B32_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0 = { S1[31 : 16].u16, S0[31 : 16].u16 }
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0 = Reg(_pack(S1[31 : 16].u16, S0[31 : 16].u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

SOP2Op_FUNCTIONS = {
  SOP2Op.S_ADD_U32: _SOP2Op_S_ADD_U32,
  SOP2Op.S_SUB_U32: _SOP2Op_S_SUB_U32,
  SOP2Op.S_ADD_I32: _SOP2Op_S_ADD_I32,
  SOP2Op.S_SUB_I32: _SOP2Op_S_SUB_I32,
  SOP2Op.S_ADDC_U32: _SOP2Op_S_ADDC_U32,
  SOP2Op.S_SUBB_U32: _SOP2Op_S_SUBB_U32,
  SOP2Op.S_MIN_I32: _SOP2Op_S_MIN_I32,
  SOP2Op.S_MIN_U32: _SOP2Op_S_MIN_U32,
  SOP2Op.S_MAX_I32: _SOP2Op_S_MAX_I32,
  SOP2Op.S_MAX_U32: _SOP2Op_S_MAX_U32,
  SOP2Op.S_CSELECT_B32: _SOP2Op_S_CSELECT_B32,
  SOP2Op.S_CSELECT_B64: _SOP2Op_S_CSELECT_B64,
  SOP2Op.S_AND_B32: _SOP2Op_S_AND_B32,
  SOP2Op.S_AND_B64: _SOP2Op_S_AND_B64,
  SOP2Op.S_OR_B32: _SOP2Op_S_OR_B32,
  SOP2Op.S_OR_B64: _SOP2Op_S_OR_B64,
  SOP2Op.S_XOR_B32: _SOP2Op_S_XOR_B32,
  SOP2Op.S_XOR_B64: _SOP2Op_S_XOR_B64,
  SOP2Op.S_ANDN2_B32: _SOP2Op_S_ANDN2_B32,
  SOP2Op.S_ANDN2_B64: _SOP2Op_S_ANDN2_B64,
  SOP2Op.S_ORN2_B32: _SOP2Op_S_ORN2_B32,
  SOP2Op.S_ORN2_B64: _SOP2Op_S_ORN2_B64,
  SOP2Op.S_NAND_B32: _SOP2Op_S_NAND_B32,
  SOP2Op.S_NAND_B64: _SOP2Op_S_NAND_B64,
  SOP2Op.S_NOR_B32: _SOP2Op_S_NOR_B32,
  SOP2Op.S_NOR_B64: _SOP2Op_S_NOR_B64,
  SOP2Op.S_XNOR_B32: _SOP2Op_S_XNOR_B32,
  SOP2Op.S_XNOR_B64: _SOP2Op_S_XNOR_B64,
  SOP2Op.S_LSHL_B32: _SOP2Op_S_LSHL_B32,
  SOP2Op.S_LSHL_B64: _SOP2Op_S_LSHL_B64,
  SOP2Op.S_LSHR_B32: _SOP2Op_S_LSHR_B32,
  SOP2Op.S_LSHR_B64: _SOP2Op_S_LSHR_B64,
  SOP2Op.S_ASHR_I32: _SOP2Op_S_ASHR_I32,
  SOP2Op.S_ASHR_I64: _SOP2Op_S_ASHR_I64,
  SOP2Op.S_BFM_B32: _SOP2Op_S_BFM_B32,
  SOP2Op.S_BFM_B64: _SOP2Op_S_BFM_B64,
  SOP2Op.S_MUL_I32: _SOP2Op_S_MUL_I32,
  SOP2Op.S_BFE_U32: _SOP2Op_S_BFE_U32,
  SOP2Op.S_BFE_I32: _SOP2Op_S_BFE_I32,
  SOP2Op.S_BFE_U64: _SOP2Op_S_BFE_U64,
  SOP2Op.S_BFE_I64: _SOP2Op_S_BFE_I64,
  SOP2Op.S_ABSDIFF_I32: _SOP2Op_S_ABSDIFF_I32,
  SOP2Op.S_MUL_HI_U32: _SOP2Op_S_MUL_HI_U32,
  SOP2Op.S_MUL_HI_I32: _SOP2Op_S_MUL_HI_I32,
  SOP2Op.S_LSHL1_ADD_U32: _SOP2Op_S_LSHL1_ADD_U32,
  SOP2Op.S_LSHL2_ADD_U32: _SOP2Op_S_LSHL2_ADD_U32,
  SOP2Op.S_LSHL3_ADD_U32: _SOP2Op_S_LSHL3_ADD_U32,
  SOP2Op.S_LSHL4_ADD_U32: _SOP2Op_S_LSHL4_ADD_U32,
  SOP2Op.S_PACK_LL_B32_B16: _SOP2Op_S_PACK_LL_B32_B16,
  SOP2Op.S_PACK_LH_B32_B16: _SOP2Op_S_PACK_LH_B32_B16,
  SOP2Op.S_PACK_HH_B32_B16: _SOP2Op_S_PACK_HH_B32_B16,
}

def _SOPCOp_S_CMP_EQ_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 == S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 == S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LG_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 <> S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32  !=  S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_GT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 > S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 > S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_GE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 >= S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 >= S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 < S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 < S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 <= S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 <= S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_EQ_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 == S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 == S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LG_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 <> S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32  !=  S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_GT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 > S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 > S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_GE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 >= S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 >= S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 < S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 < S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 <= S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 <= S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_BITCMP0_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32[S1.u32[4 : 0]] == 1'0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32[S1.u32[4 : 0]] == 0)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_BITCMP1_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32[S1.u32[4 : 0]] == 1'1U
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32[S1.u32[4 : 0]] == 1)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_BITCMP0_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u64[S1.u32[5 : 0]] == 1'0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u64[S1.u32[5 : 0]] == 0)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_BITCMP1_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u64[S1.u32[5 : 0]] == 1'1U
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u64[S1.u32[5 : 0]] == 1)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_SETVSKIP(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VSKIP = S0.u32[S1.u32[4 : 0]]
  S0 = Reg(s0)
  S1 = Reg(s1)
  # --- compiled pseudocode ---
  VSKIP = S0.u32[S1.u32[4 : 0]]
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _SOPCOp_S_SET_GPR_IDX_ON(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # specified in the SRC0 operand. The raw bits of the SRC1 field are read and used to set the enable bits. S1[0] =
  # VSRC0_REL, S1[1] = VSRC1_REL, S1[2] = VSRC2_REL and S1[3] = VDST_REL.
  # M0[7 : 0] = S0.u32[7 : 0].b8;
  # // this is the direct content of raw S1 field
  S0 = Reg(s0)
  S1 = Reg(s1)
  SRC0 = Reg(src0_idx)
  VDST = Reg(vdst_idx)
  # --- compiled pseudocode ---
  specified in the SRC0 operand. The raw bits of the SRC1 field are read and used to set the enable bits. S1[0] = 
  VSRC0_REL, S1[1] = VSRC1_REL, S1[2] = VSRC2_REL and S1[3] = VDST_REL.
  M0[7 : 0] = S0.u32[7 : 0].b8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _SOPCOp_S_CMP_EQ_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u64 == S1.u64
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u64 == S1.u64)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LG_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u64 <> S1.u64
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u64  !=  S1.u64)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

SOPCOp_FUNCTIONS = {
  SOPCOp.S_CMP_EQ_I32: _SOPCOp_S_CMP_EQ_I32,
  SOPCOp.S_CMP_LG_I32: _SOPCOp_S_CMP_LG_I32,
  SOPCOp.S_CMP_GT_I32: _SOPCOp_S_CMP_GT_I32,
  SOPCOp.S_CMP_GE_I32: _SOPCOp_S_CMP_GE_I32,
  SOPCOp.S_CMP_LT_I32: _SOPCOp_S_CMP_LT_I32,
  SOPCOp.S_CMP_LE_I32: _SOPCOp_S_CMP_LE_I32,
  SOPCOp.S_CMP_EQ_U32: _SOPCOp_S_CMP_EQ_U32,
  SOPCOp.S_CMP_LG_U32: _SOPCOp_S_CMP_LG_U32,
  SOPCOp.S_CMP_GT_U32: _SOPCOp_S_CMP_GT_U32,
  SOPCOp.S_CMP_GE_U32: _SOPCOp_S_CMP_GE_U32,
  SOPCOp.S_CMP_LT_U32: _SOPCOp_S_CMP_LT_U32,
  SOPCOp.S_CMP_LE_U32: _SOPCOp_S_CMP_LE_U32,
  SOPCOp.S_BITCMP0_B32: _SOPCOp_S_BITCMP0_B32,
  SOPCOp.S_BITCMP1_B32: _SOPCOp_S_BITCMP1_B32,
  SOPCOp.S_BITCMP0_B64: _SOPCOp_S_BITCMP0_B64,
  SOPCOp.S_BITCMP1_B64: _SOPCOp_S_BITCMP1_B64,
  SOPCOp.S_SETVSKIP: _SOPCOp_S_SETVSKIP,
  SOPCOp.S_SET_GPR_IDX_ON: _SOPCOp_S_SET_GPR_IDX_ON,
  SOPCOp.S_CMP_EQ_U64: _SOPCOp_S_CMP_EQ_U64,
  SOPCOp.S_CMP_LG_U64: _SOPCOp_S_CMP_LG_U64,
}

def _SOPKOp_S_MOVK_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(signext(S0.i16))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (signext(S0.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOPKOp_S_CMOVK_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if SCC then
  # D0.i32 = 32'I(signext(S0.i16))
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  if SCC:
    D0.i32 = (signext(S0.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_EQ_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 == 32'I(signext(S1.i16))
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 == (signext(S1.i16)))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_LG_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 != 32'I(signext(S1.i16))
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 != (signext(S1.i16)))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_GT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 > 32'I(signext(S1.i16))
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 > (signext(S1.i16)))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_GE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 >= 32'I(signext(S1.i16))
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 >= (signext(S1.i16)))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_LT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 < 32'I(signext(S1.i16))
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 < (signext(S1.i16)))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_LE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 <= 32'I(signext(S1.i16))
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 <= (signext(S1.i16)))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_EQ_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 == 32'U(S1.u16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 == (S1.u16))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_LG_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 != 32'U(S1.u16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 != (S1.u16))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_GT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 > 32'U(S1.u16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 > (S1.u16))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_GE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 >= 32'U(S1.u16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 >= (S1.u16))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_LT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 < 32'U(S1.u16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 < (S1.u16))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_CMPK_LE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 <= 32'U(S1.u16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 <= (S1.u16))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_ADDK_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.i32;
  # D0.i32 = D0.i32 + 32'I(signext(S0.i16));
  # SCC = ((tmp[31] == S0.i16[15]) && (tmp[31] != D0.i32[31]));
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.i32)
  D0.i32 = D0.i32 + (signext(S0.i16))
  SCC = Reg(((tmp[31] == S0.i16[15])  and  (tmp[31] != D0.i32[31])))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOPKOp_S_MULK_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = D0.i32 * 32'I(signext(S0.i16))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = D0.i32 * (signext(S0.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

SOPKOp_FUNCTIONS = {
  SOPKOp.S_MOVK_I32: _SOPKOp_S_MOVK_I32,
  SOPKOp.S_CMOVK_I32: _SOPKOp_S_CMOVK_I32,
  SOPKOp.S_CMPK_EQ_I32: _SOPKOp_S_CMPK_EQ_I32,
  SOPKOp.S_CMPK_LG_I32: _SOPKOp_S_CMPK_LG_I32,
  SOPKOp.S_CMPK_GT_I32: _SOPKOp_S_CMPK_GT_I32,
  SOPKOp.S_CMPK_GE_I32: _SOPKOp_S_CMPK_GE_I32,
  SOPKOp.S_CMPK_LT_I32: _SOPKOp_S_CMPK_LT_I32,
  SOPKOp.S_CMPK_LE_I32: _SOPKOp_S_CMPK_LE_I32,
  SOPKOp.S_CMPK_EQ_U32: _SOPKOp_S_CMPK_EQ_U32,
  SOPKOp.S_CMPK_LG_U32: _SOPKOp_S_CMPK_LG_U32,
  SOPKOp.S_CMPK_GT_U32: _SOPKOp_S_CMPK_GT_U32,
  SOPKOp.S_CMPK_GE_U32: _SOPKOp_S_CMPK_GE_U32,
  SOPKOp.S_CMPK_LT_U32: _SOPKOp_S_CMPK_LT_U32,
  SOPKOp.S_CMPK_LE_U32: _SOPKOp_S_CMPK_LE_U32,
  SOPKOp.S_ADDK_I32: _SOPKOp_S_ADDK_I32,
  SOPKOp.S_MULK_I32: _SOPKOp_S_MULK_I32,
}

def _SOPPOp_S_NOP(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # for i in 0U : SIMM16.u16[3 : 0].u32 do
  # endfor
  SIMM16 = Reg(literal)
  # --- compiled pseudocode ---
  for i in range(0, int(SIMM16.u16[3 : 0].u32)+1):
    pass
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _SOPPOp_S_TRAP(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // PC passed into trap handler points to S_TRAP itself,
  # // trap base address
  # --- compiled pseudocode ---
  
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _SOPPOp_S_SET_GPR_IDX_MODE(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Get Doorbell ID 10 - Returns doorbell into EXEC, with the doorbell physical address in bits
  EXEC = Reg(exec_mask)
  # --- compiled pseudocode ---
  
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  return result

SOPPOp_FUNCTIONS = {
  SOPPOp.S_NOP: _SOPPOp_S_NOP,
  SOPPOp.S_TRAP: _SOPPOp_S_TRAP,
  SOPPOp.S_SET_GPR_IDX_MODE: _SOPPOp_S_SET_GPR_IDX_MODE,
}

def _VOP1Op_V_MOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b32 = S0.b32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b32 = S0.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_READFIRSTLANE_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare lane : 32'I;
  # if EXEC == 0x0LL then
  # lane = 0;
  # // Force lane 0 if all lanes are disabled
  # else
  # lane = s_ff1_i32_b64(EXEC);
  # // Lowest active lane
  # endif;
  # D0.b32 = VGPR[lane][SRC0.u32]
  D0 = Reg(d0)
  EXEC = Reg(exec_mask)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  if EXEC == 0x0:
    lane = 0
  else:
    lane = s_ff1_i32_b64(EXEC)
  D0.b32 = VGPR[lane][SRC0.u32]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  return result

def _VOP1Op_V_CVT_I32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f64_to_i32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f64_to_i32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F64_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = i32_to_f64(S0.i32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = i32_to_f64(S0.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_CVT_F32_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = i32_to_f32(S0.i32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = i32_to_f32(S0.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0.u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_U32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = f32_to_u32(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = f32_to_u32(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f32_to_i32(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f32_to_i32(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F16_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = f32_to_f16(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = f32_to_f16(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = f16_to_f32(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = f16_to_f32(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_RPI_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f32_to_i32(floor(S0.f32 + 0.5F))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f32_to_i32(floor(S0.f32 + 0.5))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_FLR_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f32_to_i32(floor(S0.f32))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f32_to_i32(floor(S0.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = f64_to_f32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = f64_to_f32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F64_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = f32_to_f64(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = f32_to_f64(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_CVT_F32_UBYTE0(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[7 : 0].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[7 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_UBYTE1(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[15 : 8].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[15 : 8].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_UBYTE2(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[23 : 16].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[23 : 16].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_UBYTE3(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[31 : 24].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[31 : 24].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_U32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = f64_to_u32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = f64_to_u32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F64_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = u32_to_f64(S0.u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = u32_to_f64(S0.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_TRUNC_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_CEIL_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64);
  # if ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then
  # D0.f64 += 1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  if ((S0.f64 > 0.0)  and  (S0.f64 != D0.f64)):
    D0.f64 += 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_RNDNE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = floor(S0.f64 + 0.5);
  # if (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then
  # D0.f64 -= 1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = floor(S0.f64 + 0.5)
  if (isEven(floor(S0.f64))  and  (fract(S0.f64) == 0.5)):
    D0.f64 -= 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_FLOOR_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64);
  # if ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then
  # D0.f64 += -1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  if ((S0.f64 < 0.0)  and  (S0.f64 != D0.f64)):
    D0.f64 += -1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_FRACT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 + -floor(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 + -floor(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_TRUNC_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = trunc(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = trunc(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CEIL_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = trunc(S0.f32);
  # if ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then
  # D0.f32 += 1.0F
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = trunc(S0.f32)
  if ((S0.f32 > 0.0)  and  (S0.f32 != D0.f32)):
    D0.f32 += 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_RNDNE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = floor(S0.f32 + 0.5F);
  # if (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then
  # D0.f32 -= 1.0F
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = floor(S0.f32 + 0.5)
  if (isEven(F(floor(S0.f32)))  and  (fract(S0.f32) == 0.5)):
    D0.f32 -= 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FLOOR_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = trunc(S0.f32);
  # if ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then
  # D0.f32 += -1.0F
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = trunc(S0.f32)
  if ((S0.f32 < 0.0)  and  (S0.f32 != D0.f32)):
    D0.f32 += -1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_EXP_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = pow(2.0F, S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = pow(2.0, S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_LOG_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = log2(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = log2(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_RCP_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 1.0F / S0.f32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = 1.0 / S0.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_RCP_IFLAG_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 1.0F / S0.f32;
  # // Can only raise integer DIV_BY_ZERO exception
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = 1.0 / S0.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_RSQ_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 1.0F / sqrt(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = 1.0 / sqrt(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_RCP_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = 1.0 / S0.f64
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = 1.0 / S0.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_RSQ_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = 1.0 / sqrt(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = 1.0 / sqrt(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_SQRT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = sqrt(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = sqrt(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_SQRT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = sqrt(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = sqrt(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_SIN_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = sin(S0.f32 * 32'F(PI * 2.0))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = sin(S0.f32 * F(PI * 2.0))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_COS_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = cos(S0.f32 * 32'F(PI * 2.0))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = cos(S0.f32 * F(PI * 2.0))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_NOT_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ~S0.u32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ~S0.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_BFREV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32[31 : 0] = S0.u32[0 : 31]
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32[31 : 0] = S0.u32[0 : 31]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FFBH_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = -1;
  # // Set if no ones are found
  # for i in 0 : 31 do
  # // Search from MSB
  # if S0.u32[31 - i] == 1'1U then
  # D0.i32 = i;
  # endif
  # endfor
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = -1
  for i in range(0, int(31)+1):
    if S0.u32[31 - i] == 1:
      D0.i32 = i
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FFBL_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = -1;
  # // Set if no ones are found
  # for i in 0 : 31 do
  # // Search from LSB
  # if S0.u32[i] == 1'1U then
  # D0.i32 = i;
  # endif
  # endfor
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = -1
  for i in range(0, int(31)+1):
    if S0.u32[i] == 1:
      D0.i32 = i
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FFBH_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = -1;
  # // Set if all bits are the same
  # for i in 1 : 31 do
  # // Search from MSB
  # if S0.i32[31 - i] != S0.i32[31] then
  # D0.i32 = i;
  # endif
  # endfor
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = -1
  for i in range(1, int(31)+1):
    if S0.i32[31 - i] != S0.i32[31]:
      D0.i32 = i
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FREXP_EXP_I32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then
  # D0.i32 = 0
  # else
  # D0.i32 = exponent(S0.f64) - 1023 + 1
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((S0.f64 == INF)  or  (S0.f64 == (-INF))  or  isNAN(S0.f64)):
    D0.i32 = 0
  else:
    D0.i32 = exponent(S0.f64) - 1023 + 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FREXP_MANT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then
  # D0.f64 = S0.f64
  # else
  # D0.f64 = mantissa(S0.f64)
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((S0.f64 == INF)  or  (S0.f64 == (-INF))  or  isNAN(S0.f64)):
    D0.f64 = S0.f64
  else:
    D0.f64 = mantissa(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_FRACT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = S0.f64 + -floor(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = S0.f64 + -floor(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_FREXP_EXP_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then
  # D0.i32 = 0
  # else
  # D0.i32 = exponent(S0.f32) - 127 + 1
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((F(S0.f32) == INF)  or  (F(S0.f32) == (-INF))  or  isNAN(F(S0.f32))):
    D0.i32 = 0
  else:
    D0.i32 = exponent(S0.f32) - 127 + 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FREXP_MANT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then
  # D0.f32 = S0.f32
  # else
  # D0.f32 = mantissa(S0.f32)
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((F(S0.f32) == INF)  or  (F(S0.f32) == (-INF))  or  isNAN(F(S0.f32))):
    D0.f32 = S0.f32
  else:
    D0.f32 = mantissa(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_MOV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b64 = S0.b64
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b64 = S0.b64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_CVT_F16_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = u16_to_f16(S0.u16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = u16_to_f16(S0.u16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F16_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = i16_to_f16(S0.i16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = i16_to_f16(S0.i16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_U16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = f16_to_u16(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = f16_to_u16(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_I16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = f16_to_i16(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = f16_to_i16(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_RCP_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = 16'1.0 / S0.f16
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = 1.0 / S0.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_SQRT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = sqrt(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = sqrt(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_RSQ_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = 16'1.0 / sqrt(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = 1.0 / sqrt(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_LOG_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = log2(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = log2(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_EXP_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = pow(16'2.0, S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = pow(2.0, S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FREXP_MANT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then
  # D0.f16 = S0.f16
  # else
  # D0.f16 = mantissa(S0.f16)
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((F(S0.f16) == INF)  or  (F(S0.f16) == (-INF))  or  isNAN(F(S0.f16))):
    D0.f16 = S0.f16
  else:
    D0.f16 = mantissa(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FREXP_EXP_I16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then
  # D0.i16 = 16'0
  # else
  # D0.i16 = 16'I(exponent(S0.f16) - 15 + 1)
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((F(S0.f16) == INF)  or  (F(S0.f16) == (-INF))  or  isNAN(F(S0.f16))):
    D0.i16 = 0
  else:
    D0.i16 = (exponent(S0.f16) - 15 + 1)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FLOOR_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = trunc(S0.f16);
  # if ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then
  # D0.f16 += -16'1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = trunc(S0.f16)
  if ((S0.f16 < 0.0)  and  (S0.f16 != D0.f16)):
    D0.f16 += -1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CEIL_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = trunc(S0.f16);
  # if ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then
  # D0.f16 += 16'1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = trunc(S0.f16)
  if ((S0.f16 > 0.0)  and  (S0.f16 != D0.f16)):
    D0.f16 += 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_TRUNC_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = trunc(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = trunc(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_RNDNE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = floor(S0.f16 + 16'0.5);
  # if (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then
  # D0.f16 -= 16'1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = floor(S0.f16 + 0.5)
  if (isEven(F(floor(S0.f16)))  and  (fract(S0.f16) == 0.5)):
    D0.f16 -= 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_FRACT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 + -floor(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 + -floor(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_SIN_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = sin(S0.f16 * 16'F(PI * 2.0))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = sin(S0.f16 * F(PI * 2.0))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_COS_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = cos(S0.f16 * 16'F(PI * 2.0))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = cos(S0.f16 * F(PI * 2.0))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_NORM_I16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = f16_to_snorm(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = f16_to_snorm(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_NORM_U16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = f16_to_unorm(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = f16_to_unorm(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_SAT_PK_U8_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if n <= 16'0 then
  # elsif n >= 16'255 then
  # else
  # endif);
  # tmp = 16'0;
  # tmp[7 : 0].u8 = SAT8(S0[15 : 0].i16);
  # tmp[15 : 8].u8 = SAT8(S0[31 : 16].i16);
  # D0.b16 = tmp.b16
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  if n <= 0:
    pass
  elif n >= 255:
    pass
  else:
    pass
  tmp = Reg(0)
  tmp[7 : 0].u8 = SAT8(S0[15 : 0].i16)
  tmp[15 : 8].u8 = SAT8(S0[31 : 16].i16)
  D0.b16 = tmp.b16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_SWAP_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.b32;
  # D0.b32 = S0.b32;
  # S0.b32 = tmp
  S0 = Reg(s0)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.b32)
  D0.b32 = S0.b32
  S0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_FP8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if SDWA_SRC0_SEL == BYTE1.b3 then
  # D0.f32 = fp8_to_f32(S0[15 : 8].fp8)
  # elsif SDWA_SRC0_SEL == BYTE2.b3 then
  # D0.f32 = fp8_to_f32(S0[23 : 16].fp8)
  # elsif SDWA_SRC0_SEL == BYTE3.b3 then
  # D0.f32 = fp8_to_f32(S0[31 : 24].fp8)
  # else
  # // BYTE0 implied
  # D0.f32 = fp8_to_f32(S0[7 : 0].fp8)
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  if SDWA_SRC0_SEL == BYTE1.b3:
    D0.f32 = fp8_to_f32(S0[15 : 8].fp8)
  elif SDWA_SRC0_SEL == BYTE2.b3:
    D0.f32 = fp8_to_f32(S0[23 : 16].fp8)
  elif SDWA_SRC0_SEL == BYTE3.b3:
    D0.f32 = fp8_to_f32(S0[31 : 24].fp8)
  else:
    D0.f32 = fp8_to_f32(S0[7 : 0].fp8)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_BF8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if SDWA_SRC0_SEL == BYTE1.b3 then
  # D0.f32 = bf8_to_f32(S0[15 : 8].bf8)
  # elsif SDWA_SRC0_SEL == BYTE2.b3 then
  # D0.f32 = bf8_to_f32(S0[23 : 16].bf8)
  # elsif SDWA_SRC0_SEL == BYTE3.b3 then
  # D0.f32 = bf8_to_f32(S0[31 : 24].bf8)
  # else
  # // BYTE0 implied
  # D0.f32 = bf8_to_f32(S0[7 : 0].bf8)
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  if SDWA_SRC0_SEL == BYTE1.b3:
    D0.f32 = bf8_to_f32(S0[15 : 8].bf8)
  elif SDWA_SRC0_SEL == BYTE2.b3:
    D0.f32 = bf8_to_f32(S0[23 : 16].bf8)
  elif SDWA_SRC0_SEL == BYTE3.b3:
    D0.f32 = bf8_to_f32(S0[31 : 24].bf8)
  else:
    D0.f32 = bf8_to_f32(S0[7 : 0].bf8)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_PK_F32_FP8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = SDWA_SRC0_SEL[1 : 0] == WORD1.b2 ? S0[31 : 16] : S0[15 : 0];
  # D0[31 : 0].f32 = fp8_to_f32(tmp[7 : 0].fp8);
  # D0[63 : 32].f32 = fp8_to_f32(tmp[15 : 8].fp8)
  S0 = Reg(s0)
  D0 = Reg(d0)
  D1 = Reg(0)
  tmp = Reg(0)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  tmp = Reg(((S0[31 : 16]) if (SDWA_SRC0_SEL[1 : 0] == WORD1.b2) else (S0[15 : 0])))
  D0[31 : 0].f32 = fp8_to_f32(tmp[7 : 0].fp8)
  D0[63 : 32].f32 = fp8_to_f32(tmp[15 : 8].fp8)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_PK_F32_BF8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = SDWA_SRC0_SEL[1 : 0] == WORD1.b2 ? S0[31 : 16] : S0[15 : 0];
  # D0[31 : 0].f32 = bf8_to_f32(tmp[7 : 0].bf8);
  # D0[63 : 32].f32 = bf8_to_f32(tmp[15 : 8].bf8)
  S0 = Reg(s0)
  D0 = Reg(d0)
  D1 = Reg(0)
  tmp = Reg(0)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  tmp = Reg(((S0[31 : 16]) if (SDWA_SRC0_SEL[1 : 0] == WORD1.b2) else (S0[15 : 0])))
  D0[31 : 0].f32 = bf8_to_f32(tmp[7 : 0].bf8)
  D0[63 : 32].f32 = bf8_to_f32(tmp[15 : 8].bf8)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_PERMLANE16_SWAP_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # for pass in 0 : 1 do
  # for lane in 0 : 15 do
  # tmp = VGPR[pass * 32 + lane][SRC0.u32];
  # endfor
  # endfor
  tmp = Reg(0)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  for pass in range(0, int(1)+1):
    for lane in range(0, int(15)+1):
      tmp = Reg(VGPR[pass * 32 + lane][SRC0.u32])
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP1Op_V_PERMLANE32_SWAP_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # for lane in 0 : 31 do
  # tmp = VGPR[lane][SRC0.u32];
  # endfor
  tmp = Reg(0)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  for lane in range(0, int(31)+1):
    tmp = Reg(VGPR[lane][SRC0.u32])
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_BF16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 32'F({ S0.b16, 16'0U })
  # V_CMPX_{COMPF}_F16 16-bit float compare. Also writes EXEC. 0x30 to 0x3F
  # V_CMPX_{COMPF}_F32 32-bit float compare. Also writes EXEC. 0x50 to 0x5F
  # V_CMPSX_{COMPF}_F64 64-bit float compare. Also writes EXEC. 0x70 to 0x7F
  # V_CMPX_{COMPI}_I16 16-bit unsigned integer compare. Also writes EXEC. 0xB0 - 0xB7
  # V_CMPX_{COMPI}_U16 16-bit unsigned integer compare. Also writes EXEC. 0xB8 - 0xBF
  # V_CMPX_{COMPI}_I32 32-bit unsigned integer compare. Also writes EXEC. 0xD0 - 0xD7
  # V_CMPX_{COMPI}_U32 32-bit unsigned integer compare. Also writes EXEC. 0xD8 - 0xDF
  # V_CMPX_{COMPI}_I64 64-bit unsigned integer compare. Also writes EXEC. 0xF0 - 0xF7
  # V_CMPX_{COMPI}_U64 64-bit unsigned integer compare. Also writes EXEC. 0xF8 - 0xFF
  S0 = Reg(s0)
  D0 = Reg(d0)
  EXEC = Reg(exec_mask)
  # --- compiled pseudocode ---
  D0.f32 = F(_pack(S0.b16, 0))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  return result

VOP1Op_FUNCTIONS = {
  VOP1Op.V_MOV_B32: _VOP1Op_V_MOV_B32,
  VOP1Op.V_READFIRSTLANE_B32: _VOP1Op_V_READFIRSTLANE_B32,
  VOP1Op.V_CVT_I32_F64: _VOP1Op_V_CVT_I32_F64,
  VOP1Op.V_CVT_F64_I32: _VOP1Op_V_CVT_F64_I32,
  VOP1Op.V_CVT_F32_I32: _VOP1Op_V_CVT_F32_I32,
  VOP1Op.V_CVT_F32_U32: _VOP1Op_V_CVT_F32_U32,
  VOP1Op.V_CVT_U32_F32: _VOP1Op_V_CVT_U32_F32,
  VOP1Op.V_CVT_I32_F32: _VOP1Op_V_CVT_I32_F32,
  VOP1Op.V_CVT_F16_F32: _VOP1Op_V_CVT_F16_F32,
  VOP1Op.V_CVT_F32_F16: _VOP1Op_V_CVT_F32_F16,
  VOP1Op.V_CVT_RPI_I32_F32: _VOP1Op_V_CVT_RPI_I32_F32,
  VOP1Op.V_CVT_FLR_I32_F32: _VOP1Op_V_CVT_FLR_I32_F32,
  VOP1Op.V_CVT_F32_F64: _VOP1Op_V_CVT_F32_F64,
  VOP1Op.V_CVT_F64_F32: _VOP1Op_V_CVT_F64_F32,
  VOP1Op.V_CVT_F32_UBYTE0: _VOP1Op_V_CVT_F32_UBYTE0,
  VOP1Op.V_CVT_F32_UBYTE1: _VOP1Op_V_CVT_F32_UBYTE1,
  VOP1Op.V_CVT_F32_UBYTE2: _VOP1Op_V_CVT_F32_UBYTE2,
  VOP1Op.V_CVT_F32_UBYTE3: _VOP1Op_V_CVT_F32_UBYTE3,
  VOP1Op.V_CVT_U32_F64: _VOP1Op_V_CVT_U32_F64,
  VOP1Op.V_CVT_F64_U32: _VOP1Op_V_CVT_F64_U32,
  VOP1Op.V_TRUNC_F64: _VOP1Op_V_TRUNC_F64,
  VOP1Op.V_CEIL_F64: _VOP1Op_V_CEIL_F64,
  VOP1Op.V_RNDNE_F64: _VOP1Op_V_RNDNE_F64,
  VOP1Op.V_FLOOR_F64: _VOP1Op_V_FLOOR_F64,
  VOP1Op.V_FRACT_F32: _VOP1Op_V_FRACT_F32,
  VOP1Op.V_TRUNC_F32: _VOP1Op_V_TRUNC_F32,
  VOP1Op.V_CEIL_F32: _VOP1Op_V_CEIL_F32,
  VOP1Op.V_RNDNE_F32: _VOP1Op_V_RNDNE_F32,
  VOP1Op.V_FLOOR_F32: _VOP1Op_V_FLOOR_F32,
  VOP1Op.V_EXP_F32: _VOP1Op_V_EXP_F32,
  VOP1Op.V_LOG_F32: _VOP1Op_V_LOG_F32,
  VOP1Op.V_RCP_F32: _VOP1Op_V_RCP_F32,
  VOP1Op.V_RCP_IFLAG_F32: _VOP1Op_V_RCP_IFLAG_F32,
  VOP1Op.V_RSQ_F32: _VOP1Op_V_RSQ_F32,
  VOP1Op.V_RCP_F64: _VOP1Op_V_RCP_F64,
  VOP1Op.V_RSQ_F64: _VOP1Op_V_RSQ_F64,
  VOP1Op.V_SQRT_F32: _VOP1Op_V_SQRT_F32,
  VOP1Op.V_SQRT_F64: _VOP1Op_V_SQRT_F64,
  VOP1Op.V_SIN_F32: _VOP1Op_V_SIN_F32,
  VOP1Op.V_COS_F32: _VOP1Op_V_COS_F32,
  VOP1Op.V_NOT_B32: _VOP1Op_V_NOT_B32,
  VOP1Op.V_BFREV_B32: _VOP1Op_V_BFREV_B32,
  VOP1Op.V_FFBH_U32: _VOP1Op_V_FFBH_U32,
  VOP1Op.V_FFBL_B32: _VOP1Op_V_FFBL_B32,
  VOP1Op.V_FFBH_I32: _VOP1Op_V_FFBH_I32,
  VOP1Op.V_FREXP_EXP_I32_F64: _VOP1Op_V_FREXP_EXP_I32_F64,
  VOP1Op.V_FREXP_MANT_F64: _VOP1Op_V_FREXP_MANT_F64,
  VOP1Op.V_FRACT_F64: _VOP1Op_V_FRACT_F64,
  VOP1Op.V_FREXP_EXP_I32_F32: _VOP1Op_V_FREXP_EXP_I32_F32,
  VOP1Op.V_FREXP_MANT_F32: _VOP1Op_V_FREXP_MANT_F32,
  VOP1Op.V_MOV_B64: _VOP1Op_V_MOV_B64,
  VOP1Op.V_CVT_F16_U16: _VOP1Op_V_CVT_F16_U16,
  VOP1Op.V_CVT_F16_I16: _VOP1Op_V_CVT_F16_I16,
  VOP1Op.V_CVT_U16_F16: _VOP1Op_V_CVT_U16_F16,
  VOP1Op.V_CVT_I16_F16: _VOP1Op_V_CVT_I16_F16,
  VOP1Op.V_RCP_F16: _VOP1Op_V_RCP_F16,
  VOP1Op.V_SQRT_F16: _VOP1Op_V_SQRT_F16,
  VOP1Op.V_RSQ_F16: _VOP1Op_V_RSQ_F16,
  VOP1Op.V_LOG_F16: _VOP1Op_V_LOG_F16,
  VOP1Op.V_EXP_F16: _VOP1Op_V_EXP_F16,
  VOP1Op.V_FREXP_MANT_F16: _VOP1Op_V_FREXP_MANT_F16,
  VOP1Op.V_FREXP_EXP_I16_F16: _VOP1Op_V_FREXP_EXP_I16_F16,
  VOP1Op.V_FLOOR_F16: _VOP1Op_V_FLOOR_F16,
  VOP1Op.V_CEIL_F16: _VOP1Op_V_CEIL_F16,
  VOP1Op.V_TRUNC_F16: _VOP1Op_V_TRUNC_F16,
  VOP1Op.V_RNDNE_F16: _VOP1Op_V_RNDNE_F16,
  VOP1Op.V_FRACT_F16: _VOP1Op_V_FRACT_F16,
  VOP1Op.V_SIN_F16: _VOP1Op_V_SIN_F16,
  VOP1Op.V_COS_F16: _VOP1Op_V_COS_F16,
  VOP1Op.V_CVT_NORM_I16_F16: _VOP1Op_V_CVT_NORM_I16_F16,
  VOP1Op.V_CVT_NORM_U16_F16: _VOP1Op_V_CVT_NORM_U16_F16,
  VOP1Op.V_SAT_PK_U8_I16: _VOP1Op_V_SAT_PK_U8_I16,
  VOP1Op.V_SWAP_B32: _VOP1Op_V_SWAP_B32,
  VOP1Op.V_CVT_F32_FP8: _VOP1Op_V_CVT_F32_FP8,
  VOP1Op.V_CVT_F32_BF8: _VOP1Op_V_CVT_F32_BF8,
  VOP1Op.V_CVT_PK_F32_FP8: _VOP1Op_V_CVT_PK_F32_FP8,
  VOP1Op.V_CVT_PK_F32_BF8: _VOP1Op_V_CVT_PK_F32_BF8,
  VOP1Op.V_PERMLANE16_SWAP_B32: _VOP1Op_V_PERMLANE16_SWAP_B32,
  VOP1Op.V_PERMLANE32_SWAP_B32: _VOP1Op_V_PERMLANE32_SWAP_B32,
  VOP1Op.V_CVT_F32_BF16: _VOP1Op_V_CVT_F32_BF16,
}

def _VOP2Op_V_CNDMASK_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = VCC.u64[laneId] ? S1.u32 : S0.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u32 = ((S1.u32) if (VCC.u64[laneId]) else (S0.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP2Op_V_ADD_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 + S1.f32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 + S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_SUB_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 - S1.f32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 - S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_SUBREV_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S1.f32 - S0.f32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S1.f32 - S0.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_FMAC_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = fma(S0.f64, S1.f64, D0.f64)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = fma(S0.f64, S1.f64, D0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP2Op_V_MUL_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 * S1.f32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 * S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MUL_I32_I24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(S0.i24) * 32'I(S1.i24)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (S0.i24) * (S1.i24)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MUL_HI_I32_I24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I((64'I(S0.i24) * 64'I(S1.i24)) >> 32U)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (((S0.i24) * (S1.i24)) >> 32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MUL_U32_U24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U(S0.u24) * 32'U(S1.u24)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u24) * (S1.u24)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MUL_HI_U32_U24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U((64'U(S0.u24) * 64'U(S1.u24)) >> 32U)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (((S0.u24) * (S1.u24)) >> 32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MIN_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(64'F(S0.f32))) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))
  # elsif (WAVE_MODE.IEEE && isSignalNAN(64'F(S1.f32))) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))
  # elsif isNAN(64'F(S0.f32)) then
  # D0.f32 = S1.f32
  # elsif isNAN(64'F(S1.f32)) then
  # D0.f32 = S0.f32
  # elsif ((64'F(S0.f32) == +0.0) && (64'F(S1.f32) == -0.0)) then
  # D0.f32 = S1.f32
  # elsif ((64'F(S0.f32) == -0.0) && (64'F(S1.f32) == +0.0)) then
  # D0.f32 = S0.f32
  # else
  # D0.f32 = S0.f32 < S1.f32 ? S0.f32 : S1.f32
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(F(S0.f32))):
    D0.f32 = F(cvtToQuietNAN(F(S0.f32)))
  elif (WAVE_MODE.IEEE  and  isSignalNAN(F(S1.f32))):
    D0.f32 = F(cvtToQuietNAN(F(S1.f32)))
  elif isNAN(F(S0.f32)):
    D0.f32 = S1.f32
  elif isNAN(F(S1.f32)):
    D0.f32 = S0.f32
  elif ((F(S0.f32) == +0.0)  and  (F(S1.f32) == -0.0)):
    D0.f32 = S1.f32
  elif ((F(S0.f32) == -0.0)  and  (F(S1.f32) == +0.0)):
    D0.f32 = S0.f32
  else:
    D0.f32 = ((S0.f32) if (S0.f32 < S1.f32) else (S1.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MAX_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(64'F(S0.f32))) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))
  # elsif (WAVE_MODE.IEEE && isSignalNAN(64'F(S1.f32))) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))
  # elsif isNAN(64'F(S0.f32)) then
  # D0.f32 = S1.f32
  # elsif isNAN(64'F(S1.f32)) then
  # D0.f32 = S0.f32
  # elsif ((64'F(S0.f32) == +0.0) && (64'F(S1.f32) == -0.0)) then
  # D0.f32 = S0.f32
  # elsif ((64'F(S0.f32) == -0.0) && (64'F(S1.f32) == +0.0)) then
  # D0.f32 = S1.f32
  # elsif WAVE_MODE.IEEE then
  # D0.f32 = S0.f32 >= S1.f32 ? S0.f32 : S1.f32
  # else
  # D0.f32 = S0.f32 > S1.f32 ? S0.f32 : S1.f32
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(F(S0.f32))):
    D0.f32 = F(cvtToQuietNAN(F(S0.f32)))
  elif (WAVE_MODE.IEEE  and  isSignalNAN(F(S1.f32))):
    D0.f32 = F(cvtToQuietNAN(F(S1.f32)))
  elif isNAN(F(S0.f32)):
    D0.f32 = S1.f32
  elif isNAN(F(S1.f32)):
    D0.f32 = S0.f32
  elif ((F(S0.f32) == +0.0)  and  (F(S1.f32) == -0.0)):
    D0.f32 = S0.f32
  elif ((F(S0.f32) == -0.0)  and  (F(S1.f32) == +0.0)):
    D0.f32 = S1.f32
  elif WAVE_MODE.IEEE:
    D0.f32 = ((S0.f32) if (S0.f32 >= S1.f32) else (S1.f32))
  else:
    D0.f32 = ((S0.f32) if (S0.f32 > S1.f32) else (S1.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MIN_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 < S1.i32 ? S0.i32 : S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = ((S0.i32) if (S0.i32 < S1.i32) else (S1.i32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MAX_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 >= S1.i32 ? S0.i32 : S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = ((S0.i32) if (S0.i32 >= S1.i32) else (S1.i32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MIN_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 < S1.u32 ? S0.u32 : S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32) if (S0.u32 < S1.u32) else (S1.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MAX_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 >= S1.u32 ? S0.u32 : S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32) if (S0.u32 >= S1.u32) else (S1.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_LSHRREV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S1.u32 >> S0[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S1.u32 >> S0[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_ASHRREV_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = (S1.i32 >> S0[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (S1.i32 >> S0[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_LSHLREV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S1.u32 << S0[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S1.u32 << S0[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_AND_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 & S1.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 & S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_OR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 | S1.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 | S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_XOR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 ^ S1.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 ^ S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_FMAMK_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = fma(S0.f32, SIMM32.f32, S1.f32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SIMM32 = Reg(literal)
  # --- compiled pseudocode ---
  D0.f32 = fma(S0.f32, SIMM32.f32, S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_FMAAK_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SIMM32 = Reg(literal)
  # --- compiled pseudocode ---
  D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_ADD_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 64'U(S0.u32) + 64'U(S1.u32);
  # VCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_ADDC_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg((S0.u32) + (S1.u32))
  VCC.u64[laneId] = ((1) if (tmp >= 0x100000000) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP2Op_V_SUB_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32 - S1.u32;
  # VCC.u64[laneId] = S1.u32 > S0.u32 ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_SUBB_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32 - S1.u32)
  VCC.u64[laneId] = ((1) if (S1.u32 > S0.u32) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP2Op_V_SUBREV_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S1.u32 - S0.u32;
  # VCC.u64[laneId] = S0.u32 > S1.u32 ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_SUBB_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg(S1.u32 - S0.u32)
  VCC.u64[laneId] = ((1) if (S0.u32 > S1.u32) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP2Op_V_ADDC_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 64'U(S0.u32) + 64'U(S1.u32) + VCC.u64[laneId].u64;
  # VCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_ADDC_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg((S0.u32) + (S1.u32) + VCC.u64[laneId])
  VCC.u64[laneId] = ((1) if (tmp >= 0x100000000) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP2Op_V_SUBB_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32 - S1.u32 - VCC.u64[laneId].u32;
  # VCC.u64[laneId] = 64'U(S1.u32) + VCC.u64[laneId].u64 > 64'U(S0.u32) ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_SUBB_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32 - S1.u32 - VCC.u64[laneId])
  VCC.u64[laneId] = ((1) if ((S1.u32) + VCC.u64[laneId] > (S0.u32)) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP2Op_V_SUBBREV_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S1.u32 - S0.u32 - VCC.u64[laneId].u32;
  # VCC.u64[laneId] = 64'U(S0.u32) + VCC.u64[laneId].u64 > 64'U(S1.u32) ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_SUBB_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg(S1.u32 - S0.u32 - VCC.u64[laneId])
  VCC.u64[laneId] = ((1) if ((S0.u32) + VCC.u64[laneId] > (S1.u32)) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP2Op_V_ADD_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 + S1.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 + S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_SUB_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 - S1.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 - S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_SUBREV_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S1.f16 - S0.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S1.f16 - S0.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MUL_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 * S1.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 * S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MAC_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.f16 * S1.f16 + D0.f16;
  # if OPSEL.u4[3] then
  # D0 = { tmp.f16, D0[15 : 0] }
  # else
  # D0 = { 16'0, tmp.f16 }
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.f16 * S1.f16 + D0.f16)
  if OPSEL.u4[3]:
    D0 = Reg(_pack(tmp.f16, D0[15 : 0]))
  else:
    D0 = Reg(_pack(0, tmp.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MADMK_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.f16 * SIMM16.f16 + S1.f16;
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  SIMM16 = Reg(literal)
  # --- compiled pseudocode ---
  tmp = Reg(S0.f16 * SIMM16.f16 + S1.f16)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP2Op_V_MADAK_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.f16 * S1.f16 + SIMM16.f16;
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  SIMM16 = Reg(literal)
  # --- compiled pseudocode ---
  tmp = Reg(S0.f16 * S1.f16 + SIMM16.f16)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP2Op_V_ADD_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 + S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S0.u16 + S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_SUB_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 - S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S0.u16 - S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_SUBREV_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S1.u16 - S0.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S1.u16 - S0.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MUL_LO_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 * S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S0.u16 * S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_LSHLREV_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = (S1.u16 << S0[3 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = (S1.u16 << S0[3 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_LSHRREV_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = (S1.u16 >> S0[3 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = (S1.u16 >> S0[3 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_ASHRREV_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = (S1.i16 >> S0[3 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = (S1.i16 >> S0[3 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MAX_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(64'F(S0.f16))) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))
  # elsif (WAVE_MODE.IEEE && isSignalNAN(64'F(S1.f16))) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))
  # elsif isNAN(64'F(S0.f16)) then
  # D0.f16 = S1.f16
  # elsif isNAN(64'F(S1.f16)) then
  # D0.f16 = S0.f16
  # elsif ((64'F(S0.f16) == +0.0) && (64'F(S1.f16) == -0.0)) then
  # D0.f16 = S0.f16
  # elsif ((64'F(S0.f16) == -0.0) && (64'F(S1.f16) == +0.0)) then
  # D0.f16 = S1.f16
  # elsif WAVE_MODE.IEEE then
  # D0.f16 = S0.f16 >= S1.f16 ? S0.f16 : S1.f16
  # else
  # D0.f16 = S0.f16 > S1.f16 ? S0.f16 : S1.f16
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(F(S0.f16))):
    D0.f16 = F(cvtToQuietNAN(F(S0.f16)))
  elif (WAVE_MODE.IEEE  and  isSignalNAN(F(S1.f16))):
    D0.f16 = F(cvtToQuietNAN(F(S1.f16)))
  elif isNAN(F(S0.f16)):
    D0.f16 = S1.f16
  elif isNAN(F(S1.f16)):
    D0.f16 = S0.f16
  elif ((F(S0.f16) == +0.0)  and  (F(S1.f16) == -0.0)):
    D0.f16 = S0.f16
  elif ((F(S0.f16) == -0.0)  and  (F(S1.f16) == +0.0)):
    D0.f16 = S1.f16
  elif WAVE_MODE.IEEE:
    D0.f16 = ((S0.f16) if (S0.f16 >= S1.f16) else (S1.f16))
  else:
    D0.f16 = ((S0.f16) if (S0.f16 > S1.f16) else (S1.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MIN_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(64'F(S0.f16))) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))
  # elsif (WAVE_MODE.IEEE && isSignalNAN(64'F(S1.f16))) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))
  # elsif isNAN(64'F(S0.f16)) then
  # D0.f16 = S1.f16
  # elsif isNAN(64'F(S1.f16)) then
  # D0.f16 = S0.f16
  # elsif ((64'F(S0.f16) == +0.0) && (64'F(S1.f16) == -0.0)) then
  # D0.f16 = S1.f16
  # elsif ((64'F(S0.f16) == -0.0) && (64'F(S1.f16) == +0.0)) then
  # D0.f16 = S0.f16
  # else
  # D0.f16 = S0.f16 < S1.f16 ? S0.f16 : S1.f16
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(F(S0.f16))):
    D0.f16 = F(cvtToQuietNAN(F(S0.f16)))
  elif (WAVE_MODE.IEEE  and  isSignalNAN(F(S1.f16))):
    D0.f16 = F(cvtToQuietNAN(F(S1.f16)))
  elif isNAN(F(S0.f16)):
    D0.f16 = S1.f16
  elif isNAN(F(S1.f16)):
    D0.f16 = S0.f16
  elif ((F(S0.f16) == +0.0)  and  (F(S1.f16) == -0.0)):
    D0.f16 = S1.f16
  elif ((F(S0.f16) == -0.0)  and  (F(S1.f16) == +0.0)):
    D0.f16 = S0.f16
  else:
    D0.f16 = ((S0.f16) if (S0.f16 < S1.f16) else (S1.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MAX_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 >= S1.u16 ? S0.u16 : S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = ((S0.u16) if (S0.u16 >= S1.u16) else (S1.u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MAX_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = S0.i16 >= S1.i16 ? S0.i16 : S1.i16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = ((S0.i16) if (S0.i16 >= S1.i16) else (S1.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MIN_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 < S1.u16 ? S0.u16 : S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = ((S0.u16) if (S0.u16 < S1.u16) else (S1.u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_MIN_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = S0.i16 < S1.i16 ? S0.i16 : S1.i16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = ((S0.i16) if (S0.i16 < S1.i16) else (S1.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_LDEXP_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 * 16'F(2.0F ** 32'I(S1.i16))
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 * F(2.0 ** (S1.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 + S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = S0.u32 + S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_SUB_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 - S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = S0.u32 - S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_SUBREV_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S1.u32 - S0.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = S1.u32 - S0.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_DOT2C_F32_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.f32;
  # tmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16);
  # tmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16);
  # D0.f32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.f32)
  tmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16)
  tmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16)
  D0.f32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_DOT2C_I32_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.i32;
  # tmp += i16_to_i32(S0[15 : 0].i16) * i16_to_i32(S1[15 : 0].i16);
  # tmp += i16_to_i32(S0[31 : 16].i16) * i16_to_i32(S1[31 : 16].i16);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.i32)
  tmp += i16_to_i32(S0[15 : 0].i16) * i16_to_i32(S1[15 : 0].i16)
  tmp += i16_to_i32(S0[31 : 16].i16) * i16_to_i32(S1[31 : 16].i16)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_DOT4C_I32_I8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.i32;
  # tmp += i8_to_i32(S0[7 : 0].i8) * i8_to_i32(S1[7 : 0].i8);
  # tmp += i8_to_i32(S0[15 : 8].i8) * i8_to_i32(S1[15 : 8].i8);
  # tmp += i8_to_i32(S0[23 : 16].i8) * i8_to_i32(S1[23 : 16].i8);
  # tmp += i8_to_i32(S0[31 : 24].i8) * i8_to_i32(S1[31 : 24].i8);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.i32)
  tmp += i8_to_i32(S0[7 : 0].i8) * i8_to_i32(S1[7 : 0].i8)
  tmp += i8_to_i32(S0[15 : 8].i8) * i8_to_i32(S1[15 : 8].i8)
  tmp += i8_to_i32(S0[23 : 16].i8) * i8_to_i32(S1[23 : 16].i8)
  tmp += i8_to_i32(S0[31 : 24].i8) * i8_to_i32(S1[31 : 24].i8)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_DOT8C_I32_I4(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.i32;
  # tmp += i4_to_i32(S0[3 : 0].i4) * i4_to_i32(S1[3 : 0].i4);
  # tmp += i4_to_i32(S0[7 : 4].i4) * i4_to_i32(S1[7 : 4].i4);
  # tmp += i4_to_i32(S0[11 : 8].i4) * i4_to_i32(S1[11 : 8].i4);
  # tmp += i4_to_i32(S0[15 : 12].i4) * i4_to_i32(S1[15 : 12].i4);
  # tmp += i4_to_i32(S0[19 : 16].i4) * i4_to_i32(S1[19 : 16].i4);
  # tmp += i4_to_i32(S0[23 : 20].i4) * i4_to_i32(S1[23 : 20].i4);
  # tmp += i4_to_i32(S0[27 : 24].i4) * i4_to_i32(S1[27 : 24].i4);
  # tmp += i4_to_i32(S0[31 : 28].i4) * i4_to_i32(S1[31 : 28].i4);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.i32)
  tmp += i4_to_i32(S0[3 : 0].i4) * i4_to_i32(S1[3 : 0].i4)
  tmp += i4_to_i32(S0[7 : 4].i4) * i4_to_i32(S1[7 : 4].i4)
  tmp += i4_to_i32(S0[11 : 8].i4) * i4_to_i32(S1[11 : 8].i4)
  tmp += i4_to_i32(S0[15 : 12].i4) * i4_to_i32(S1[15 : 12].i4)
  tmp += i4_to_i32(S0[19 : 16].i4) * i4_to_i32(S1[19 : 16].i4)
  tmp += i4_to_i32(S0[23 : 20].i4) * i4_to_i32(S1[23 : 20].i4)
  tmp += i4_to_i32(S0[27 : 24].i4) * i4_to_i32(S1[27 : 24].i4)
  tmp += i4_to_i32(S0[31 : 28].i4) * i4_to_i32(S1[31 : 28].i4)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_FMAC_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = fma(S0.f32, S1.f32, D0.f32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = fma(S0.f32, S1.f32, D0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_PK_FMAC_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16);
  # D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16)
  D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP2Op_V_XNOR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ~(S0.u32 ^ S1.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ~(S0.u32 ^ S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

VOP2Op_FUNCTIONS = {
  VOP2Op.V_CNDMASK_B32: _VOP2Op_V_CNDMASK_B32,
  VOP2Op.V_ADD_F32: _VOP2Op_V_ADD_F32,
  VOP2Op.V_SUB_F32: _VOP2Op_V_SUB_F32,
  VOP2Op.V_SUBREV_F32: _VOP2Op_V_SUBREV_F32,
  VOP2Op.V_FMAC_F64: _VOP2Op_V_FMAC_F64,
  VOP2Op.V_MUL_F32: _VOP2Op_V_MUL_F32,
  VOP2Op.V_MUL_I32_I24: _VOP2Op_V_MUL_I32_I24,
  VOP2Op.V_MUL_HI_I32_I24: _VOP2Op_V_MUL_HI_I32_I24,
  VOP2Op.V_MUL_U32_U24: _VOP2Op_V_MUL_U32_U24,
  VOP2Op.V_MUL_HI_U32_U24: _VOP2Op_V_MUL_HI_U32_U24,
  VOP2Op.V_MIN_F32: _VOP2Op_V_MIN_F32,
  VOP2Op.V_MAX_F32: _VOP2Op_V_MAX_F32,
  VOP2Op.V_MIN_I32: _VOP2Op_V_MIN_I32,
  VOP2Op.V_MAX_I32: _VOP2Op_V_MAX_I32,
  VOP2Op.V_MIN_U32: _VOP2Op_V_MIN_U32,
  VOP2Op.V_MAX_U32: _VOP2Op_V_MAX_U32,
  VOP2Op.V_LSHRREV_B32: _VOP2Op_V_LSHRREV_B32,
  VOP2Op.V_ASHRREV_I32: _VOP2Op_V_ASHRREV_I32,
  VOP2Op.V_LSHLREV_B32: _VOP2Op_V_LSHLREV_B32,
  VOP2Op.V_AND_B32: _VOP2Op_V_AND_B32,
  VOP2Op.V_OR_B32: _VOP2Op_V_OR_B32,
  VOP2Op.V_XOR_B32: _VOP2Op_V_XOR_B32,
  VOP2Op.V_FMAMK_F32: _VOP2Op_V_FMAMK_F32,
  VOP2Op.V_FMAAK_F32: _VOP2Op_V_FMAAK_F32,
  VOP2Op.V_ADD_CO_U32: _VOP2Op_V_ADD_CO_U32,
  VOP2Op.V_SUB_CO_U32: _VOP2Op_V_SUB_CO_U32,
  VOP2Op.V_SUBREV_CO_U32: _VOP2Op_V_SUBREV_CO_U32,
  VOP2Op.V_ADDC_CO_U32: _VOP2Op_V_ADDC_CO_U32,
  VOP2Op.V_SUBB_CO_U32: _VOP2Op_V_SUBB_CO_U32,
  VOP2Op.V_SUBBREV_CO_U32: _VOP2Op_V_SUBBREV_CO_U32,
  VOP2Op.V_ADD_F16: _VOP2Op_V_ADD_F16,
  VOP2Op.V_SUB_F16: _VOP2Op_V_SUB_F16,
  VOP2Op.V_SUBREV_F16: _VOP2Op_V_SUBREV_F16,
  VOP2Op.V_MUL_F16: _VOP2Op_V_MUL_F16,
  VOP2Op.V_MAC_F16: _VOP2Op_V_MAC_F16,
  VOP2Op.V_MADMK_F16: _VOP2Op_V_MADMK_F16,
  VOP2Op.V_MADAK_F16: _VOP2Op_V_MADAK_F16,
  VOP2Op.V_ADD_U16: _VOP2Op_V_ADD_U16,
  VOP2Op.V_SUB_U16: _VOP2Op_V_SUB_U16,
  VOP2Op.V_SUBREV_U16: _VOP2Op_V_SUBREV_U16,
  VOP2Op.V_MUL_LO_U16: _VOP2Op_V_MUL_LO_U16,
  VOP2Op.V_LSHLREV_B16: _VOP2Op_V_LSHLREV_B16,
  VOP2Op.V_LSHRREV_B16: _VOP2Op_V_LSHRREV_B16,
  VOP2Op.V_ASHRREV_I16: _VOP2Op_V_ASHRREV_I16,
  VOP2Op.V_MAX_F16: _VOP2Op_V_MAX_F16,
  VOP2Op.V_MIN_F16: _VOP2Op_V_MIN_F16,
  VOP2Op.V_MAX_U16: _VOP2Op_V_MAX_U16,
  VOP2Op.V_MAX_I16: _VOP2Op_V_MAX_I16,
  VOP2Op.V_MIN_U16: _VOP2Op_V_MIN_U16,
  VOP2Op.V_MIN_I16: _VOP2Op_V_MIN_I16,
  VOP2Op.V_LDEXP_F16: _VOP2Op_V_LDEXP_F16,
  VOP2Op.V_ADD_U32: _VOP2Op_V_ADD_U32,
  VOP2Op.V_SUB_U32: _VOP2Op_V_SUB_U32,
  VOP2Op.V_SUBREV_U32: _VOP2Op_V_SUBREV_U32,
  VOP2Op.V_DOT2C_F32_F16: _VOP2Op_V_DOT2C_F32_F16,
  VOP2Op.V_DOT2C_I32_I16: _VOP2Op_V_DOT2C_I32_I16,
  VOP2Op.V_DOT4C_I32_I8: _VOP2Op_V_DOT4C_I32_I8,
  VOP2Op.V_DOT8C_I32_I4: _VOP2Op_V_DOT8C_I32_I4,
  VOP2Op.V_FMAC_F32: _VOP2Op_V_FMAC_F32,
  VOP2Op.V_PK_FMAC_F16: _VOP2Op_V_PK_FMAC_F16,
  VOP2Op.V_XNOR_B32: _VOP2Op_V_XNOR_B32,
}

def _VOP3POp_V_PK_MAD_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 * S1[15 : 0].i16 + S2[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 * S1[31 : 16].i16 + S2[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = S0[15 : 0].i16 * S1[15 : 0].i16 + S2[15 : 0].i16
  tmp[31 : 16].i16 = S0[31 : 16].i16 * S1[31 : 16].i16 + S2[31 : 16].i16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MUL_LO_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16;
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16
  tmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_ADD_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 + S1[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 + S1[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = S0[15 : 0].i16 + S1[15 : 0].i16
  tmp[31 : 16].i16 = S0[31 : 16].i16 + S1[31 : 16].i16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_SUB_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 - S1[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 - S1[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = S0[15 : 0].i16 - S1[15 : 0].i16
  tmp[31 : 16].i16 = S0[31 : 16].i16 - S1[31 : 16].i16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_LSHLREV_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].u16 = (S1[31 : 16].u16 << S0.u32[19 : 16].u32);
  # tmp[15 : 0].u16 = (S1[15 : 0].u16 << S0.u32[3 : 0].u32);
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].u16 = (S1[31 : 16].u16 << S0.u32[19 : 16].u32)
  tmp[15 : 0].u16 = (S1[15 : 0].u16 << S0.u32[3 : 0].u32)
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_LSHRREV_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].u16 = (S1[31 : 16].u16 >> S0.u32[19 : 16].u32);
  # tmp[15 : 0].u16 = (S1[15 : 0].u16 >> S0.u32[3 : 0].u32);
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].u16 = (S1[31 : 16].u16 >> S0.u32[19 : 16].u32)
  tmp[15 : 0].u16 = (S1[15 : 0].u16 >> S0.u32[3 : 0].u32)
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_ASHRREV_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].i16 = (S1[31 : 16].i16 >> S0.u32[19 : 16].u32);
  # tmp[15 : 0].i16 = (S1[15 : 0].i16 >> S0.u32[3 : 0].u32);
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].i16 = (S1[31 : 16].i16 >> S0.u32[19 : 16].u32)
  tmp[15 : 0].i16 = (S1[15 : 0].i16 >> S0.u32[3 : 0].u32)
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAX_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 >= S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 >= S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = ((S0[15 : 0].i16) if (S0[15 : 0].i16 >= S1[15 : 0].i16) else (S1[15 : 0].i16))
  tmp[31 : 16].i16 = ((S0[31 : 16].i16) if (S0[31 : 16].i16 >= S1[31 : 16].i16) else (S1[31 : 16].i16))
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MIN_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 < S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 < S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = ((S0[15 : 0].i16) if (S0[15 : 0].i16 < S1[15 : 0].i16) else (S1[15 : 0].i16))
  tmp[31 : 16].i16 = ((S0[31 : 16].i16) if (S0[31 : 16].i16 < S1[31 : 16].i16) else (S1[31 : 16].i16))
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAD_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16 + S2[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16 + S2[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16 + S2[15 : 0].u16
  tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16 + S2[31 : 16].u16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_ADD_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 + S1[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 + S1[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = S0[15 : 0].u16 + S1[15 : 0].u16
  tmp[31 : 16].u16 = S0[31 : 16].u16 + S1[31 : 16].u16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_SUB_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 - S1[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 - S1[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = S0[15 : 0].u16 - S1[15 : 0].u16
  tmp[31 : 16].u16 = S0[31 : 16].u16 - S1[31 : 16].u16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAX_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 >= S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 >= S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = ((S0[15 : 0].u16) if (S0[15 : 0].u16 >= S1[15 : 0].u16) else (S1[15 : 0].u16))
  tmp[31 : 16].u16 = ((S0[31 : 16].u16) if (S0[31 : 16].u16 >= S1[31 : 16].u16) else (S1[31 : 16].u16))
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MIN_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 < S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 < S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = ((S0[15 : 0].u16) if (S0[15 : 0].u16 < S1[15 : 0].u16) else (S1[15 : 0].u16))
  tmp[31 : 16].u16 = ((S0[31 : 16].u16) if (S0[31 : 16].u16 < S1[31 : 16].u16) else (S1[31 : 16].u16))
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_FMA_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16);
  # tmp[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16);
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16)
  tmp[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16)
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_ADD_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = S0[15 : 0].f16 + S1[15 : 0].f16;
  # tmp[31 : 16].f16 = S0[31 : 16].f16 + S1[31 : 16].f16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = S0[15 : 0].f16 + S1[15 : 0].f16
  tmp[31 : 16].f16 = S0[31 : 16].f16 + S1[31 : 16].f16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MUL_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = S0[15 : 0].f16 * S1[15 : 0].f16;
  # tmp[31 : 16].f16 = S0[31 : 16].f16 * S1[31 : 16].f16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = S0[15 : 0].f16 * S1[15 : 0].f16
  tmp[31 : 16].f16 = S0[31 : 16].f16 * S1[31 : 16].f16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MIN_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = v_min_f16(S0[15 : 0].f16, S1[15 : 0].f16);
  # tmp[31 : 16].f16 = v_min_f16(S0[31 : 16].f16, S1[31 : 16].f16);
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = v_min_f16(S0[15 : 0].f16, S1[15 : 0].f16)
  tmp[31 : 16].f16 = v_min_f16(S0[31 : 16].f16, S1[31 : 16].f16)
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAX_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = v_max_f16(S0[15 : 0].f16, S1[15 : 0].f16);
  # tmp[31 : 16].f16 = v_max_f16(S0[31 : 16].f16, S1[31 : 16].f16);
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = v_max_f16(S0[15 : 0].f16, S1[15 : 0].f16)
  tmp[31 : 16].f16 = v_max_f16(S0[31 : 16].f16, S1[31 : 16].f16)
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MINIMUM3_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].f16 = 16'F(v_minimum3_f16(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16));
  # tmp[15 : 0].f16 = 16'F(v_minimum3_f16(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16));
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].f16 = F(v_minimum3_f16(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16))
  tmp[15 : 0].f16 = F(v_minimum3_f16(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16))
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAXIMUM3_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].f16 = 16'F(v_maximum3_f16(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16));
  # tmp[15 : 0].f16 = 16'F(v_maximum3_f16(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16));
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].f16 = F(v_maximum3_f16(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16))
  tmp[15 : 0].f16 = F(v_maximum3_f16(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16))
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_DOT2_F32_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S2.f32;
  # tmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16);
  # tmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16);
  # D0.f32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.f32)
  tmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16)
  tmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16)
  D0.f32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_DOT2_I32_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S2.i32;
  # tmp += i16_to_i32(S0[15 : 0].i16) * i16_to_i32(S1[15 : 0].i16);
  # tmp += i16_to_i32(S0[31 : 16].i16) * i16_to_i32(S1[31 : 16].i16);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.i32)
  tmp += i16_to_i32(S0[15 : 0].i16) * i16_to_i32(S1[15 : 0].i16)
  tmp += i16_to_i32(S0[31 : 16].i16) * i16_to_i32(S1[31 : 16].i16)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_DOT2_U32_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S2.u32;
  # tmp += u16_to_u32(S0[15 : 0].u16) * u16_to_u32(S1[15 : 0].u16);
  # tmp += u16_to_u32(S0[31 : 16].u16) * u16_to_u32(S1[31 : 16].u16);
  # D0.u32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.u32)
  tmp += u16_to_u32(S0[15 : 0].u16) * u16_to_u32(S1[15 : 0].u16)
  tmp += u16_to_u32(S0[31 : 16].u16) * u16_to_u32(S1[31 : 16].u16)
  D0.u32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_DOT4_I32_I8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S2.i32;
  # tmp += i8_to_i32(S0[7 : 0].i8) * i8_to_i32(S1[7 : 0].i8);
  # tmp += i8_to_i32(S0[15 : 8].i8) * i8_to_i32(S1[15 : 8].i8);
  # tmp += i8_to_i32(S0[23 : 16].i8) * i8_to_i32(S1[23 : 16].i8);
  # tmp += i8_to_i32(S0[31 : 24].i8) * i8_to_i32(S1[31 : 24].i8);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.i32)
  tmp += i8_to_i32(S0[7 : 0].i8) * i8_to_i32(S1[7 : 0].i8)
  tmp += i8_to_i32(S0[15 : 8].i8) * i8_to_i32(S1[15 : 8].i8)
  tmp += i8_to_i32(S0[23 : 16].i8) * i8_to_i32(S1[23 : 16].i8)
  tmp += i8_to_i32(S0[31 : 24].i8) * i8_to_i32(S1[31 : 24].i8)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_DOT4_U32_U8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S2.u32;
  # tmp += u8_to_u32(S0[7 : 0].u8) * u8_to_u32(S1[7 : 0].u8);
  # tmp += u8_to_u32(S0[15 : 8].u8) * u8_to_u32(S1[15 : 8].u8);
  # tmp += u8_to_u32(S0[23 : 16].u8) * u8_to_u32(S1[23 : 16].u8);
  # tmp += u8_to_u32(S0[31 : 24].u8) * u8_to_u32(S1[31 : 24].u8);
  # D0.u32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.u32)
  tmp += u8_to_u32(S0[7 : 0].u8) * u8_to_u32(S1[7 : 0].u8)
  tmp += u8_to_u32(S0[15 : 8].u8) * u8_to_u32(S1[15 : 8].u8)
  tmp += u8_to_u32(S0[23 : 16].u8) * u8_to_u32(S1[23 : 16].u8)
  tmp += u8_to_u32(S0[31 : 24].u8) * u8_to_u32(S1[31 : 24].u8)
  D0.u32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_DOT8_I32_I4(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S2.i32;
  # tmp += i4_to_i32(S0[3 : 0].i4) * i4_to_i32(S1[3 : 0].i4);
  # tmp += i4_to_i32(S0[7 : 4].i4) * i4_to_i32(S1[7 : 4].i4);
  # tmp += i4_to_i32(S0[11 : 8].i4) * i4_to_i32(S1[11 : 8].i4);
  # tmp += i4_to_i32(S0[15 : 12].i4) * i4_to_i32(S1[15 : 12].i4);
  # tmp += i4_to_i32(S0[19 : 16].i4) * i4_to_i32(S1[19 : 16].i4);
  # tmp += i4_to_i32(S0[23 : 20].i4) * i4_to_i32(S1[23 : 20].i4);
  # tmp += i4_to_i32(S0[27 : 24].i4) * i4_to_i32(S1[27 : 24].i4);
  # tmp += i4_to_i32(S0[31 : 28].i4) * i4_to_i32(S1[31 : 28].i4);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.i32)
  tmp += i4_to_i32(S0[3 : 0].i4) * i4_to_i32(S1[3 : 0].i4)
  tmp += i4_to_i32(S0[7 : 4].i4) * i4_to_i32(S1[7 : 4].i4)
  tmp += i4_to_i32(S0[11 : 8].i4) * i4_to_i32(S1[11 : 8].i4)
  tmp += i4_to_i32(S0[15 : 12].i4) * i4_to_i32(S1[15 : 12].i4)
  tmp += i4_to_i32(S0[19 : 16].i4) * i4_to_i32(S1[19 : 16].i4)
  tmp += i4_to_i32(S0[23 : 20].i4) * i4_to_i32(S1[23 : 20].i4)
  tmp += i4_to_i32(S0[27 : 24].i4) * i4_to_i32(S1[27 : 24].i4)
  tmp += i4_to_i32(S0[31 : 28].i4) * i4_to_i32(S1[31 : 28].i4)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_DOT8_U32_U4(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S2.u32;
  # tmp += u4_to_u32(S0[3 : 0].u4) * u4_to_u32(S1[3 : 0].u4);
  # tmp += u4_to_u32(S0[7 : 4].u4) * u4_to_u32(S1[7 : 4].u4);
  # tmp += u4_to_u32(S0[11 : 8].u4) * u4_to_u32(S1[11 : 8].u4);
  # tmp += u4_to_u32(S0[15 : 12].u4) * u4_to_u32(S1[15 : 12].u4);
  # tmp += u4_to_u32(S0[19 : 16].u4) * u4_to_u32(S1[19 : 16].u4);
  # tmp += u4_to_u32(S0[23 : 20].u4) * u4_to_u32(S1[23 : 20].u4);
  # tmp += u4_to_u32(S0[27 : 24].u4) * u4_to_u32(S1[27 : 24].u4);
  # tmp += u4_to_u32(S0[31 : 28].u4) * u4_to_u32(S1[31 : 28].u4);
  # D0.u32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.u32)
  tmp += u4_to_u32(S0[3 : 0].u4) * u4_to_u32(S1[3 : 0].u4)
  tmp += u4_to_u32(S0[7 : 4].u4) * u4_to_u32(S1[7 : 4].u4)
  tmp += u4_to_u32(S0[11 : 8].u4) * u4_to_u32(S1[11 : 8].u4)
  tmp += u4_to_u32(S0[15 : 12].u4) * u4_to_u32(S1[15 : 12].u4)
  tmp += u4_to_u32(S0[19 : 16].u4) * u4_to_u32(S1[19 : 16].u4)
  tmp += u4_to_u32(S0[23 : 20].u4) * u4_to_u32(S1[23 : 20].u4)
  tmp += u4_to_u32(S0[27 : 24].u4) * u4_to_u32(S1[27 : 24].u4)
  tmp += u4_to_u32(S0[31 : 28].u4) * u4_to_u32(S1[31 : 28].u4)
  D0.u32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_FMA_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 64'B;
  # tmp[31 : 0].f32 = fma(S0[31 : 0].f32, S1[31 : 0].f32, S2[31 : 0].f32);
  # tmp[63 : 32].f32 = fma(S0[63 : 32].f32, S1[63 : 32].f32, S2[63 : 32].f32);
  # D0.b64 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 0].f32 = fma(S0[31 : 0].f32, S1[31 : 0].f32, S2[31 : 0].f32)
  tmp[63 : 32].f32 = fma(S0[63 : 32].f32, S1[63 : 32].f32, S2[63 : 32].f32)
  D0.b64 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3POp_V_PK_MUL_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 64'B;
  # tmp[31 : 0].f32 = S0[31 : 0].f32 * S1[31 : 0].f32;
  # tmp[63 : 32].f32 = S0[63 : 32].f32 * S1[63 : 32].f32;
  # D0.b64 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 0].f32 = S0[31 : 0].f32 * S1[31 : 0].f32
  tmp[63 : 32].f32 = S0[63 : 32].f32 * S1[63 : 32].f32
  D0.b64 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3POp_V_PK_ADD_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 64'B;
  # tmp[31 : 0].f32 = S0[31 : 0].f32 + S1[31 : 0].f32;
  # tmp[63 : 32].f32 = S0[63 : 32].f32 + S1[63 : 32].f32;
  # D0.b64 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 0].f32 = S0[31 : 0].f32 + S1[31 : 0].f32
  tmp[63 : 32].f32 = S0[63 : 32].f32 + S1[63 : 32].f32
  D0.b64 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3POp_V_PK_MOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp0.u32 = S0.u32[OPSEL[0].i32 * 32 + 31 : OPSEL[0].i32 * 32];
  # tmp1.u32 = S1.u32[OPSEL[1].i32 * 32 + 31 : OPSEL[1].i32 * 32];
  # D0.u32[31 : 0] = tmp0.u32;
  # D0.u32[63 : 32] = tmp1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp0.u32 = S0.u32[OPSEL[0].i32 * 32 + 31 : OPSEL[0].i32 * 32]
  tmp1.u32 = S1.u32[OPSEL[1].i32 * 32 + 31 : OPSEL[1].i32 * 32]
  D0.u32[31 : 0] = tmp0.u32
  D0.u32[63 : 32] = tmp1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

VOP3POp_FUNCTIONS = {
  VOP3POp.V_PK_MAD_I16: _VOP3POp_V_PK_MAD_I16,
  VOP3POp.V_PK_MUL_LO_U16: _VOP3POp_V_PK_MUL_LO_U16,
  VOP3POp.V_PK_ADD_I16: _VOP3POp_V_PK_ADD_I16,
  VOP3POp.V_PK_SUB_I16: _VOP3POp_V_PK_SUB_I16,
  VOP3POp.V_PK_LSHLREV_B16: _VOP3POp_V_PK_LSHLREV_B16,
  VOP3POp.V_PK_LSHRREV_B16: _VOP3POp_V_PK_LSHRREV_B16,
  VOP3POp.V_PK_ASHRREV_I16: _VOP3POp_V_PK_ASHRREV_I16,
  VOP3POp.V_PK_MAX_I16: _VOP3POp_V_PK_MAX_I16,
  VOP3POp.V_PK_MIN_I16: _VOP3POp_V_PK_MIN_I16,
  VOP3POp.V_PK_MAD_U16: _VOP3POp_V_PK_MAD_U16,
  VOP3POp.V_PK_ADD_U16: _VOP3POp_V_PK_ADD_U16,
  VOP3POp.V_PK_SUB_U16: _VOP3POp_V_PK_SUB_U16,
  VOP3POp.V_PK_MAX_U16: _VOP3POp_V_PK_MAX_U16,
  VOP3POp.V_PK_MIN_U16: _VOP3POp_V_PK_MIN_U16,
  VOP3POp.V_PK_FMA_F16: _VOP3POp_V_PK_FMA_F16,
  VOP3POp.V_PK_ADD_F16: _VOP3POp_V_PK_ADD_F16,
  VOP3POp.V_PK_MUL_F16: _VOP3POp_V_PK_MUL_F16,
  VOP3POp.V_PK_MIN_F16: _VOP3POp_V_PK_MIN_F16,
  VOP3POp.V_PK_MAX_F16: _VOP3POp_V_PK_MAX_F16,
  VOP3POp.V_PK_MINIMUM3_F16: _VOP3POp_V_PK_MINIMUM3_F16,
  VOP3POp.V_PK_MAXIMUM3_F16: _VOP3POp_V_PK_MAXIMUM3_F16,
  VOP3POp.V_DOT2_F32_F16: _VOP3POp_V_DOT2_F32_F16,
  VOP3POp.V_DOT2_I32_I16: _VOP3POp_V_DOT2_I32_I16,
  VOP3POp.V_DOT2_U32_U16: _VOP3POp_V_DOT2_U32_U16,
  VOP3POp.V_DOT4_I32_I8: _VOP3POp_V_DOT4_I32_I8,
  VOP3POp.V_DOT4_U32_U8: _VOP3POp_V_DOT4_U32_U8,
  VOP3POp.V_DOT8_I32_I4: _VOP3POp_V_DOT8_I32_I4,
  VOP3POp.V_DOT8_U32_U4: _VOP3POp_V_DOT8_U32_U4,
  VOP3POp.V_PK_FMA_F32: _VOP3POp_V_PK_FMA_F32,
  VOP3POp.V_PK_MUL_F32: _VOP3POp_V_PK_MUL_F32,
  VOP3POp.V_PK_ADD_F32: _VOP3POp_V_PK_ADD_F32,
  VOP3POp.V_PK_MOV_B32: _VOP3POp_V_PK_MOV_B32,
}

def _VOP3AOp_V_CMP_CLASS_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # single-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar
  # S1.u[0] value is a signaling NAN.
  # S1.u[1] value is a quiet NAN.
  # S1.u[2] value is negative infinity.
  # S1.u[3] value is a negative normal value.
  # S1.u[4] value is a negative denormal value.
  # S1.u[5] value is negative zero.
  # S1.u[6] value is positive zero.
  # S1.u[7] value is a positive denormal value.
  # S1.u[8] value is a positive normal value.
  # S1.u[9] value is positive infinity.
  # declare result : 1'U;
  # if isSignalNAN(64'F(S0.f32)) then
  # result = S1.u32[0]
  # elsif isQuietNAN(64'F(S0.f32)) then
  # result = S1.u32[1]
  # elsif exponent(S0.f32) == 255 then
  # // +-INF
  # result = S1.u32[sign(S0.f32) ? 2 : 9]
  # elsif exponent(S0.f32) > 0 then
  # // +-normal value
  # result = S1.u32[sign(S0.f32) ? 3 : 8]
  # elsif 64'F(abs(S0.f32)) > 0.0 then
  # // +-denormal value
  # result = S1.u32[sign(S0.f32) ? 4 : 7]
  # else
  # // +-0.0
  # result = S1.u32[sign(S0.f32) ? 5 : 6]
  # endif;
  # D0.u64[laneId] = result;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  if isSignalNAN(F(S0.f32)):
    result = S1.u32[0]
  elif isQuietNAN(F(S0.f32)):
    result = S1.u32[1]
  elif exponent(S0.f32) == 255:
    result = S1.u32[((2) if (sign(S0.f32)) else (9))]
  elif exponent(S0.f32) > 0:
    result = S1.u32[((3) if (sign(S0.f32)) else (8))]
  elif F(abs(S0.f32)) > 0.0:
    result = S1.u32[((4) if (sign(S0.f32)) else (7))]
  else:
    result = S1.u32[((5) if (sign(S0.f32)) else (6))]
  D0.u64[laneId] = result
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_CLASS_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # single-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask and
  # S1.u[0] value is a signaling NAN.
  # S1.u[1] value is a quiet NAN.
  # S1.u[2] value is negative infinity.
  # S1.u[3] value is a negative normal value.
  # S1.u[4] value is a negative denormal value.
  # S1.u[5] value is negative zero.
  # S1.u[6] value is positive zero.
  # S1.u[7] value is a positive denormal value.
  # S1.u[8] value is a positive normal value.
  # S1.u[9] value is positive infinity.
  # declare result : 1'U;
  # if isSignalNAN(64'F(S0.f32)) then
  # result = S1.u32[0]
  # elsif isQuietNAN(64'F(S0.f32)) then
  # result = S1.u32[1]
  # elsif exponent(S0.f32) == 255 then
  # // +-INF
  # result = S1.u32[sign(S0.f32) ? 2 : 9]
  # elsif exponent(S0.f32) > 0 then
  # // +-normal value
  # result = S1.u32[sign(S0.f32) ? 3 : 8]
  # elsif 64'F(abs(S0.f32)) > 0.0 then
  # // +-denormal value
  # result = S1.u32[sign(S0.f32) ? 4 : 7]
  # else
  # // +-0.0
  # result = S1.u32[sign(S0.f32) ? 5 : 6]
  # endif;
  # EXEC.u64[laneId] = D0.u64[laneId] = result
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  if isSignalNAN(F(S0.f32)):
    result = S1.u32[0]
  elif isQuietNAN(F(S0.f32)):
    result = S1.u32[1]
  elif exponent(S0.f32) == 255:
    result = S1.u32[((2) if (sign(S0.f32)) else (9))]
  elif exponent(S0.f32) > 0:
    result = S1.u32[((3) if (sign(S0.f32)) else (8))]
  elif F(abs(S0.f32)) > 0.0:
    result = S1.u32[((4) if (sign(S0.f32)) else (7))]
  else:
    result = S1.u32[((5) if (sign(S0.f32)) else (6))]
  EXEC.u64[laneId] = D0.u64[laneId] = result
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_CLASS_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # double-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar
  # S1.u[0] value is a signaling NAN.
  # S1.u[1] value is a quiet NAN.
  # S1.u[2] value is negative infinity.
  # S1.u[3] value is a negative normal value.
  # S1.u[4] value is a negative denormal value.
  # S1.u[5] value is negative zero.
  # S1.u[6] value is positive zero.
  # S1.u[7] value is a positive denormal value.
  # S1.u[8] value is a positive normal value.
  # S1.u[9] value is positive infinity.
  # declare result : 1'U;
  # if isSignalNAN(S0.f64) then
  # result = S1.u32[0]
  # elsif isQuietNAN(S0.f64) then
  # result = S1.u32[1]
  # elsif exponent(S0.f64) == 2047 then
  # // +-INF
  # result = S1.u32[sign(S0.f64) ? 2 : 9]
  # elsif exponent(S0.f64) > 0 then
  # // +-normal value
  # result = S1.u32[sign(S0.f64) ? 3 : 8]
  # elsif abs(S0.f64) > 0.0 then
  # // +-denormal value
  # result = S1.u32[sign(S0.f64) ? 4 : 7]
  # else
  # // +-0.0
  # result = S1.u32[sign(S0.f64) ? 5 : 6]
  # endif;
  # D0.u64[laneId] = result;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  if isSignalNAN(S0.f64):
    result = S1.u32[0]
  elif isQuietNAN(S0.f64):
    result = S1.u32[1]
  elif exponent(S0.f64) == 2047:
    result = S1.u32[((2) if (sign(S0.f64)) else (9))]
  elif exponent(S0.f64) > 0:
    result = S1.u32[((3) if (sign(S0.f64)) else (8))]
  elif abs(S0.f64) > 0.0:
    result = S1.u32[((4) if (sign(S0.f64)) else (7))]
  else:
    result = S1.u32[((5) if (sign(S0.f64)) else (6))]
  D0.u64[laneId] = result
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_CLASS_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # double-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask
  # S1.u[0] value is a signaling NAN.
  # S1.u[1] value is a quiet NAN.
  # S1.u[2] value is negative infinity.
  # S1.u[3] value is a negative normal value.
  # S1.u[4] value is a negative denormal value.
  # S1.u[5] value is negative zero.
  # S1.u[6] value is positive zero.
  # S1.u[7] value is a positive denormal value.
  # S1.u[8] value is a positive normal value.
  # S1.u[9] value is positive infinity.
  # declare result : 1'U;
  # if isSignalNAN(S0.f64) then
  # result = S1.u32[0]
  # elsif isQuietNAN(S0.f64) then
  # result = S1.u32[1]
  # elsif exponent(S0.f64) == 2047 then
  # // +-INF
  # result = S1.u32[sign(S0.f64) ? 2 : 9]
  # elsif exponent(S0.f64) > 0 then
  # // +-normal value
  # result = S1.u32[sign(S0.f64) ? 3 : 8]
  # elsif abs(S0.f64) > 0.0 then
  # // +-denormal value
  # result = S1.u32[sign(S0.f64) ? 4 : 7]
  # else
  # // +-0.0
  # result = S1.u32[sign(S0.f64) ? 5 : 6]
  # endif;
  # EXEC.u64[laneId] = D0.u64[laneId] = result
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  if isSignalNAN(S0.f64):
    result = S1.u32[0]
  elif isQuietNAN(S0.f64):
    result = S1.u32[1]
  elif exponent(S0.f64) == 2047:
    result = S1.u32[((2) if (sign(S0.f64)) else (9))]
  elif exponent(S0.f64) > 0:
    result = S1.u32[((3) if (sign(S0.f64)) else (8))]
  elif abs(S0.f64) > 0.0:
    result = S1.u32[((4) if (sign(S0.f64)) else (7))]
  else:
    result = S1.u32[((5) if (sign(S0.f64)) else (6))]
  EXEC.u64[laneId] = D0.u64[laneId] = result
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_CLASS_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # half-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar
  # S1.u[0] value is a signaling NAN.
  # S1.u[1] value is a quiet NAN.
  # S1.u[2] value is negative infinity.
  # S1.u[3] value is a negative normal value.
  # S1.u[4] value is a negative denormal value.
  # S1.u[5] value is negative zero.
  # S1.u[6] value is positive zero.
  # S1.u[7] value is a positive denormal value.
  # S1.u[8] value is a positive normal value.
  # S1.u[9] value is positive infinity.
  # declare result : 1'U;
  # if isSignalNAN(64'F(S0.f16)) then
  # result = S1.u32[0]
  # elsif isQuietNAN(64'F(S0.f16)) then
  # result = S1.u32[1]
  # elsif exponent(S0.f16) == 31 then
  # // +-INF
  # result = S1.u32[sign(S0.f16) ? 2 : 9]
  # elsif exponent(S0.f16) > 0 then
  # // +-normal value
  # result = S1.u32[sign(S0.f16) ? 3 : 8]
  # elsif 64'F(abs(S0.f16)) > 0.0 then
  # // +-denormal value
  # result = S1.u32[sign(S0.f16) ? 4 : 7]
  # else
  # // +-0.0
  # result = S1.u32[sign(S0.f16) ? 5 : 6]
  # endif;
  # D0.u64[laneId] = result;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  if isSignalNAN(F(S0.f16)):
    result = S1.u32[0]
  elif isQuietNAN(F(S0.f16)):
    result = S1.u32[1]
  elif exponent(S0.f16) == 31:
    result = S1.u32[((2) if (sign(S0.f16)) else (9))]
  elif exponent(S0.f16) > 0:
    result = S1.u32[((3) if (sign(S0.f16)) else (8))]
  elif F(abs(S0.f16)) > 0.0:
    result = S1.u32[((4) if (sign(S0.f16)) else (7))]
  else:
    result = S1.u32[((5) if (sign(S0.f16)) else (6))]
  D0.u64[laneId] = result
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_CLASS_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # half-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask and
  # S1.u[0] value is a signaling NAN.
  # S1.u[1] value is a quiet NAN.
  # S1.u[2] value is negative infinity.
  # S1.u[3] value is a negative normal value.
  # S1.u[4] value is a negative denormal value.
  # S1.u[5] value is negative zero.
  # S1.u[6] value is positive zero.
  # S1.u[7] value is a positive denormal value.
  # S1.u[8] value is a positive normal value.
  # S1.u[9] value is positive infinity.
  # declare result : 1'U;
  # if isSignalNAN(64'F(S0.f16)) then
  # result = S1.u32[0]
  # elsif isQuietNAN(64'F(S0.f16)) then
  # result = S1.u32[1]
  # elsif exponent(S0.f16) == 31 then
  # // +-INF
  # result = S1.u32[sign(S0.f16) ? 2 : 9]
  # elsif exponent(S0.f16) > 0 then
  # // +-normal value
  # result = S1.u32[sign(S0.f16) ? 3 : 8]
  # elsif 64'F(abs(S0.f16)) > 0.0 then
  # // +-denormal value
  # result = S1.u32[sign(S0.f16) ? 4 : 7]
  # else
  # // +-0.0
  # result = S1.u32[sign(S0.f16) ? 5 : 6]
  # endif;
  # EXEC.u64[laneId] = D0.u64[laneId] = result
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  if isSignalNAN(F(S0.f16)):
    result = S1.u32[0]
  elif isQuietNAN(F(S0.f16)):
    result = S1.u32[1]
  elif exponent(S0.f16) == 31:
    result = S1.u32[((2) if (sign(S0.f16)) else (9))]
  elif exponent(S0.f16) > 0:
    result = S1.u32[((3) if (sign(S0.f16)) else (8))]
  elif F(abs(S0.f16)) > 0.0:
    result = S1.u32[((4) if (sign(S0.f16)) else (7))]
  else:
    result = S1.u32[((5) if (sign(S0.f16)) else (6))]
  EXEC.u64[laneId] = D0.u64[laneId] = result
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.f16 < S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f16 < S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.f16 == S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f16 == S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f16 <= S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f16 <= S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.f16 > S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f16 > S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LG_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f16 <> S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f16  !=  S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f16 >= S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f16 >= S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_O_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC
  # D0.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = ( not isNAN(F(S0.f16))  and   not isNAN(F(S1.f16)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_U_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VCC or a scalar register.
  # D0.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = (isNAN(F(S0.f16))  or  isNAN(F(S1.f16)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NGE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f16 >= S1.f16);
  # // With NAN inputs this is not the same operation as <
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f16 >= S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLG_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f16 <> S1.f16);
  # // With NAN inputs this is not the same operation as ==
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f16  !=  S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NGT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VCC or a scalar register.
  # D0.u64[laneId] = !(S0.f16 > S1.f16);
  # // With NAN inputs this is not the same operation as <=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f16 > S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f16 <= S1.f16);
  # // With NAN inputs this is not the same operation as >
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f16 <= S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NEQ_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = !(S0.f16 == S1.f16);
  # // With NAN inputs this is not the same operation as !=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f16 == S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC
  # D0.u64[laneId] = !(S0.f16 < S1.f16);
  # // With NAN inputs this is not the same operation as >=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f16 < S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_TRU_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 < S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 < S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 == S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 == S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 <= S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 <= S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 > S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 > S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LG_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 <> S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f16  !=  S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 >= S1.f16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f16 >= S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_O_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = ( not isNAN(F(S0.f16))  and   not isNAN(F(S1.f16)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_U_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = (isNAN(F(S0.f16))  or  isNAN(F(S1.f16)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NGE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f16 >= S1.f16);
  # // With NAN inputs this is not the same operation as <
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f16 >= S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLG_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f16 <> S1.f16);
  # // With NAN inputs this is not the same operation as ==
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f16  !=  S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NGT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f16 > S1.f16);
  # // With NAN inputs this is not the same operation as <=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f16 > S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLE_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f16 <= S1.f16);
  # // With NAN inputs this is not the same operation as >
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f16 <= S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NEQ_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f16 == S1.f16);
  # // With NAN inputs this is not the same operation as !=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f16 == S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f16 < S1.f16);
  # // With NAN inputs this is not the same operation as >=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f16 < S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_TRU_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.f32 < S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f32 < S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.f32 == S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f32 == S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f32 <= S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f32 <= S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.f32 > S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f32 > S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LG_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f32 <> S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f32  !=  S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f32 >= S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f32 >= S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_O_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC
  # D0.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = ( not isNAN(F(S0.f32))  and   not isNAN(F(S1.f32)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_U_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VCC or a scalar register.
  # D0.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = (isNAN(F(S0.f32))  or  isNAN(F(S1.f32)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NGE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f32 >= S1.f32);
  # // With NAN inputs this is not the same operation as <
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f32 >= S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLG_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f32 <> S1.f32);
  # // With NAN inputs this is not the same operation as ==
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f32  !=  S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NGT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VCC or a scalar register.
  # D0.u64[laneId] = !(S0.f32 > S1.f32);
  # // With NAN inputs this is not the same operation as <=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f32 > S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f32 <= S1.f32);
  # // With NAN inputs this is not the same operation as >
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f32 <= S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NEQ_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = !(S0.f32 == S1.f32);
  # // With NAN inputs this is not the same operation as !=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f32 == S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC
  # D0.u64[laneId] = !(S0.f32 < S1.f32);
  # // With NAN inputs this is not the same operation as >=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f32 < S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_TRU_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 < S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 < S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 == S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 == S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 <= S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 <= S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 > S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 > S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LG_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 <> S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f32  !=  S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 >= S1.f32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f32 >= S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_O_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = ( not isNAN(F(S0.f32))  and   not isNAN(F(S1.f32)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_U_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = (isNAN(F(S0.f32))  or  isNAN(F(S1.f32)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NGE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f32 >= S1.f32);
  # // With NAN inputs this is not the same operation as <
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f32 >= S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLG_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f32 <> S1.f32);
  # // With NAN inputs this is not the same operation as ==
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f32  !=  S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NGT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f32 > S1.f32);
  # // With NAN inputs this is not the same operation as <=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f32 > S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f32 <= S1.f32);
  # // With NAN inputs this is not the same operation as >
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f32 <= S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NEQ_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f32 == S1.f32);
  # // With NAN inputs this is not the same operation as !=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f32 == S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f32 < S1.f32);
  # // With NAN inputs this is not the same operation as >=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f32 < S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_TRU_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.f64 < S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f64 < S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.f64 == S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f64 == S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f64 <= S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f64 <= S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.f64 > S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f64 > S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LG_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f64 <> S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f64  !=  S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.f64 >= S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.f64 >= S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_O_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC
  # D0.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = ( not isNAN(S0.f64)  and   not isNAN(S1.f64))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_U_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VCC or a scalar register.
  # D0.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = (isNAN(S0.f64)  or  isNAN(S1.f64))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NGE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f64 >= S1.f64);
  # // With NAN inputs this is not the same operation as <
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f64 >= S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLG_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f64 <> S1.f64);
  # // With NAN inputs this is not the same operation as ==
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f64  !=  S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NGT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VCC or a scalar register.
  # D0.u64[laneId] = !(S0.f64 > S1.f64);
  # // With NAN inputs this is not the same operation as <=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f64 > S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = !(S0.f64 <= S1.f64);
  # // With NAN inputs this is not the same operation as >
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f64 <= S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NEQ_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = !(S0.f64 == S1.f64);
  # // With NAN inputs this is not the same operation as !=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f64 == S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NLT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC
  # D0.u64[laneId] = !(S0.f64 < S1.f64);
  # // With NAN inputs this is not the same operation as >=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] =  not (S0.f64 < S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_TRU_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 < S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 < S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 == S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 == S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 <= S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 <= S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 > S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 > S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LG_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 <> S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f64  !=  S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 >= S1.f64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.f64 >= S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_O_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = ( not isNAN(S0.f64)  and   not isNAN(S1.f64))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_U_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64));
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = (isNAN(S0.f64)  or  isNAN(S1.f64))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NGE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f64 >= S1.f64);
  # // With NAN inputs this is not the same operation as <
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f64 >= S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLG_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f64 <> S1.f64);
  # // With NAN inputs this is not the same operation as ==
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f64  !=  S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NGT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f64 > S1.f64);
  # // With NAN inputs this is not the same operation as <=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f64 > S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f64 <= S1.f64);
  # // With NAN inputs this is not the same operation as >
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f64 <= S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NEQ_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f64 == S1.f64);
  # // With NAN inputs this is not the same operation as !=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f64 == S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NLT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = !(S0.f64 < S1.f64);
  # // With NAN inputs this is not the same operation as >=
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] =  not (S0.f64 < S1.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_TRU_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.i16 < S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i16 < S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.i16 == S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i16 == S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.i16 <= S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i16 <= S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.i16 > S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i16 > S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = S0.i16 <> S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i16  !=  S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.i16 >= S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i16 >= S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_T_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.u16 < S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u16 < S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.u16 == S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u16 == S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.u16 <= S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u16 <= S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.u16 > S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u16 > S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = S0.u16 <> S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u16  !=  S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.u16 >= S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u16 >= S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_T_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 < S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 < S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 == S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 == S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 <= S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 <= S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 > S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 > S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 <> S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16  !=  S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 >= S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 >= S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_T_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 < S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 < S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 == S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 == S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 <= S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 <= S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 > S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 > S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 <> S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16  !=  S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 >= S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 >= S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_T_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.i32 < S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i32 < S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.i32 == S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i32 == S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.i32 <= S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i32 <= S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.i32 > S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i32 > S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = S0.i32 <> S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i32  !=  S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.i32 >= S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i32 >= S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_T_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.u32 < S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u32 < S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.u32 == S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u32 == S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.u32 <= S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u32 <= S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.u32 > S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u32 > S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = S0.u32 <> S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u32  !=  S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.u32 >= S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u32 >= S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_T_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 < S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 < S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 == S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 == S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 <= S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 <= S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 > S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 > S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 <> S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i32  !=  S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 >= S1.i32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i32 >= S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_T_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 < S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 < S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 == S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 == S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 <= S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 <= S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 > S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 > S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 <> S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u32  !=  S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 >= S1.u32;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u32 >= S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_T_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.i64 < S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i64 < S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.i64 == S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i64 == S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.i64 <= S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i64 <= S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.i64 > S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i64 > S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NE_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = S0.i64 <> S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i64  !=  S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.i64 >= S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.i64 >= S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_T_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_F_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LT_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.u64 < S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u64 < S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_EQ_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a
  # D0.u64[laneId] = S0.u64 == S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u64 == S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_LE_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.u64 <= S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u64 <= S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GT_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC
  # D0.u64[laneId] = S0.u64 > S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u64 > S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_NE_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC
  # D0.u64[laneId] = S0.u64 <> S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u64  !=  S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_GE_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64[laneId] = S0.u64 >= S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = S0.u64 >= S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMP_T_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into VCC or a scalar register.
  # D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 < S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 < S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 == S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 == S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 <= S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 <= S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 > S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 > S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NE_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 <> S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i64  !=  S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 >= S1.i64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i64 >= S1.i64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_T_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_F_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'0U;
  # // D0 = VCC in VOPC encoding.
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LT_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 < S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 < S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_EQ_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 == S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 == S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_LE_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 <= S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 <= S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GT_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 > S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 > S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_NE_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 <> S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u64  !=  S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_GE_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 >= S1.u64;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u64 >= S1.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CMPX_T_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = 1'1U;
  # // D0 = VCC in VOPC encoding.
  # addr = CalcDsAddr(ADDR.b32, OFFSET0.b32, OFFSET1.b32);
  # tmp = MEM[addr].u32;
  # addr = CalcDsAddr(ADDR.b32, OFFSET0.b32, OFFSET1.b32);
  # tmp = MEM[addr].u32;
  # addr = CalcDsAddr(ADDR.b32, OFFSET0.b32, OFFSET1.b32);
  # tmp = MEM[addr].u32;
  # addr = CalcDsAddr(ADDR.b32, OFFSET0.b32, OFFSET1.b32);
  # tmp = MEM[addr].u32;
  # src = DATA.u32;
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = 1
  addr = CalcDsAddr(ADDR.b32, OFFSET0.b32, OFFSET1.b32)
  tmp = Reg(MEM[addr].u32)
  addr = CalcDsAddr(ADDR.b32, OFFSET0.b32, OFFSET1.b32)
  tmp = Reg(MEM[addr].u32)
  addr = CalcDsAddr(ADDR.b32, OFFSET0.b32, OFFSET1.b32)
  tmp = Reg(MEM[addr].u32)
  addr = CalcDsAddr(ADDR.b32, OFFSET0.b32, OFFSET1.b32)
  tmp = Reg(MEM[addr].u32)
  src = DATA.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  result['d0_64'] = True
  return result

def _VOP3AOp_V_MOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b32 = S0.b32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b32 = S0.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_READFIRSTLANE_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare lane : 32'I;
  # if EXEC == 0x0LL then
  # lane = 0;
  # // Force lane 0 if all lanes are disabled
  # else
  # lane = s_ff1_i32_b64(EXEC);
  # // Lowest active lane
  # endif;
  # D0.b32 = VGPR[lane][SRC0.u32]
  D0 = Reg(d0)
  EXEC = Reg(exec_mask)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  if EXEC == 0x0:
    lane = 0
  else:
    lane = s_ff1_i32_b64(EXEC)
  D0.b32 = VGPR[lane][SRC0.u32]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  return result

def _VOP3AOp_V_CVT_I32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f64_to_i32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f64_to_i32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F64_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = i32_to_f64(S0.i32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = i32_to_f64(S0.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CVT_F32_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = i32_to_f32(S0.i32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = i32_to_f32(S0.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F32_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0.u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_U32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = f32_to_u32(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = f32_to_u32(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f32_to_i32(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f32_to_i32(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F16_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = f32_to_f16(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = f32_to_f16(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F32_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = f16_to_f32(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = f16_to_f32(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_RPI_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f32_to_i32(floor(S0.f32 + 0.5F))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f32_to_i32(floor(S0.f32 + 0.5))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_FLR_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f32_to_i32(floor(S0.f32))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f32_to_i32(floor(S0.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = f64_to_f32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = f64_to_f32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F64_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = f32_to_f64(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = f32_to_f64(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CVT_F32_UBYTE0(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[7 : 0].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[7 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F32_UBYTE1(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[15 : 8].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[15 : 8].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F32_UBYTE2(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[23 : 16].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[23 : 16].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F32_UBYTE3(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[31 : 24].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[31 : 24].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_U32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = f64_to_u32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = f64_to_u32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F64_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = u32_to_f64(S0.u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = u32_to_f64(S0.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_TRUNC_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CEIL_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64);
  # if ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then
  # D0.f64 += 1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  if ((S0.f64 > 0.0)  and  (S0.f64 != D0.f64)):
    D0.f64 += 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_RNDNE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = floor(S0.f64 + 0.5);
  # if (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then
  # D0.f64 -= 1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = floor(S0.f64 + 0.5)
  if (isEven(floor(S0.f64))  and  (fract(S0.f64) == 0.5)):
    D0.f64 -= 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_FLOOR_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64);
  # if ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then
  # D0.f64 += -1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  if ((S0.f64 < 0.0)  and  (S0.f64 != D0.f64)):
    D0.f64 += -1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_FRACT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 + -floor(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 + -floor(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_TRUNC_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = trunc(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = trunc(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CEIL_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = trunc(S0.f32);
  # if ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then
  # D0.f32 += 1.0F
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = trunc(S0.f32)
  if ((S0.f32 > 0.0)  and  (S0.f32 != D0.f32)):
    D0.f32 += 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_RNDNE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = floor(S0.f32 + 0.5F);
  # if (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then
  # D0.f32 -= 1.0F
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = floor(S0.f32 + 0.5)
  if (isEven(F(floor(S0.f32)))  and  (fract(S0.f32) == 0.5)):
    D0.f32 -= 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FLOOR_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = trunc(S0.f32);
  # if ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then
  # D0.f32 += -1.0F
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = trunc(S0.f32)
  if ((S0.f32 < 0.0)  and  (S0.f32 != D0.f32)):
    D0.f32 += -1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_EXP_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = pow(2.0F, S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = pow(2.0, S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LOG_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = log2(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = log2(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_RCP_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 1.0F / S0.f32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = 1.0 / S0.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_RCP_IFLAG_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 1.0F / S0.f32;
  # // Can only raise integer DIV_BY_ZERO exception
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = 1.0 / S0.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_RSQ_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 1.0F / sqrt(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = 1.0 / sqrt(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_RCP_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = 1.0 / S0.f64
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = 1.0 / S0.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_RSQ_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = 1.0 / sqrt(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = 1.0 / sqrt(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_SQRT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = sqrt(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = sqrt(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SQRT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = sqrt(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = sqrt(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_SIN_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = sin(S0.f32 * 32'F(PI * 2.0))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = sin(S0.f32 * F(PI * 2.0))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_COS_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = cos(S0.f32 * 32'F(PI * 2.0))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = cos(S0.f32 * F(PI * 2.0))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_NOT_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ~S0.u32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ~S0.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_BFREV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32[31 : 0] = S0.u32[0 : 31]
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32[31 : 0] = S0.u32[0 : 31]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FFBH_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = -1;
  # // Set if no ones are found
  # for i in 0 : 31 do
  # // Search from MSB
  # if S0.u32[31 - i] == 1'1U then
  # D0.i32 = i;
  # endif
  # endfor
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = -1
  for i in range(0, int(31)+1):
    if S0.u32[31 - i] == 1:
      D0.i32 = i
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FFBL_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = -1;
  # // Set if no ones are found
  # for i in 0 : 31 do
  # // Search from LSB
  # if S0.u32[i] == 1'1U then
  # D0.i32 = i;
  # endif
  # endfor
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = -1
  for i in range(0, int(31)+1):
    if S0.u32[i] == 1:
      D0.i32 = i
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FFBH_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = -1;
  # // Set if all bits are the same
  # for i in 1 : 31 do
  # // Search from MSB
  # if S0.i32[31 - i] != S0.i32[31] then
  # D0.i32 = i;
  # endif
  # endfor
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = -1
  for i in range(1, int(31)+1):
    if S0.i32[31 - i] != S0.i32[31]:
      D0.i32 = i
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FREXP_EXP_I32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then
  # D0.i32 = 0
  # else
  # D0.i32 = exponent(S0.f64) - 1023 + 1
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((S0.f64 == INF)  or  (S0.f64 == (-INF))  or  isNAN(S0.f64)):
    D0.i32 = 0
  else:
    D0.i32 = exponent(S0.f64) - 1023 + 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FREXP_MANT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then
  # D0.f64 = S0.f64
  # else
  # D0.f64 = mantissa(S0.f64)
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((S0.f64 == INF)  or  (S0.f64 == (-INF))  or  isNAN(S0.f64)):
    D0.f64 = S0.f64
  else:
    D0.f64 = mantissa(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_FRACT_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = S0.f64 + -floor(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = S0.f64 + -floor(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_FREXP_EXP_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then
  # D0.i32 = 0
  # else
  # D0.i32 = exponent(S0.f32) - 127 + 1
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((F(S0.f32) == INF)  or  (F(S0.f32) == (-INF))  or  isNAN(F(S0.f32))):
    D0.i32 = 0
  else:
    D0.i32 = exponent(S0.f32) - 127 + 1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FREXP_MANT_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then
  # D0.f32 = S0.f32
  # else
  # D0.f32 = mantissa(S0.f32)
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((F(S0.f32) == INF)  or  (F(S0.f32) == (-INF))  or  isNAN(F(S0.f32))):
    D0.f32 = S0.f32
  else:
    D0.f32 = mantissa(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MOV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b64 = S0.b64
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b64 = S0.b64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_CVT_F16_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = u16_to_f16(S0.u16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = u16_to_f16(S0.u16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_F16_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = i16_to_f16(S0.i16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = i16_to_f16(S0.i16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_U16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = f16_to_u16(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = f16_to_u16(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_I16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = f16_to_i16(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = f16_to_i16(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_RCP_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = 16'1.0 / S0.f16
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = 1.0 / S0.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SQRT_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = sqrt(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = sqrt(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_RSQ_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = 16'1.0 / sqrt(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = 1.0 / sqrt(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LOG_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = log2(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = log2(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_EXP_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = pow(16'2.0, S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = pow(2.0, S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CNDMASK_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = VCC.u64[laneId] ? S1.u32 : S0.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  D0.u32 = ((S1.u32) if (VCC.u64[laneId]) else (S0.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3AOp_V_ADD_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 + S1.f32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 + S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUB_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 - S1.f32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 - S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUBREV_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S1.f32 - S0.f32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S1.f32 - S0.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FMAC_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = fma(S0.f64, S1.f64, D0.f64)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = fma(S0.f64, S1.f64, D0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_MUL_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 * S1.f32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 * S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_I32_I24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(S0.i24) * 32'I(S1.i24)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (S0.i24) * (S1.i24)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_HI_I32_I24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I((64'I(S0.i24) * 64'I(S1.i24)) >> 32U)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (((S0.i24) * (S1.i24)) >> 32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_U32_U24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U(S0.u24) * 32'U(S1.u24)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u24) * (S1.u24)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_HI_U32_U24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U((64'U(S0.u24) * 64'U(S1.u24)) >> 32U)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (((S0.u24) * (S1.u24)) >> 32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(64'F(S0.f32))) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))
  # elsif (WAVE_MODE.IEEE && isSignalNAN(64'F(S1.f32))) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))
  # elsif isNAN(64'F(S0.f32)) then
  # D0.f32 = S1.f32
  # elsif isNAN(64'F(S1.f32)) then
  # D0.f32 = S0.f32
  # elsif ((64'F(S0.f32) == +0.0) && (64'F(S1.f32) == -0.0)) then
  # D0.f32 = S1.f32
  # elsif ((64'F(S0.f32) == -0.0) && (64'F(S1.f32) == +0.0)) then
  # D0.f32 = S0.f32
  # else
  # D0.f32 = S0.f32 < S1.f32 ? S0.f32 : S1.f32
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(F(S0.f32))):
    D0.f32 = F(cvtToQuietNAN(F(S0.f32)))
  elif (WAVE_MODE.IEEE  and  isSignalNAN(F(S1.f32))):
    D0.f32 = F(cvtToQuietNAN(F(S1.f32)))
  elif isNAN(F(S0.f32)):
    D0.f32 = S1.f32
  elif isNAN(F(S1.f32)):
    D0.f32 = S0.f32
  elif ((F(S0.f32) == +0.0)  and  (F(S1.f32) == -0.0)):
    D0.f32 = S1.f32
  elif ((F(S0.f32) == -0.0)  and  (F(S1.f32) == +0.0)):
    D0.f32 = S0.f32
  else:
    D0.f32 = ((S0.f32) if (S0.f32 < S1.f32) else (S1.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(64'F(S0.f32))) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))
  # elsif (WAVE_MODE.IEEE && isSignalNAN(64'F(S1.f32))) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))
  # elsif isNAN(64'F(S0.f32)) then
  # D0.f32 = S1.f32
  # elsif isNAN(64'F(S1.f32)) then
  # D0.f32 = S0.f32
  # elsif ((64'F(S0.f32) == +0.0) && (64'F(S1.f32) == -0.0)) then
  # D0.f32 = S0.f32
  # elsif ((64'F(S0.f32) == -0.0) && (64'F(S1.f32) == +0.0)) then
  # D0.f32 = S1.f32
  # elsif WAVE_MODE.IEEE then
  # D0.f32 = S0.f32 >= S1.f32 ? S0.f32 : S1.f32
  # else
  # D0.f32 = S0.f32 > S1.f32 ? S0.f32 : S1.f32
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(F(S0.f32))):
    D0.f32 = F(cvtToQuietNAN(F(S0.f32)))
  elif (WAVE_MODE.IEEE  and  isSignalNAN(F(S1.f32))):
    D0.f32 = F(cvtToQuietNAN(F(S1.f32)))
  elif isNAN(F(S0.f32)):
    D0.f32 = S1.f32
  elif isNAN(F(S1.f32)):
    D0.f32 = S0.f32
  elif ((F(S0.f32) == +0.0)  and  (F(S1.f32) == -0.0)):
    D0.f32 = S0.f32
  elif ((F(S0.f32) == -0.0)  and  (F(S1.f32) == +0.0)):
    D0.f32 = S1.f32
  elif WAVE_MODE.IEEE:
    D0.f32 = ((S0.f32) if (S0.f32 >= S1.f32) else (S1.f32))
  else:
    D0.f32 = ((S0.f32) if (S0.f32 > S1.f32) else (S1.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 < S1.i32 ? S0.i32 : S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = ((S0.i32) if (S0.i32 < S1.i32) else (S1.i32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 >= S1.i32 ? S0.i32 : S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = ((S0.i32) if (S0.i32 >= S1.i32) else (S1.i32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 < S1.u32 ? S0.u32 : S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32) if (S0.u32 < S1.u32) else (S1.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 >= S1.u32 ? S0.u32 : S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32) if (S0.u32 >= S1.u32) else (S1.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LSHRREV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S1.u32 >> S0[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S1.u32 >> S0[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ASHRREV_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = (S1.i32 >> S0[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (S1.i32 >> S0[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LSHLREV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S1.u32 << S0[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S1.u32 << S0[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_AND_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 & S1.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 & S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_OR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 | S1.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 | S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_XOR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 ^ S1.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 ^ S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ADD_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 + S1.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 + S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUB_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 - S1.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 - S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUBREV_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S1.f16 - S0.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S1.f16 - S0.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 * S1.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 * S1.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAC_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.f16 * S1.f16 + D0.f16;
  # if OPSEL.u4[3] then
  # D0 = { tmp.f16, D0[15 : 0] }
  # else
  # D0 = { 16'0, tmp.f16 }
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.f16 * S1.f16 + D0.f16)
  if OPSEL.u4[3]:
    D0 = Reg(_pack(tmp.f16, D0[15 : 0]))
  else:
    D0 = Reg(_pack(0, tmp.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ADD_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 + S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S0.u16 + S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUB_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 - S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S0.u16 - S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUBREV_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S1.u16 - S0.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S1.u16 - S0.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_LO_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 * S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S0.u16 * S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LSHLREV_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = (S1.u16 << S0[3 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = (S1.u16 << S0[3 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LSHRREV_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = (S1.u16 >> S0[3 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = (S1.u16 >> S0[3 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ASHRREV_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = (S1.i16 >> S0[3 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = (S1.i16 >> S0[3 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(64'F(S0.f16))) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))
  # elsif (WAVE_MODE.IEEE && isSignalNAN(64'F(S1.f16))) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))
  # elsif isNAN(64'F(S0.f16)) then
  # D0.f16 = S1.f16
  # elsif isNAN(64'F(S1.f16)) then
  # D0.f16 = S0.f16
  # elsif ((64'F(S0.f16) == +0.0) && (64'F(S1.f16) == -0.0)) then
  # D0.f16 = S0.f16
  # elsif ((64'F(S0.f16) == -0.0) && (64'F(S1.f16) == +0.0)) then
  # D0.f16 = S1.f16
  # elsif WAVE_MODE.IEEE then
  # D0.f16 = S0.f16 >= S1.f16 ? S0.f16 : S1.f16
  # else
  # D0.f16 = S0.f16 > S1.f16 ? S0.f16 : S1.f16
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(F(S0.f16))):
    D0.f16 = F(cvtToQuietNAN(F(S0.f16)))
  elif (WAVE_MODE.IEEE  and  isSignalNAN(F(S1.f16))):
    D0.f16 = F(cvtToQuietNAN(F(S1.f16)))
  elif isNAN(F(S0.f16)):
    D0.f16 = S1.f16
  elif isNAN(F(S1.f16)):
    D0.f16 = S0.f16
  elif ((F(S0.f16) == +0.0)  and  (F(S1.f16) == -0.0)):
    D0.f16 = S0.f16
  elif ((F(S0.f16) == -0.0)  and  (F(S1.f16) == +0.0)):
    D0.f16 = S1.f16
  elif WAVE_MODE.IEEE:
    D0.f16 = ((S0.f16) if (S0.f16 >= S1.f16) else (S1.f16))
  else:
    D0.f16 = ((S0.f16) if (S0.f16 > S1.f16) else (S1.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(64'F(S0.f16))) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))
  # elsif (WAVE_MODE.IEEE && isSignalNAN(64'F(S1.f16))) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))
  # elsif isNAN(64'F(S0.f16)) then
  # D0.f16 = S1.f16
  # elsif isNAN(64'F(S1.f16)) then
  # D0.f16 = S0.f16
  # elsif ((64'F(S0.f16) == +0.0) && (64'F(S1.f16) == -0.0)) then
  # D0.f16 = S1.f16
  # elsif ((64'F(S0.f16) == -0.0) && (64'F(S1.f16) == +0.0)) then
  # D0.f16 = S0.f16
  # else
  # D0.f16 = S0.f16 < S1.f16 ? S0.f16 : S1.f16
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(F(S0.f16))):
    D0.f16 = F(cvtToQuietNAN(F(S0.f16)))
  elif (WAVE_MODE.IEEE  and  isSignalNAN(F(S1.f16))):
    D0.f16 = F(cvtToQuietNAN(F(S1.f16)))
  elif isNAN(F(S0.f16)):
    D0.f16 = S1.f16
  elif isNAN(F(S1.f16)):
    D0.f16 = S0.f16
  elif ((F(S0.f16) == +0.0)  and  (F(S1.f16) == -0.0)):
    D0.f16 = S1.f16
  elif ((F(S0.f16) == -0.0)  and  (F(S1.f16) == +0.0)):
    D0.f16 = S0.f16
  else:
    D0.f16 = ((S0.f16) if (S0.f16 < S1.f16) else (S1.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 >= S1.u16 ? S0.u16 : S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = ((S0.u16) if (S0.u16 >= S1.u16) else (S1.u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = S0.i16 >= S1.i16 ? S0.i16 : S1.i16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = ((S0.i16) if (S0.i16 >= S1.i16) else (S1.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 < S1.u16 ? S0.u16 : S1.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = ((S0.u16) if (S0.u16 < S1.u16) else (S1.u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = S0.i16 < S1.i16 ? S0.i16 : S1.i16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = ((S0.i16) if (S0.i16 < S1.i16) else (S1.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LDEXP_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 * 16'F(2.0F ** 32'I(S1.i16))
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 * F(2.0 ** (S1.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 + S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = S0.u32 + S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUB_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 - S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = S0.u32 - S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUBREV_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S1.u32 - S0.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = S1.u32 - S0.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_DOT2C_F32_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.f32;
  # tmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16);
  # tmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16);
  # D0.f32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.f32)
  tmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16)
  tmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16)
  D0.f32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_DOT2C_I32_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.i32;
  # tmp += i16_to_i32(S0[15 : 0].i16) * i16_to_i32(S1[15 : 0].i16);
  # tmp += i16_to_i32(S0[31 : 16].i16) * i16_to_i32(S1[31 : 16].i16);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.i32)
  tmp += i16_to_i32(S0[15 : 0].i16) * i16_to_i32(S1[15 : 0].i16)
  tmp += i16_to_i32(S0[31 : 16].i16) * i16_to_i32(S1[31 : 16].i16)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_DOT4C_I32_I8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.i32;
  # tmp += i8_to_i32(S0[7 : 0].i8) * i8_to_i32(S1[7 : 0].i8);
  # tmp += i8_to_i32(S0[15 : 8].i8) * i8_to_i32(S1[15 : 8].i8);
  # tmp += i8_to_i32(S0[23 : 16].i8) * i8_to_i32(S1[23 : 16].i8);
  # tmp += i8_to_i32(S0[31 : 24].i8) * i8_to_i32(S1[31 : 24].i8);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.i32)
  tmp += i8_to_i32(S0[7 : 0].i8) * i8_to_i32(S1[7 : 0].i8)
  tmp += i8_to_i32(S0[15 : 8].i8) * i8_to_i32(S1[15 : 8].i8)
  tmp += i8_to_i32(S0[23 : 16].i8) * i8_to_i32(S1[23 : 16].i8)
  tmp += i8_to_i32(S0[31 : 24].i8) * i8_to_i32(S1[31 : 24].i8)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_DOT8C_I32_I4(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = D0.i32;
  # tmp += i4_to_i32(S0[3 : 0].i4) * i4_to_i32(S1[3 : 0].i4);
  # tmp += i4_to_i32(S0[7 : 4].i4) * i4_to_i32(S1[7 : 4].i4);
  # tmp += i4_to_i32(S0[11 : 8].i4) * i4_to_i32(S1[11 : 8].i4);
  # tmp += i4_to_i32(S0[15 : 12].i4) * i4_to_i32(S1[15 : 12].i4);
  # tmp += i4_to_i32(S0[19 : 16].i4) * i4_to_i32(S1[19 : 16].i4);
  # tmp += i4_to_i32(S0[23 : 20].i4) * i4_to_i32(S1[23 : 20].i4);
  # tmp += i4_to_i32(S0[27 : 24].i4) * i4_to_i32(S1[27 : 24].i4);
  # tmp += i4_to_i32(S0[31 : 28].i4) * i4_to_i32(S1[31 : 28].i4);
  # D0.i32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(D0.i32)
  tmp += i4_to_i32(S0[3 : 0].i4) * i4_to_i32(S1[3 : 0].i4)
  tmp += i4_to_i32(S0[7 : 4].i4) * i4_to_i32(S1[7 : 4].i4)
  tmp += i4_to_i32(S0[11 : 8].i4) * i4_to_i32(S1[11 : 8].i4)
  tmp += i4_to_i32(S0[15 : 12].i4) * i4_to_i32(S1[15 : 12].i4)
  tmp += i4_to_i32(S0[19 : 16].i4) * i4_to_i32(S1[19 : 16].i4)
  tmp += i4_to_i32(S0[23 : 20].i4) * i4_to_i32(S1[23 : 20].i4)
  tmp += i4_to_i32(S0[27 : 24].i4) * i4_to_i32(S1[27 : 24].i4)
  tmp += i4_to_i32(S0[31 : 28].i4) * i4_to_i32(S1[31 : 28].i4)
  D0.i32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FMAC_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = fma(S0.f32, S1.f32, D0.f32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = fma(S0.f32, S1.f32, D0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_PK_FMAC_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16);
  # D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16)
  D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_XNOR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ~(S0.u32 ^ S1.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ~(S0.u32 ^ S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_I32_I24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(S0.i24) * 32'I(S1.i24) + S2.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (S0.i24) * (S1.i24) + S2.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_U32_U24(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U(S0.u24) * 32'U(S1.u24) + S2.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u24) * (S1.u24) + S2.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CUBEID_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // Set D0.f = cubemap face ID ({0.0, 1.0, ..., 5.0}).
  # // XYZ coordinate is given in (S0.f, S1.f, S2.f).
  # // S0.f = x
  # // S1.f = y
  # // S2.f = z
  # if ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then
  # if S2.f32 < 0.0F then
  # D0.f32 = 5.0F
  # else
  # D0.f32 = 4.0F
  # endif
  # elsif abs(S1.f32) >= abs(S0.f32) then
  # if S1.f32 < 0.0F then
  # D0.f32 = 3.0F
  # else
  # D0.f32 = 2.0F
  # endif
  # else
  # if S0.f32 < 0.0F then
  # D0.f32 = 1.0F
  # else
  # D0.f32 = 0.0F
  # endif
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((abs(S2.f32) >= abs(S0.f32))  and  (abs(S2.f32) >= abs(S1.f32))):
    if S2.f32 < 0.0:
      D0.f32 = 5.0
    else:
      D0.f32 = 4.0
  elif abs(S1.f32) >= abs(S0.f32):
    if S1.f32 < 0.0:
      D0.f32 = 3.0
    else:
      D0.f32 = 2.0
  else:
    if S0.f32 < 0.0:
      D0.f32 = 1.0
    else:
      D0.f32 = 0.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CUBESC_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // D0.f = cubemap S coordinate.
  # // XYZ coordinate is given in (S0.f, S1.f, S2.f).
  # // S0.f = x
  # // S1.f = y
  # // S2.f = z
  # if ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then
  # if S2.f32 < 0.0F then
  # D0.f32 = -S0.f32
  # else
  # D0.f32 = S0.f32
  # endif
  # elsif abs(S1.f32) >= abs(S0.f32) then
  # D0.f32 = S0.f32
  # else
  # if S0.f32 < 0.0F then
  # D0.f32 = S2.f32
  # else
  # D0.f32 = -S2.f32
  # endif
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((abs(S2.f32) >= abs(S0.f32))  and  (abs(S2.f32) >= abs(S1.f32))):
    if S2.f32 < 0.0:
      D0.f32 = -S0.f32
    else:
      D0.f32 = S0.f32
  elif abs(S1.f32) >= abs(S0.f32):
    D0.f32 = S0.f32
  else:
    if S0.f32 < 0.0:
      D0.f32 = S2.f32
    else:
      D0.f32 = -S2.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CUBETC_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // D0.f = cubemap T coordinate.
  # // XYZ coordinate is given in (S0.f, S1.f, S2.f).
  # // S0.f = x
  # // S1.f = y
  # // S2.f = z
  # if ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then
  # D0.f32 = -S1.f32
  # elsif abs(S1.f32) >= abs(S0.f32) then
  # if S1.f32 < 0.0F then
  # D0.f32 = -S2.f32
  # else
  # D0.f32 = S2.f32
  # endif
  # else
  # D0.f32 = -S1.f32
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((abs(S2.f32) >= abs(S0.f32))  and  (abs(S2.f32) >= abs(S1.f32))):
    D0.f32 = -S1.f32
  elif abs(S1.f32) >= abs(S0.f32):
    if S1.f32 < 0.0:
      D0.f32 = -S2.f32
    else:
      D0.f32 = S2.f32
  else:
    D0.f32 = -S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CUBEMA_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // D0.f = 2.0 * cubemap major axis.
  # // XYZ coordinate is given in (S0.f, S1.f, S2.f).
  # // S0.f = x
  # // S1.f = y
  # // S2.f = z
  # if ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then
  # D0.f32 = S2.f32 * 2.0F
  # elsif abs(S1.f32) >= abs(S0.f32) then
  # D0.f32 = S1.f32 * 2.0F
  # else
  # D0.f32 = S0.f32 * 2.0F
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((abs(S2.f32) >= abs(S0.f32))  and  (abs(S2.f32) >= abs(S1.f32))):
    D0.f32 = S2.f32 * 2.0
  elif abs(S1.f32) >= abs(S0.f32):
    D0.f32 = S1.f32 * 2.0
  else:
    D0.f32 = S0.f32 * 2.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_BFE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1U << S2[4 : 0].u32) - 1U))
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1 << S2[4 : 0].u32) - 1))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_BFE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S2[4 : 0].u32) - 1));
  # D0.i32 = signext_from_bit(tmp.i32, S2[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S2[4 : 0].u32) - 1))
  D0.i32 = signext_from_bit(tmp.i32, S2[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_BFI_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ((S0.u32 & S1.u32) | (~S0.u32 & S2.u32))
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32 & S1.u32) | (~S0.u32 & S2.u32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FMA_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = fma(S0.f32, S1.f32, S2.f32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = fma(S0.f32, S1.f32, S2.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FMA_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = fma(S0.f64, S1.f64, S2.f64)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = fma(S0.f64, S1.f64, S2.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_LERP_U8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = ((S0.u32[31 : 24] + S1.u32[31 : 24] + S2.u32[24].u8) >> 1U << 24U);
  # tmp += ((S0.u32[23 : 16] + S1.u32[23 : 16] + S2.u32[16].u8) >> 1U << 16U);
  # tmp += ((S0.u32[15 : 8] + S1.u32[15 : 8] + S2.u32[8].u8) >> 1U << 8U);
  # tmp += ((S0.u32[7 : 0] + S1.u32[7 : 0] + S2.u32[0].u8) >> 1U);
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(((S0.u32[31 : 24] + S1.u32[31 : 24] + S2.u32[24].u8) >> 1 << 24))
  tmp += ((S0.u32[23 : 16] + S1.u32[23 : 16] + S2.u32[16].u8) >> 1 << 16)
  tmp += ((S0.u32[15 : 8] + S1.u32[15 : 8] + S2.u32[8].u8) >> 1 << 8)
  tmp += ((S0.u32[7 : 0] + S1.u32[7 : 0] + S2.u32[0].u8) >> 1)
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ALIGNBIT_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U(({ S0.u32, S1.u32 } >> S2.u32[4 : 0]) & 0xffffffffLL)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((_pack32(S0.u32, S1.u32) >> S2.u32[4 : 0]) & 0xffffffff)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ALIGNBYTE_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U(({ S0.u32, S1.u32 } >> (S2.u32[1 : 0] * 8U)) & 0xffffffffLL)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((_pack32(S0.u32, S1.u32) >> (S2.u32[1 : 0] * 8)) & 0xffffffff)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN3_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = v_min_f32(v_min_f32(S0.f32, S1.f32), S2.f32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = v_min_f32(v_min_f32(S0.f32, S1.f32), S2.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN3_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = v_min_i32(v_min_i32(S0.i32, S1.i32), S2.i32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = v_min_i32(v_min_i32(S0.i32, S1.i32), S2.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN3_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = v_min_u32(v_min_u32(S0.u32, S1.u32), S2.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = v_min_u32(v_min_u32(S0.u32, S1.u32), S2.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX3_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = v_max_f32(v_max_f32(S0.f32, S1.f32), S2.f32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = v_max_f32(v_max_f32(S0.f32, S1.f32), S2.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX3_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = v_max_i32(v_max_i32(S0.i32, S1.i32), S2.i32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = v_max_i32(v_max_i32(S0.i32, S1.i32), S2.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX3_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = v_max_u32(v_max_u32(S0.u32, S1.u32), S2.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = v_max_u32(v_max_u32(S0.u32, S1.u32), S2.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MED3_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)) || isNAN(64'F(S2.f32))) then
  # D0.f32 = v_min3_f32(S0.f32, S1.f32, S2.f32)
  # elsif v_max3_f32(S0.f32, S1.f32, S2.f32) == S0.f32 then
  # D0.f32 = v_max_f32(S1.f32, S2.f32)
  # elsif v_max3_f32(S0.f32, S1.f32, S2.f32) == S1.f32 then
  # D0.f32 = v_max_f32(S0.f32, S2.f32)
  # else
  # D0.f32 = v_max_f32(S0.f32, S1.f32)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (isNAN(F(S0.f32))  or  isNAN(F(S1.f32))  or  isNAN(F(S2.f32))):
    D0.f32 = v_min3_f32(S0.f32, S1.f32, S2.f32)
  elif v_max3_f32(S0.f32, S1.f32, S2.f32) == S0.f32:
    D0.f32 = v_max_f32(S1.f32, S2.f32)
  elif v_max3_f32(S0.f32, S1.f32, S2.f32) == S1.f32:
    D0.f32 = v_max_f32(S0.f32, S2.f32)
  else:
    D0.f32 = v_max_f32(S0.f32, S1.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MED3_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if v_max3_i32(S0.i32, S1.i32, S2.i32) == S0.i32 then
  # D0.i32 = v_max_i32(S1.i32, S2.i32)
  # elsif v_max3_i32(S0.i32, S1.i32, S2.i32) == S1.i32 then
  # D0.i32 = v_max_i32(S0.i32, S2.i32)
  # else
  # D0.i32 = v_max_i32(S0.i32, S1.i32)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if v_max3_i32(S0.i32, S1.i32, S2.i32) == S0.i32:
    D0.i32 = v_max_i32(S1.i32, S2.i32)
  elif v_max3_i32(S0.i32, S1.i32, S2.i32) == S1.i32:
    D0.i32 = v_max_i32(S0.i32, S2.i32)
  else:
    D0.i32 = v_max_i32(S0.i32, S1.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MED3_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if v_max3_u32(S0.u32, S1.u32, S2.u32) == S0.u32 then
  # D0.u32 = v_max_u32(S1.u32, S2.u32)
  # elsif v_max3_u32(S0.u32, S1.u32, S2.u32) == S1.u32 then
  # D0.u32 = v_max_u32(S0.u32, S2.u32)
  # else
  # D0.u32 = v_max_u32(S0.u32, S1.u32)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if v_max3_u32(S0.u32, S1.u32, S2.u32) == S0.u32:
    D0.u32 = v_max_u32(S1.u32, S2.u32)
  elif v_max3_u32(S0.u32, S1.u32, S2.u32) == S1.u32:
    D0.u32 = v_max_u32(S0.u32, S2.u32)
  else:
    D0.u32 = v_max_u32(S0.u32, S1.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SAD_U8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // UNSIGNED comparison
  # tmp = S2.u32;
  # tmp += 32'U(ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]));
  # tmp += 32'U(ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]));
  # tmp += 32'U(ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]));
  # tmp += 32'U(ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]));
  # D0.u32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.u32)
  tmp += (ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]))
  tmp += (ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]))
  tmp += (ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]))
  tmp += (ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]))
  D0.u32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SAD_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // UNSIGNED comparison
  # tmp = S2.u32;
  # tmp += ABSDIFF(S0[15 : 0].u16, S1[15 : 0].u16);
  # tmp += ABSDIFF(S0[31 : 16].u16, S1[31 : 16].u16);
  # D0.u32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.u32)
  tmp += ABSDIFF(S0[15 : 0].u16, S1[15 : 0].u16)
  tmp += ABSDIFF(S0[31 : 16].u16, S1[31 : 16].u16)
  D0.u32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SAD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // UNSIGNED comparison
  # D0.u32 = ABSDIFF(S0.u32, S1.u32) + S2.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ABSDIFF(S0.u32, S1.u32) + S2.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PK_U8_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = (S2.u32 & 32'U(~(0xff << (S1.u32[1 : 0].u32 * 8U))));
  # tmp = (tmp | ((32'U(f32_to_u8(S0.f32)) & 255U) << (S1.u32[1 : 0].u32 * 8U)));
  # D0.u32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg((S2.u32 & (~(0xff << (S1.u32[1 : 0].u32 * 8)))))
  tmp = Reg((tmp | (((f32_to_u8(S0.f32)) & 255) << (S1.u32[1 : 0].u32 * 8))))
  D0.u32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_DIV_FIXUP_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # sign_out = (sign(S1.f32) ^ sign(S2.f32));
  # if isNAN(64'F(S2.f32)) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S2.f32)))
  # elsif isNAN(64'F(S1.f32)) then
  # D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))
  # elsif ((64'F(S1.f32) == 0.0) && (64'F(S2.f32) == 0.0)) then
  # // 0/0
  # D0.f32 = 32'F(0xffc00000)
  # elsif ((64'F(abs(S1.f32)) == +INF) && (64'F(abs(S2.f32)) == +INF)) then
  # // inf/inf
  # D0.f32 = 32'F(0xffc00000)
  # elsif ((64'F(S1.f32) == 0.0) || (64'F(abs(S2.f32)) == +INF)) then
  # // x/0, or inf/y
  # D0.f32 = sign_out ? -INF.f32 : +INF.f32
  # elsif ((64'F(abs(S1.f32)) == +INF) || (64'F(S2.f32) == 0.0)) then
  # // x/inf, 0/y
  # D0.f32 = sign_out ? -0.0F : 0.0F
  # elsif exponent(S2.f32) - exponent(S1.f32) < -150 then
  # D0.f32 = sign_out ? -UNDERFLOW_F32 : UNDERFLOW_F32
  # elsif exponent(S1.f32) == 255 then
  # D0.f32 = sign_out ? -OVERFLOW_F32 : OVERFLOW_F32
  # else
  # D0.f32 = sign_out ? -abs(S0.f32) : abs(S0.f32)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  sign_out = (sign(S1.f32) ^ sign(S2.f32))
  if isNAN(F(S2.f32)):
    D0.f32 = F(cvtToQuietNAN(F(S2.f32)))
  elif isNAN(F(S1.f32)):
    D0.f32 = F(cvtToQuietNAN(F(S1.f32)))
  elif ((F(S1.f32) == 0.0)  and  (F(S2.f32) == 0.0)):
    D0.f32 = F(0xffc00000)
  elif ((F(abs(S1.f32)) == INF)  and  (F(abs(S2.f32)) == INF)):
    D0.f32 = F(0xffc00000)
  elif ((F(S1.f32) == 0.0)  or  (F(abs(S2.f32)) == INF)):
    D0.f32 = (((-INF).f32) if (sign_out) else (INF.f32))
  elif ((F(abs(S1.f32)) == INF)  or  (F(S2.f32) == 0.0)):
    D0.f32 = ((-0.0) if (sign_out) else (0.0))
  elif exponent(S2.f32) - exponent(S1.f32) < -150:
    D0.f32 = ((-UNDERFLOW_F32) if (sign_out) else (UNDERFLOW_F32))
  elif exponent(S1.f32) == 255:
    D0.f32 = ((-OVERFLOW_F32) if (sign_out) else (OVERFLOW_F32))
  else:
    D0.f32 = ((-OVERFLOW_F32) if (sign_out) else (OVERFLOW_F32)) if isNAN(S0.f32) else ((-abs(S0.f32)) if (sign_out) else (abs(S0.f32)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_DIV_FIXUP_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # sign_out = (sign(S1.f64) ^ sign(S2.f64));
  # if isNAN(S2.f64) then
  # D0.f64 = cvtToQuietNAN(S2.f64)
  # elsif isNAN(S1.f64) then
  # D0.f64 = cvtToQuietNAN(S1.f64)
  # elsif ((S1.f64 == 0.0) && (S2.f64 == 0.0)) then
  # // 0/0
  # D0.f64 = 64'F(0xfff8000000000000LL)
  # elsif ((abs(S1.f64) == +INF) && (abs(S2.f64) == +INF)) then
  # // inf/inf
  # D0.f64 = 64'F(0xfff8000000000000LL)
  # elsif ((S1.f64 == 0.0) || (abs(S2.f64) == +INF)) then
  # // x/0, or inf/y
  # D0.f64 = sign_out ? -INF : +INF
  # elsif ((abs(S1.f64) == +INF) || (S2.f64 == 0.0)) then
  # // x/inf, 0/y
  # D0.f64 = sign_out ? -0.0 : 0.0
  # elsif exponent(S2.f64) - exponent(S1.f64) < -1075 then
  # D0.f64 = sign_out ? -UNDERFLOW_F64 : UNDERFLOW_F64
  # elsif exponent(S1.f64) == 2047 then
  # D0.f64 = sign_out ? -OVERFLOW_F64 : OVERFLOW_F64
  # else
  # D0.f64 = sign_out ? -abs(S0.f64) : abs(S0.f64)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  sign_out = (sign(S1.f64) ^ sign(S2.f64))
  if isNAN(S2.f64):
    D0.f64 = cvtToQuietNAN(S2.f64)
  elif isNAN(S1.f64):
    D0.f64 = cvtToQuietNAN(S1.f64)
  elif ((S1.f64 == 0.0)  and  (S2.f64 == 0.0)):
    D0.f64 = F(0xfff8000000000000)
  elif ((abs(S1.f64) == INF)  and  (abs(S2.f64) == INF)):
    D0.f64 = F(0xfff8000000000000)
  elif ((S1.f64 == 0.0)  or  (abs(S2.f64) == INF)):
    D0.f64 = (((-INF)) if (sign_out) else (INF))
  elif ((abs(S1.f64) == INF)  or  (S2.f64 == 0.0)):
    D0.f64 = ((-0.0) if (sign_out) else (0.0))
  elif exponent(S2.f64) - exponent(S1.f64) < -1075:
    D0.f64 = ((-UNDERFLOW_F64) if (sign_out) else (UNDERFLOW_F64))
  elif exponent(S1.f64) == 2047:
    D0.f64 = ((-OVERFLOW_F64) if (sign_out) else (OVERFLOW_F64))
  else:
    D0.f64 = ((-OVERFLOW_F64) if (sign_out) else (OVERFLOW_F64)) if isNAN(S0.f64) else ((-abs(S0.f64)) if (sign_out) else (abs(S0.f64)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_DIV_FMAS_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if VCC.u64[laneId] then
  # D0.f32 = 2.0F ** 32 * fma(S0.f32, S1.f32, S2.f32)
  # else
  # D0.f32 = fma(S0.f32, S1.f32, S2.f32)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  if VCC.u64[laneId]:
    D0.f32 = (2.0 ** 64 if exponent(S2.f32) > 127 else 2.0 ** -64) * fma(S0.f32, S1.f32, S2.f32)
  else:
    D0.f32 = fma(S0.f32, S1.f32, S2.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3AOp_V_DIV_FMAS_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if VCC.u64[laneId] then
  # D0.f64 = 2.0 ** 64 * fma(S0.f64, S1.f64, S2.f64)
  # else
  # D0.f64 = fma(S0.f64, S1.f64, S2.f64)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  laneId = lane
  # --- compiled pseudocode ---
  if VCC.u64[laneId]:
    D0.f64 = (2.0 ** 128 if exponent(S2.f64) > 1023 else 2.0 ** -128) * fma(S0.f64, S1.f64, S2.f64)
  else:
    D0.f64 = fma(S0.f64, S1.f64, S2.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3AOp_V_MSAD_U8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # // UNSIGNED comparison
  # tmp = S2.u32;
  # tmp += S1.u32[7 : 0] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]));
  # tmp += S1.u32[15 : 8] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]));
  # tmp += S1.u32[23 : 16] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]));
  # tmp += S1.u32[31 : 24] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]));
  # D0.u32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S2.u32)
  tmp += ((0) if (S1.u32[7 : 0] == 0) else ((ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]))))
  tmp += ((0) if (S1.u32[15 : 8] == 0) else ((ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]))))
  tmp += ((0) if (S1.u32[23 : 16] == 0) else ((ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]))))
  tmp += ((0) if (S1.u32[31 : 24] == 0) else ((ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]))))
  D0.u32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_LEGACY_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.f16 * S1.f16 + S2.f16;
  # if OPSEL.u4[3] then
  # D0 = { tmp.f16, D0[15 : 0] }
  # else
  # D0 = { 16'0, tmp.f16 }
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.f16 * S1.f16 + S2.f16)
  if OPSEL.u4[3]:
    D0 = Reg(_pack(tmp.f16, D0[15 : 0]))
  else:
    D0 = Reg(_pack(0, tmp.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_LEGACY_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u16 * S1.u16 + S2.u16;
  # if OPSEL.u4[3] then
  # D0 = { tmp.u16, D0[15 : 0] }
  # else
  # D0 = { 16'0, tmp.u16 }
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.u16 * S1.u16 + S2.u16)
  if OPSEL.u4[3]:
    D0 = Reg(_pack(tmp.u16, D0[15 : 0]))
  else:
    D0 = Reg(_pack(0, tmp.u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_LEGACY_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.i16 * S1.i16 + S2.i16;
  # if OPSEL.u4[3] then
  # D0 = { tmp.i16, D0[15 : 0] }
  # else
  # D0 = { 16'0, tmp.i16 }
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.i16 * S1.i16 + S2.i16)
  if OPSEL.u4[3]:
    D0 = Reg(_pack(tmp.i16, D0[15 : 0]))
  else:
    D0 = Reg(_pack(0, tmp.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FMA_LEGACY_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = fma(S0.f16, S1.f16, S2.f16);
  # if OPSEL.u4[3] then
  # D0 = { tmp.f16, D0[15 : 0] }
  # else
  # D0 = { 16'0, tmp.f16 }
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(fma(S0.f16, S1.f16, S2.f16))
  if OPSEL.u4[3]:
    D0 = Reg(_pack(tmp.f16, D0[15 : 0]))
  else:
    D0 = Reg(_pack(0, tmp.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_DIV_FIXUP_LEGACY_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # sign_out = (sign(S1.f16) ^ sign(S2.f16));
  # if isNAN(64'F(S2.f16)) then
  # tmp = cvtToQuietNAN(64'F(S2.f16))
  # elsif isNAN(64'F(S1.f16)) then
  # tmp = cvtToQuietNAN(64'F(S1.f16))
  # elsif ((64'F(S1.f16) == 0.0) && (64'F(S2.f16) == 0.0)) then
  # // 0/0
  # tmp = 16'F(0xfe00)
  # elsif ((64'F(abs(S1.f16)) == +INF) && (64'F(abs(S2.f16)) == +INF)) then
  # // inf/inf
  # tmp = 16'F(0xfe00)
  # elsif ((64'F(S1.f16) == 0.0) || (64'F(abs(S2.f16)) == +INF)) then
  # // x/0, or inf/y
  # tmp = sign_out ? -INF : +INF
  # elsif ((64'F(abs(S1.f16)) == +INF) || (64'F(S2.f16) == 0.0)) then
  # // x/inf, 0/y
  # tmp = sign_out ? -0.0 : 0.0
  # else
  # tmp = sign_out ? -abs(S0.f16) : abs(S0.f16)
  # endif;
  # if OPSEL.u4[3] then
  # D0 = { tmp.f16, D0[15 : 0] }
  # else
  # D0 = { 16'0, tmp.f16 }
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  sign_out = (sign(S1.f16) ^ sign(S2.f16))
  if isNAN(F(S2.f16)):
    tmp = Reg(cvtToQuietNAN(F(S2.f16)))
  elif isNAN(F(S1.f16)):
    tmp = Reg(cvtToQuietNAN(F(S1.f16)))
  elif ((F(S1.f16) == 0.0)  and  (F(S2.f16) == 0.0)):
    tmp = Reg(F(0xfe00))
  elif ((F(abs(S1.f16)) == INF)  and  (F(abs(S2.f16)) == INF)):
    tmp = Reg(F(0xfe00))
  elif ((F(S1.f16) == 0.0)  or  (F(abs(S2.f16)) == INF)):
    tmp = Reg((((-INF)) if (sign_out) else (INF)))
  elif ((F(abs(S1.f16)) == INF)  or  (F(S2.f16) == 0.0)):
    tmp = Reg(((-0.0) if (sign_out) else (0.0)))
  else:
    tmp = Reg(((-abs(S0.f16)) if (sign_out) else (abs(S0.f16))))
  if OPSEL.u4[3]:
    D0 = Reg(_pack(tmp.f16, D0[15 : 0]))
  else:
    D0 = Reg(_pack(0, tmp.f16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PKACCUM_U8_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # byte = S1.u32[1 : 0];
  # bit = byte.u32 * 8U;
  # D0.u32[bit + 7U : bit] = 32'U(f32_to_u8(S0.f32))
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  byte = S1.u32[1 : 0]
  bit = byte.u32 * 8
  D0.u32[bit + 7U : bit] = (f32_to_u8(S0.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_U32_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U(S0.u16) * 32'U(S1.u16) + S2.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u16) * (S1.u16) + S2.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_I32_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(S0.i16) * 32'I(S1.i16) + S2.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (S0.i16) * (S1.i16) + S2.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_XAD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 ^ S1.u32) + S2.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 ^ S1.u32) + S2.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN3_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = v_min_f16(v_min_f16(S0.f16, S1.f16), S2.f16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = v_min_f16(v_min_f16(S0.f16, S1.f16), S2.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN3_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = v_min_i16(v_min_i16(S0.i16, S1.i16), S2.i16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = v_min_i16(v_min_i16(S0.i16, S1.i16), S2.i16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MIN3_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = v_min_u16(v_min_u16(S0.u16, S1.u16), S2.u16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = v_min_u16(v_min_u16(S0.u16, S1.u16), S2.u16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX3_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = v_max_f16(v_max_f16(S0.f16, S1.f16), S2.f16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = v_max_f16(v_max_f16(S0.f16, S1.f16), S2.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX3_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = v_max_i16(v_max_i16(S0.i16, S1.i16), S2.i16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = v_max_i16(v_max_i16(S0.i16, S1.i16), S2.i16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAX3_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = v_max_u16(v_max_u16(S0.u16, S1.u16), S2.u16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = v_max_u16(v_max_u16(S0.u16, S1.u16), S2.u16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MED3_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)) || isNAN(64'F(S2.f16))) then
  # D0.f16 = v_min3_f16(S0.f16, S1.f16, S2.f16)
  # elsif v_max3_f16(S0.f16, S1.f16, S2.f16) == S0.f16 then
  # D0.f16 = v_max_f16(S1.f16, S2.f16)
  # elsif v_max3_f16(S0.f16, S1.f16, S2.f16) == S1.f16 then
  # D0.f16 = v_max_f16(S0.f16, S2.f16)
  # else
  # D0.f16 = v_max_f16(S0.f16, S1.f16)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (isNAN(F(S0.f16))  or  isNAN(F(S1.f16))  or  isNAN(F(S2.f16))):
    D0.f16 = v_min3_f16(S0.f16, S1.f16, S2.f16)
  elif v_max3_f16(S0.f16, S1.f16, S2.f16) == S0.f16:
    D0.f16 = v_max_f16(S1.f16, S2.f16)
  elif v_max3_f16(S0.f16, S1.f16, S2.f16) == S1.f16:
    D0.f16 = v_max_f16(S0.f16, S2.f16)
  else:
    D0.f16 = v_max_f16(S0.f16, S1.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MED3_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if v_max3_i16(S0.i16, S1.i16, S2.i16) == S0.i16 then
  # D0.i16 = v_max_i16(S1.i16, S2.i16)
  # elsif v_max3_i16(S0.i16, S1.i16, S2.i16) == S1.i16 then
  # D0.i16 = v_max_i16(S0.i16, S2.i16)
  # else
  # D0.i16 = v_max_i16(S0.i16, S1.i16)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if v_max3_i16(S0.i16, S1.i16, S2.i16) == S0.i16:
    D0.i16 = v_max_i16(S1.i16, S2.i16)
  elif v_max3_i16(S0.i16, S1.i16, S2.i16) == S1.i16:
    D0.i16 = v_max_i16(S0.i16, S2.i16)
  else:
    D0.i16 = v_max_i16(S0.i16, S1.i16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MED3_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if v_max3_u16(S0.u16, S1.u16, S2.u16) == S0.u16 then
  # D0.u16 = v_max_u16(S1.u16, S2.u16)
  # elsif v_max3_u16(S0.u16, S1.u16, S2.u16) == S1.u16 then
  # D0.u16 = v_max_u16(S0.u16, S2.u16)
  # else
  # D0.u16 = v_max_u16(S0.u16, S1.u16)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if v_max3_u16(S0.u16, S1.u16, S2.u16) == S0.u16:
    D0.u16 = v_max_u16(S1.u16, S2.u16)
  elif v_max3_u16(S0.u16, S1.u16, S2.u16) == S1.u16:
    D0.u16 = v_max_u16(S0.u16, S2.u16)
  else:
    D0.u16 = v_max_u16(S0.u16, S1.u16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LSHL_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 << S1.u32[4 : 0].u32) + S2.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 << S1.u32[4 : 0].u32) + S2.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ADD_LSHL_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ((S0.u32 + S1.u32) << S2.u32[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32 + S1.u32) << S2.u32[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ADD3_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 + S1.u32 + S2.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = S0.u32 + S1.u32 + S2.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LSHL_OR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ((S0.u32 << S1.u32[4 : 0].u32) | S2.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32 << S1.u32[4 : 0].u32) | S2.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_AND_OR_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = ((S0.u32 & S1.u32) | S2.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = ((S0.u32 & S1.u32) | S2.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_OR3_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (S0.u32 | S1.u32 | S2.u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (S0.u32 | S1.u32 | S2.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = S0.f16 * S1.f16 + S2.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = S0.f16 * S1.f16 + S2.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u16 = S0.u16 * S1.u16 + S2.u16
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u16 = S0.u16 * S1.u16 + S2.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAD_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = S0.i16 * S1.i16 + S2.i16
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = S0.i16 * S1.i16 + S2.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_FMA_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = fma(S0.f16, S1.f16, S2.f16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = fma(S0.f16, S1.f16, S2.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_DIV_FIXUP_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # sign_out = (sign(S1.f16) ^ sign(S2.f16));
  # if isNAN(64'F(S2.f16)) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S2.f16)))
  # elsif isNAN(64'F(S1.f16)) then
  # D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))
  # elsif ((64'F(S1.f16) == 0.0) && (64'F(S2.f16) == 0.0)) then
  # // 0/0
  # D0.f16 = 16'F(0xfe00)
  # elsif ((64'F(abs(S1.f16)) == +INF) && (64'F(abs(S2.f16)) == +INF)) then
  # // inf/inf
  # D0.f16 = 16'F(0xfe00)
  # elsif ((64'F(S1.f16) == 0.0) || (64'F(abs(S2.f16)) == +INF)) then
  # // x/0, or inf/y
  # D0.f16 = sign_out ? -INF.f16 : +INF.f16
  # elsif ((64'F(abs(S1.f16)) == +INF) || (64'F(S2.f16) == 0.0)) then
  # // x/inf, 0/y
  # D0.f16 = sign_out ? -16'0.0 : 16'0.0
  # else
  # D0.f16 = sign_out ? -abs(S0.f16) : abs(S0.f16)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  sign_out = (sign(S1.f16) ^ sign(S2.f16))
  if isNAN(F(S2.f16)):
    D0.f16 = F(cvtToQuietNAN(F(S2.f16)))
  elif isNAN(F(S1.f16)):
    D0.f16 = F(cvtToQuietNAN(F(S1.f16)))
  elif ((F(S1.f16) == 0.0)  and  (F(S2.f16) == 0.0)):
    D0.f16 = F(0xfe00)
  elif ((F(abs(S1.f16)) == INF)  and  (F(abs(S2.f16)) == INF)):
    D0.f16 = F(0xfe00)
  elif ((F(S1.f16) == 0.0)  or  (F(abs(S2.f16)) == INF)):
    D0.f16 = (((-INF).f16) if (sign_out) else (INF.f16))
  elif ((F(abs(S1.f16)) == INF)  or  (F(S2.f16) == 0.0)):
    D0.f16 = ((-0.0) if (sign_out) else (0.0))
  else:
    D0.f16 = ((-abs(S0.f16)) if (sign_out) else (abs(S0.f16)))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LSHL_ADD_U64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S0.u64 << S1.u32[2 : 0].u32) + S2.u64
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u64 = (S0.u64 << S1.u32[2 : 0].u32) + S2.u64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_BITOP3_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 16'0U;
  # tmp = (tmp | (32'I(TTBL.b32 & 0x1) != 0 ? 16'U(~S0.b16 & ~S1.b16 & ~S2.b16) : 16'0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x2) != 0 ? 16'U(~S0.b16 & ~S1.b16 & S2.b16) : 16'0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x4) != 0 ? 16'U(~S0.b16 & S1.b16 & ~S2.b16) : 16'0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x8) != 0 ? 16'U(~S0.b16 & S1.b16 & S2.b16) : 16'0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x10) != 0 ? 16'U(S0.b16 & ~S1.b16 & ~S2.b16) : 16'0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x20) != 0 ? 16'U(S0.b16 & ~S1.b16 & S2.b16) : 16'0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x40) != 0 ? 16'U(S0.b16 & S1.b16 & ~S2.b16) : 16'0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x80) != 0 ? 16'U(S0.b16 & S1.b16 & S2.b16) : 16'0U));
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(0)
  tmp = Reg((tmp | ((TTBL.b32 & 0x1) != 0 ? (~S0.b16 & ~S1.b16 & ~S2.b16) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x2) != 0 ? (~S0.b16 & ~S1.b16 & S2.b16) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x4) != 0 ? (~S0.b16 & S1.b16 & ~S2.b16) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x8) != 0 ? (~S0.b16 & S1.b16 & S2.b16) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x10) != 0 ? (S0.b16 & ~S1.b16 & ~S2.b16) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x20) != 0 ? (S0.b16 & ~S1.b16 & S2.b16) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x40) != 0 ? (S0.b16 & S1.b16 & ~S2.b16) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x80) != 0 ? (S0.b16 & S1.b16 & S2.b16) : 0)))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_BITOP3_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 0U;
  # tmp = (tmp | (32'I(TTBL.b32 & 0x1) != 0 ? 32'U(~S0.b32 & ~S1.b32 & ~S2.b32) : 0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x2) != 0 ? 32'U(~S0.b32 & ~S1.b32 & S2.b32) : 0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x4) != 0 ? 32'U(~S0.b32 & S1.b32 & ~S2.b32) : 0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x8) != 0 ? 32'U(~S0.b32 & S1.b32 & S2.b32) : 0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x10) != 0 ? 32'U(S0.b32 & ~S1.b32 & ~S2.b32) : 0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x20) != 0 ? 32'U(S0.b32 & ~S1.b32 & S2.b32) : 0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x40) != 0 ? 32'U(S0.b32 & S1.b32 & ~S2.b32) : 0U));
  # tmp = (tmp | (32'I(TTBL.b32 & 0x80) != 0 ? 32'U(S0.b32 & S1.b32 & S2.b32) : 0U));
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(0)
  tmp = Reg((tmp | ((TTBL.b32 & 0x1) != 0 ? (~S0.b32 & ~S1.b32 & ~S2.b32) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x2) != 0 ? (~S0.b32 & ~S1.b32 & S2.b32) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x4) != 0 ? (~S0.b32 & S1.b32 & ~S2.b32) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x8) != 0 ? (~S0.b32 & S1.b32 & S2.b32) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x10) != 0 ? (S0.b32 & ~S1.b32 & ~S2.b32) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x20) != 0 ? (S0.b32 & ~S1.b32 & S2.b32) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x40) != 0 ? (S0.b32 & S1.b32 & ~S2.b32) : 0)))
  tmp = Reg((tmp | ((TTBL.b32 & 0x80) != 0 ? (S0.b32 & S1.b32 & S2.b32) : 0)))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_FP8_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # tmp0 = f32_to_fp8_scale(S0.f32, scale.u8);
  # tmp1 = f32_to_fp8_scale(S1.f32, scale.u8);
  # dstword = OPSEL[3].i32 * 16;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  tmp0 = f32_to_fp8_scale(S0.f32, scale.u8)
  tmp1 = f32_to_fp8_scale(S1.f32, scale.u8)
  dstword = OPSEL[3].i32 * 16
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_BF8_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # tmp0 = f32_to_bf8_scale(S0.f32, scale.u8);
  # tmp1 = f32_to_bf8_scale(S1.f32, scale.u8);
  # dstword = OPSEL[3].i32 * 16;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  tmp0 = f32_to_bf8_scale(S0.f32, scale.u8)
  tmp1 = f32_to_bf8_scale(S1.f32, scale.u8)
  dstword = OPSEL[3].i32 * 16
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_FP8_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # tmp = f32_to_fp8_sr_scale(S0.f32, S1.u32, scale.u8);
  # dstbyte = OPSEL[3 : 2].i32 * 8;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  tmp = Reg(f32_to_fp8_sr_scale(S0.f32, S1.u32, scale.u8))
  dstbyte = OPSEL[3 : 2].i32 * 8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_BF8_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # tmp = f32_to_bf8_sr_scale(S0.f32, S1.u32, scale.u8);
  # dstbyte = OPSEL[3 : 2].i32 * 8;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  tmp = Reg(f32_to_bf8_sr_scale(S0.f32, S1.u32, scale.u8))
  dstbyte = OPSEL[3 : 2].i32 * 8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_F32_FP8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcword = OPSEL[0].i32 * 16;
  # src = VGPR[laneId][SRC0.u32][srcword + 15 : srcword].b16;
  # D0[31 : 0].f32 = tmp0;
  # D0[63 : 32].f32 = tmp1
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcword = OPSEL[0].i32 * 16
  src = VGPR[laneId][SRC0.u32][srcword + 15 : srcword].b16
  D0[31 : 0].f32 = tmp0
  D0[63 : 32].f32 = tmp1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_F32_BF8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcword = OPSEL[0].i32 * 16;
  # src = VGPR[laneId][SRC0.u32][srcword + 15 : srcword].b16;
  # D0[31 : 0].f32 = tmp0;
  # D0[63 : 32].f32 = tmp1
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcword = OPSEL[0].i32 * 16
  src = VGPR[laneId][SRC0.u32][srcword + 15 : srcword].b16
  D0[31 : 0].f32 = tmp0
  D0[63 : 32].f32 = tmp1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_F32_FP8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcbyte = OPSEL[1 : 0].i32 * 8;
  # src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].fp8;
  # tmp = fp8_to_f32_scale(src, scale.u8);
  S1 = Reg(s1)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcbyte = OPSEL[1 : 0].i32 * 8
  src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].fp8
  tmp = Reg(fp8_to_f32_scale(src, scale.u8))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_F32_BF8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcbyte = OPSEL[1 : 0].i32 * 8;
  # src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].bf8;
  # tmp = bf8_to_f32_scale(src, scale.u8);
  S1 = Reg(s1)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcbyte = OPSEL[1 : 0].i32 * 8
  src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].bf8
  tmp = Reg(bf8_to_f32_scale(src, scale.u8))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_FP4_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # tmp0 = f32_to_fp4_scale(S0.f32, scale.u8);
  # tmp1 = f32_to_fp4_scale(S1.f32, scale.u8);
  # dstbyte = OPSEL[3 : 2].i32 * 8;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  tmp0 = f32_to_fp4_scale(S0.f32, scale.u8)
  tmp1 = f32_to_fp4_scale(S1.f32, scale.u8)
  dstbyte = OPSEL[3 : 2].i32 * 8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_PK_FP4_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # randomVal = S1.u32;
  # tmp0 = f32_to_fp4_sr_scale(S0[31 : 0].f32, randomVal, scale.u8);
  # tmp1 = f32_to_fp4_sr_scale(S0[63 : 32].f32, randomVal, scale.u8);
  # dstbyte = OPSEL[3 : 2].i32 * 8;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  randomVal = S1.u32
  tmp0 = f32_to_fp4_sr_scale(S0[31 : 0].f32, randomVal, scale.u8)
  tmp1 = f32_to_fp4_sr_scale(S0[63 : 32].f32, randomVal, scale.u8)
  dstbyte = OPSEL[3 : 2].i32 * 8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_F32_FP4(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcbyte = OPSEL[1 : 0].i32 * 8;
  # src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].b8;
  # D0[31 : 0].f32 = tmp0;
  # D0[63 : 32].f32 = tmp1
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcbyte = OPSEL[1 : 0].i32 * 8
  src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].b8
  D0[31 : 0].f32 = tmp0
  D0[63 : 32].f32 = tmp1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_FP8_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # tmp0 = f16_to_fp8_scale(S0[15 : 0].f16, scale.u8);
  # tmp1 = f16_to_fp8_scale(S0[31 : 16].f16, scale.u8);
  # dstword = OPSEL[3].i32 * 16;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  tmp0 = f16_to_fp8_scale(S0[15 : 0].f16, scale.u8)
  tmp1 = f16_to_fp8_scale(S0[31 : 16].f16, scale.u8)
  dstword = OPSEL[3].i32 * 16
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_BF8_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # tmp0 = f16_to_bf8_scale(S0[15 : 0].f16, scale.u8);
  # tmp1 = f16_to_bf8_scale(S0[31 : 16].f16, scale.u8);
  # dstword = OPSEL[3].i32 * 16;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  tmp0 = f16_to_bf8_scale(S0[15 : 0].f16, scale.u8)
  tmp1 = f16_to_bf8_scale(S0[31 : 16].f16, scale.u8)
  dstword = OPSEL[3].i32 * 16
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_FP8_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # tmp = f16_to_fp8_sr_scale(S0.f16, S1.u32, scale.u8);
  # dstbyte = OPSEL[3 : 2].i32 * 8;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  tmp = Reg(f16_to_fp8_sr_scale(S0.f16, S1.u32, scale.u8))
  dstbyte = OPSEL[3 : 2].i32 * 8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_BF8_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # tmp = f16_to_bf8_sr_scale(S0.f16, S1.u32, scale.u8);
  # dstbyte = OPSEL[3 : 2].i32 * 8;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  tmp = Reg(f16_to_bf8_sr_scale(S0.f16, S1.u32, scale.u8))
  dstbyte = OPSEL[3 : 2].i32 * 8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_F16_FP8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcword = OPSEL[0].i32 * 16;
  # src = VGPR[laneId][SRC0.u32][srcword + 15 : srcword].b16;
  # D0[15 : 0].f16 = tmp0;
  # D0[31 : 16].f16 = tmp1
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcword = OPSEL[0].i32 * 16
  src = VGPR[laneId][SRC0.u32][srcword + 15 : srcword].b16
  D0[15 : 0].f16 = tmp0
  D0[31 : 16].f16 = tmp1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_F16_BF8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcword = OPSEL[0].i32 * 16;
  # src = VGPR[laneId][SRC0.u32][srcword + 15 : srcword].b16;
  # D0[15 : 0].f16 = tmp0;
  # D0[31 : 16].f16 = tmp1
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcword = OPSEL[0].i32 * 16
  src = VGPR[laneId][SRC0.u32][srcword + 15 : srcword].b16
  D0[15 : 0].f16 = tmp0
  D0[31 : 16].f16 = tmp1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_F16_FP8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcbyte = OPSEL[1 : 0].i32 * 8;
  # src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].fp8;
  # tmp = fp8_to_f16_scale(src, scale.u8);
  # // OPSEL[3] controls destination hi/lo
  S1 = Reg(s1)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcbyte = OPSEL[1 : 0].i32 * 8
  src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].fp8
  tmp = Reg(fp8_to_f16_scale(src, scale.u8))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_F16_BF8(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcbyte = OPSEL[1 : 0].i32 * 8;
  # src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].bf8;
  # tmp = bf8_to_f16_scale(src, scale.u8);
  # // OPSEL[3] controls destination hi/lo
  S1 = Reg(s1)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcbyte = OPSEL[1 : 0].i32 * 8
  src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].bf8
  tmp = Reg(bf8_to_f16_scale(src, scale.u8))
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_FP4_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # tmp0 = f16_to_fp4_scale(S0[15 : 0].f16, scale.u8);
  # tmp1 = f16_to_fp4_scale(S0[31 : 16].f16, scale.u8);
  # dstbyte = OPSEL[3 : 2].i32 * 8;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  tmp0 = f16_to_fp4_scale(S0[15 : 0].f16, scale.u8)
  tmp1 = f16_to_fp4_scale(S0[31 : 16].f16, scale.u8)
  dstbyte = OPSEL[3 : 2].i32 * 8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_PK_FP4_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # randomVal = S1.u32;
  # tmp0 = f16_to_fp4_sr_scale(S0[15 : 0].f16, randomVal, scale.u8);
  # tmp1 = f16_to_fp4_sr_scale(S0[31 : 16].f16, randomVal, scale.u8);
  # dstbyte = OPSEL[3 : 2].i32 * 8;
  # // Other destination bits are preserved
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  randomVal = S1.u32
  tmp0 = f16_to_fp4_sr_scale(S0[15 : 0].f16, randomVal, scale.u8)
  tmp1 = f16_to_fp4_sr_scale(S0[31 : 16].f16, randomVal, scale.u8)
  dstbyte = OPSEL[3 : 2].i32 * 8
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK_F16_FP4(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # srcbyte = OPSEL[1 : 0].i32 * 8;
  # src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].b8;
  # D0[15 : 0].f16 = tmp0;
  # D0[31 : 16].f16 = tmp1
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  laneId = lane
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  srcbyte = OPSEL[1 : 0].i32 * 8
  src = VGPR[laneId][SRC0.u32][srcbyte + 7 : srcbyte].b8
  D0[15 : 0].f16 = tmp0
  D0[31 : 16].f16 = tmp1
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_2XPK16_FP6_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # declare tmp : 192'B;
  # for pass in 0 : 15 do
  # // Note that S0 and S1 inputs are interleaved in the packed result.
  # tmp[dOffset + 5 : dOffset].fp6 = f32_to_fp6_scale(S0[sOffset + 31 : sOffset].f32, scale.u8);
  # tmp[dOffset + 11 : dOffset + 6].fp6 = f32_to_fp6_scale(S1[sOffset + 31 : sOffset].f32, scale.u8)
  # endfor;
  # D0[191 : 0] = tmp.b192
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  for pass in range(0, int(15)+1):
    tmp[dOffset + 5 : dOffset].fp6 = f32_to_fp6_scale(S0[sOffset + 31 : sOffset].f32, scale.u8)
    tmp[dOffset + 11 : dOffset + 6].fp6 = f32_to_fp6_scale(S1[sOffset + 31 : sOffset].f32, scale.u8)
  D0[191 : 0] = tmp.b192
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_2XPK16_BF6_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # declare tmp : 192'B;
  # for pass in 0 : 15 do
  # // Note that S0 and S1 inputs are interleaved in the packed result.
  # tmp[dOffset + 5 : dOffset].bf6 = f32_to_bf6_scale(S0[sOffset + 31 : sOffset].f32, scale.u8);
  # tmp[dOffset + 11 : dOffset + 6].bf6 = f32_to_bf6_scale(S1[sOffset + 31 : sOffset].f32, scale.u8)
  # endfor;
  # D0[191 : 0] = tmp.b192
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  for pass in range(0, int(15)+1):
    tmp[dOffset + 5 : dOffset].bf6 = f32_to_bf6_scale(S0[sOffset + 31 : sOffset].f32, scale.u8)
    tmp[dOffset + 11 : dOffset + 6].bf6 = f32_to_bf6_scale(S1[sOffset + 31 : sOffset].f32, scale.u8)
  D0[191 : 0] = tmp.b192
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_PK32_FP6_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # randomVal = S1.u32;
  # declare tmp : 192'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 5 : dOffset].fp6 = f32_to_fp6_sr_scale(S0[sOffset + 31 : sOffset].f32, randomVal,
  # endfor;
  # D0[191 : 0] = tmp.b192
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  randomVal = S1.u32
  for pass in range(0, int(31)+1):
    tmp[dOffset + 5 : dOffset].fp6 = f32_to_fp6_sr_scale(S0[sOffset + 31 : sOffset].f32, randomVal, endfor; D0[191 : 0] = tmp.b192
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_PK32_BF6_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # randomVal = S1.u32;
  # declare tmp : 192'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 5 : dOffset].bf6 = f32_to_bf6_sr_scale(S0[sOffset + 31 : sOffset].f32, randomVal,
  # endfor;
  # D0[191 : 0] = tmp.b192
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  randomVal = S1.u32
  for pass in range(0, int(31)+1):
    tmp[dOffset + 5 : dOffset].bf6 = f32_to_bf6_sr_scale(S0[sOffset + 31 : sOffset].f32, randomVal, endfor; D0[191 : 0] = tmp.b192
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK32_F32_FP6(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # declare tmp : 1024'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 31 : dOffset].f32 = fp6_to_f32_scale(S0[sOffset + 5 : sOffset].fp6, scale.u8)
  # endfor;
  # D0[1023 : 0] = tmp.b1024
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  for pass in range(0, int(31)+1):
    tmp[dOffset + 31 : dOffset].f32 = fp6_to_f32_scale(S0[sOffset + 5 : sOffset].fp6, scale.u8)
  D0[1023 : 0] = tmp.b1024
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK32_F32_BF6(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # declare tmp : 1024'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 31 : dOffset].f32 = bf6_to_f32_scale(S0[sOffset + 5 : sOffset].bf6, scale.u8)
  # endfor;
  # D0[1023 : 0] = tmp.b1024
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  for pass in range(0, int(31)+1):
    tmp[dOffset + 31 : dOffset].f32 = bf6_to_f32_scale(S0[sOffset + 5 : sOffset].bf6, scale.u8)
  D0[1023 : 0] = tmp.b1024
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK32_BF6_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # declare tmp : 192'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 5 : dOffset].bf6 = f16_to_bf6_scale(S0[sOffset + 15 : sOffset].f16, scale.u8)
  # endfor;
  # D0[191 : 0] = tmp.b192
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  for pass in range(0, int(31)+1):
    tmp[dOffset + 5 : dOffset].bf6 = f16_to_bf6_scale(S0[sOffset + 15 : sOffset].f16, scale.u8)
  D0[191 : 0] = tmp.b192
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_PK32_FP6_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # randomVal = S1.u32;
  # declare tmp : 192'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 5 : dOffset].fp6 = f16_to_fp6_sr_scale(S0[sOffset + 15 : sOffset].f16, randomVal,
  # endfor;
  # D0[191 : 0] = tmp.b192
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  randomVal = S1.u32
  for pass in range(0, int(31)+1):
    tmp[dOffset + 5 : dOffset].fp6 = f16_to_fp6_sr_scale(S0[sOffset + 15 : sOffset].f16, randomVal, endfor; D0[191 : 0] = tmp.b192
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_SR_PK32_BF6_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S2.f32));
  # randomVal = S1.u32;
  # declare tmp : 192'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 5 : dOffset].bf6 = f16_to_bf6_sr_scale(S0[sOffset + 15 : sOffset].f16, randomVal,
  # endfor;
  # D0[191 : 0] = tmp.b192
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S2.f32))
  randomVal = S1.u32
  for pass in range(0, int(31)+1):
    tmp[dOffset + 5 : dOffset].bf6 = f16_to_bf6_sr_scale(S0[sOffset + 15 : sOffset].f16, randomVal, endfor; D0[191 : 0] = tmp.b192
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK32_F16_FP6(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # declare tmp : 512'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 15 : dOffset].f16 = fp6_to_f16_scale(S0[sOffset + 5 : sOffset].fp6, scale.u8)
  # endfor;
  # D0[511 : 0] = tmp.b512
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  for pass in range(0, int(31)+1):
    tmp[dOffset + 15 : dOffset].f16 = fp6_to_f16_scale(S0[sOffset + 5 : sOffset].fp6, scale.u8)
  D0[511 : 0] = tmp.b512
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_SCALEF32_PK32_F16_BF6(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # scale = 32'U(exponent(S1.f32));
  # declare tmp : 512'B;
  # for pass in 0 : 31 do
  # tmp[dOffset + 15 : dOffset].f16 = bf6_to_f16_scale(S0[sOffset + 5 : sOffset].bf6, scale.u8)
  # endfor;
  # D0[511 : 0] = tmp.b512
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  scale = (exponent(S1.f32))
  for pass in range(0, int(31)+1):
    tmp[dOffset + 15 : dOffset].f16 = bf6_to_f16_scale(S0[sOffset + 5 : sOffset].bf6, scale.u8)
  D0[511 : 0] = tmp.b512
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ASHR_PK_I8_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if n <= -128 then
  # elsif n >= 127 then
  # else
  # endif);
  # declare tmp : 16'B;
  # tmp[7 : 0] = SAT8(S0.i32 >> S2[4 : 0].u32);
  # tmp[15 : 8] = SAT8(S1.i32 >> S2[4 : 0].u32);
  # D0[15 : 0] = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  if n <= -128:
    pass
  elif n >= 127:
    pass
  else:
    pass
  tmp[7 : 0] = SAT8(S0.i32 >> S2[4 : 0].u32)
  tmp[15 : 8] = SAT8(S1.i32 >> S2[4 : 0].u32)
  D0[15 : 0] = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ASHR_PK_U8_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if n <= 0 then
  # elsif n >= 255 then
  # else
  # endif);
  # declare tmp : 16'B;
  # tmp[7 : 0] = SAT8(S0.i32 >> S2[4 : 0].u32);
  # tmp[15 : 8] = SAT8(S1.i32 >> S2[4 : 0].u32);
  # D0[15 : 0] = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  if n <= 0:
    pass
  elif n >= 255:
    pass
  else:
    pass
  tmp[7 : 0] = SAT8(S0.i32 >> S2[4 : 0].u32)
  tmp[15 : 8] = SAT8(S1.i32 >> S2[4 : 0].u32)
  D0[15 : 0] = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PK_F16_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # prev_mode = ROUND_MODE;
  # tmp[15 : 0].f16 = f32_to_f16(S0.f32);
  # tmp[31 : 16].f16 = f32_to_f16(S1.f32);
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  prev_mode = ROUND_MODE
  tmp[15 : 0].f16 = f32_to_f16(S0.f32)
  tmp[31 : 16].f16 = f32_to_f16(S1.f32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ADD_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = S0.f64 + S1.f64
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = S0.f64 + S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_MUL_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = S0.f64 * S1.f64
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = S0.f64 * S1.f64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_MIN_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(S0.f64)) then
  # D0.f64 = cvtToQuietNAN(S0.f64)
  # elsif (WAVE_MODE.IEEE && isSignalNAN(S1.f64)) then
  # D0.f64 = cvtToQuietNAN(S1.f64)
  # elsif isNAN(S0.f64) then
  # D0.f64 = S1.f64
  # elsif isNAN(S1.f64) then
  # D0.f64 = S0.f64
  # elsif ((S0.f64 == +0.0) && (S1.f64 == -0.0)) then
  # D0.f64 = S1.f64
  # elsif ((S0.f64 == -0.0) && (S1.f64 == +0.0)) then
  # D0.f64 = S0.f64
  # else
  # D0.f64 = S0.f64 < S1.f64 ? S0.f64 : S1.f64
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(S0.f64)):
    D0.f64 = cvtToQuietNAN(S0.f64)
  elif (WAVE_MODE.IEEE  and  isSignalNAN(S1.f64)):
    D0.f64 = cvtToQuietNAN(S1.f64)
  elif isNAN(S0.f64):
    D0.f64 = S1.f64
  elif isNAN(S1.f64):
    D0.f64 = S0.f64
  elif ((S0.f64 == +0.0)  and  (S1.f64 == -0.0)):
    D0.f64 = S1.f64
  elif ((S0.f64 == -0.0)  and  (S1.f64 == +0.0)):
    D0.f64 = S0.f64
  else:
    D0.f64 = ((S0.f64) if (S0.f64 < S1.f64) else (S1.f64))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_MAX_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if (WAVE_MODE.IEEE && isSignalNAN(S0.f64)) then
  # D0.f64 = cvtToQuietNAN(S0.f64)
  # elsif (WAVE_MODE.IEEE && isSignalNAN(S1.f64)) then
  # D0.f64 = cvtToQuietNAN(S1.f64)
  # elsif isNAN(S0.f64) then
  # D0.f64 = S1.f64
  # elsif isNAN(S1.f64) then
  # D0.f64 = S0.f64
  # elsif ((S0.f64 == +0.0) && (S1.f64 == -0.0)) then
  # D0.f64 = S0.f64
  # elsif ((S0.f64 == -0.0) && (S1.f64 == +0.0)) then
  # D0.f64 = S1.f64
  # elsif WAVE_MODE.IEEE then
  # D0.f64 = S0.f64 >= S1.f64 ? S0.f64 : S1.f64
  # else
  # D0.f64 = S0.f64 > S1.f64 ? S0.f64 : S1.f64
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if (WAVE_MODE.IEEE  and  isSignalNAN(S0.f64)):
    D0.f64 = cvtToQuietNAN(S0.f64)
  elif (WAVE_MODE.IEEE  and  isSignalNAN(S1.f64)):
    D0.f64 = cvtToQuietNAN(S1.f64)
  elif isNAN(S0.f64):
    D0.f64 = S1.f64
  elif isNAN(S1.f64):
    D0.f64 = S0.f64
  elif ((S0.f64 == +0.0)  and  (S1.f64 == -0.0)):
    D0.f64 = S0.f64
  elif ((S0.f64 == -0.0)  and  (S1.f64 == +0.0)):
    D0.f64 = S1.f64
  elif WAVE_MODE.IEEE:
    D0.f64 = ((S0.f64) if (S0.f64 >= S1.f64) else (S1.f64))
  else:
    D0.f64 = ((S0.f64) if (S0.f64 > S1.f64) else (S1.f64))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_LDEXP_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = S0.f64 * 2.0 ** S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = S0.f64 * 2.0 ** S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_MUL_LO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = S0.u32 * S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = S0.u32 * S1.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_HI_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = 32'U((64'U(S0.u32) * 64'U(S1.u32)) >> 32U)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (((S0.u32) * (S1.u32)) >> 32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_HI_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I((64'I(S0.i32) * 64'I(S1.i32)) >> 32U)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (((S0.i32) * (S1.i32)) >> 32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LDEXP_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = S0.f32 * 2.0F ** S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = S0.f32 * 2.0 ** S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_READLANE_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # lane = S1.u32[5 : 0];
  # // Lane select
  # D0.b32 = VGPR[lane][SRC0.u32]
  S1 = Reg(s1)
  D0 = Reg(d0)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  lane = S1.u32[5 : 0]
  D0.b32 = VGPR[lane][SRC0.u32]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_BCNT_U32_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S1.u32;
  # for i in 0 : 31 do
  # tmp += S0[i].u32;
  # // count i'th bit
  # endfor;
  # D0.u32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S1.u32)
  for i in range(0, int(31)+1):
    tmp += S0[i].u32
  D0.u32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_LSHLREV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S1.u64 << S0[5 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u64 = (S1.u64 << S0[5 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_LSHRREV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u64 = (S1.u64 >> S0[5 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u64 = (S1.u64 >> S0[5 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_ASHRREV_I64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i64 = (S1.i64 >> S0[5 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i64 = (S1.i64 >> S0[5 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3AOp_V_BFM_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = (((1U << S0[4 : 0].u32) - 1U) << S1[4 : 0].u32)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = (((1 << S0[4 : 0].u32) - 1) << S1[4 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PKNORM_I16_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = f32_to_snorm(S0.f32);
  # tmp[31 : 16].i16 = f32_to_snorm(S1.f32);
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = f32_to_snorm(S0.f32)
  tmp[31 : 16].i16 = f32_to_snorm(S1.f32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PKNORM_U16_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = f32_to_unorm(S0.f32);
  # tmp[31 : 16].u16 = f32_to_unorm(S1.f32);
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = f32_to_unorm(S0.f32)
  tmp[31 : 16].u16 = f32_to_unorm(S1.f32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PKRTZ_F16_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # prev_mode = ROUND_MODE;
  # tmp[15 : 0].f16 = f32_to_f16(S0.f32);
  # tmp[31 : 16].f16 = f32_to_f16(S1.f32);
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  prev_mode = ROUND_MODE
  tmp[15 : 0].f16 = f32_to_f16(S0.f32)
  tmp[31 : 16].f16 = f32_to_f16(S1.f32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PK_U16_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = u32_to_u16(S0.u32);
  # tmp[31 : 16].u16 = u32_to_u16(S1.u32);
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = u32_to_u16(S0.u32)
  tmp[31 : 16].u16 = u32_to_u16(S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PK_I16_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = i32_to_i16(S0.i32);
  # tmp[31 : 16].i16 = i32_to_i16(S1.i32);
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = i32_to_i16(S0.i32)
  tmp[31 : 16].i16 = i32_to_i16(S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PKNORM_I16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = f16_to_snorm(S0.f16);
  # tmp[31 : 16].i16 = f16_to_snorm(S1.f16);
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = f16_to_snorm(S0.f16)
  tmp[31 : 16].i16 = f16_to_snorm(S1.f16)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_CVT_PKNORM_U16_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = f16_to_unorm(S0.f16);
  # tmp[31 : 16].u16 = f16_to_unorm(S1.f16);
  S0 = Reg(s0)
  S1 = Reg(s1)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = f16_to_unorm(S0.f16)
  tmp[31 : 16].u16 = f16_to_unorm(S1.f16)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ADD_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 + S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = S0.i32 + S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUB_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = S0.i32 - S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = S0.i32 - S1.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_ADD_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = S0.i16 + S1.i16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = S0.i16 + S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_SUB_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i16 = S0.i16 - S1.i16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i16 = S0.i16 - S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_PACK_B32_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0[31 : 16].f16 = S1.f16;
  # D0[15 : 0].f16 = S0.f16
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0[31 : 16].f16 = S1.f16
  D0[15 : 0].f16 = S0.f16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MUL_LEGACY_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then
  # // DX9 rules, 0.0 * x = 0.0
  # D0.f32 = 0.0F
  # else
  # D0.f32 = S0.f32 * S1.f32
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  if ((F(S0.f32) == 0.0)  or  (F(S1.f32) == 0.0)):
    D0.f32 = 0.0
  else:
    D0.f32 = S0.f32 * S1.f32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MINIMUM3_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 32'F(v_minimum_f32(v_minimum_f32(S0.f32, S1.f32), S2.f32))
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = F(v_minimum_f32(v_minimum_f32(S0.f32, S1.f32), S2.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3AOp_V_MAXIMUM3_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = 32'F(v_maximum_f32(v_maximum_f32(S0.f32, S1.f32), S2.f32))
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = F(v_maximum_f32(v_maximum_f32(S0.f32, S1.f32), S2.f32))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

VOP3AOp_FUNCTIONS = {
  VOP3AOp.V_CMP_CLASS_F32: _VOP3AOp_V_CMP_CLASS_F32,
  VOP3AOp.V_CMPX_CLASS_F32: _VOP3AOp_V_CMPX_CLASS_F32,
  VOP3AOp.V_CMP_CLASS_F64: _VOP3AOp_V_CMP_CLASS_F64,
  VOP3AOp.V_CMPX_CLASS_F64: _VOP3AOp_V_CMPX_CLASS_F64,
  VOP3AOp.V_CMP_CLASS_F16: _VOP3AOp_V_CMP_CLASS_F16,
  VOP3AOp.V_CMPX_CLASS_F16: _VOP3AOp_V_CMPX_CLASS_F16,
  VOP3AOp.V_CMP_F_F16: _VOP3AOp_V_CMP_F_F16,
  VOP3AOp.V_CMP_LT_F16: _VOP3AOp_V_CMP_LT_F16,
  VOP3AOp.V_CMP_EQ_F16: _VOP3AOp_V_CMP_EQ_F16,
  VOP3AOp.V_CMP_LE_F16: _VOP3AOp_V_CMP_LE_F16,
  VOP3AOp.V_CMP_GT_F16: _VOP3AOp_V_CMP_GT_F16,
  VOP3AOp.V_CMP_LG_F16: _VOP3AOp_V_CMP_LG_F16,
  VOP3AOp.V_CMP_GE_F16: _VOP3AOp_V_CMP_GE_F16,
  VOP3AOp.V_CMP_O_F16: _VOP3AOp_V_CMP_O_F16,
  VOP3AOp.V_CMP_U_F16: _VOP3AOp_V_CMP_U_F16,
  VOP3AOp.V_CMP_NGE_F16: _VOP3AOp_V_CMP_NGE_F16,
  VOP3AOp.V_CMP_NLG_F16: _VOP3AOp_V_CMP_NLG_F16,
  VOP3AOp.V_CMP_NGT_F16: _VOP3AOp_V_CMP_NGT_F16,
  VOP3AOp.V_CMP_NLE_F16: _VOP3AOp_V_CMP_NLE_F16,
  VOP3AOp.V_CMP_NEQ_F16: _VOP3AOp_V_CMP_NEQ_F16,
  VOP3AOp.V_CMP_NLT_F16: _VOP3AOp_V_CMP_NLT_F16,
  VOP3AOp.V_CMP_TRU_F16: _VOP3AOp_V_CMP_TRU_F16,
  VOP3AOp.V_CMPX_F_F16: _VOP3AOp_V_CMPX_F_F16,
  VOP3AOp.V_CMPX_LT_F16: _VOP3AOp_V_CMPX_LT_F16,
  VOP3AOp.V_CMPX_EQ_F16: _VOP3AOp_V_CMPX_EQ_F16,
  VOP3AOp.V_CMPX_LE_F16: _VOP3AOp_V_CMPX_LE_F16,
  VOP3AOp.V_CMPX_GT_F16: _VOP3AOp_V_CMPX_GT_F16,
  VOP3AOp.V_CMPX_LG_F16: _VOP3AOp_V_CMPX_LG_F16,
  VOP3AOp.V_CMPX_GE_F16: _VOP3AOp_V_CMPX_GE_F16,
  VOP3AOp.V_CMPX_O_F16: _VOP3AOp_V_CMPX_O_F16,
  VOP3AOp.V_CMPX_U_F16: _VOP3AOp_V_CMPX_U_F16,
  VOP3AOp.V_CMPX_NGE_F16: _VOP3AOp_V_CMPX_NGE_F16,
  VOP3AOp.V_CMPX_NLG_F16: _VOP3AOp_V_CMPX_NLG_F16,
  VOP3AOp.V_CMPX_NGT_F16: _VOP3AOp_V_CMPX_NGT_F16,
  VOP3AOp.V_CMPX_NLE_F16: _VOP3AOp_V_CMPX_NLE_F16,
  VOP3AOp.V_CMPX_NEQ_F16: _VOP3AOp_V_CMPX_NEQ_F16,
  VOP3AOp.V_CMPX_NLT_F16: _VOP3AOp_V_CMPX_NLT_F16,
  VOP3AOp.V_CMPX_TRU_F16: _VOP3AOp_V_CMPX_TRU_F16,
  VOP3AOp.V_CMP_F_F32: _VOP3AOp_V_CMP_F_F32,
  VOP3AOp.V_CMP_LT_F32: _VOP3AOp_V_CMP_LT_F32,
  VOP3AOp.V_CMP_EQ_F32: _VOP3AOp_V_CMP_EQ_F32,
  VOP3AOp.V_CMP_LE_F32: _VOP3AOp_V_CMP_LE_F32,
  VOP3AOp.V_CMP_GT_F32: _VOP3AOp_V_CMP_GT_F32,
  VOP3AOp.V_CMP_LG_F32: _VOP3AOp_V_CMP_LG_F32,
  VOP3AOp.V_CMP_GE_F32: _VOP3AOp_V_CMP_GE_F32,
  VOP3AOp.V_CMP_O_F32: _VOP3AOp_V_CMP_O_F32,
  VOP3AOp.V_CMP_U_F32: _VOP3AOp_V_CMP_U_F32,
  VOP3AOp.V_CMP_NGE_F32: _VOP3AOp_V_CMP_NGE_F32,
  VOP3AOp.V_CMP_NLG_F32: _VOP3AOp_V_CMP_NLG_F32,
  VOP3AOp.V_CMP_NGT_F32: _VOP3AOp_V_CMP_NGT_F32,
  VOP3AOp.V_CMP_NLE_F32: _VOP3AOp_V_CMP_NLE_F32,
  VOP3AOp.V_CMP_NEQ_F32: _VOP3AOp_V_CMP_NEQ_F32,
  VOP3AOp.V_CMP_NLT_F32: _VOP3AOp_V_CMP_NLT_F32,
  VOP3AOp.V_CMP_TRU_F32: _VOP3AOp_V_CMP_TRU_F32,
  VOP3AOp.V_CMPX_F_F32: _VOP3AOp_V_CMPX_F_F32,
  VOP3AOp.V_CMPX_LT_F32: _VOP3AOp_V_CMPX_LT_F32,
  VOP3AOp.V_CMPX_EQ_F32: _VOP3AOp_V_CMPX_EQ_F32,
  VOP3AOp.V_CMPX_LE_F32: _VOP3AOp_V_CMPX_LE_F32,
  VOP3AOp.V_CMPX_GT_F32: _VOP3AOp_V_CMPX_GT_F32,
  VOP3AOp.V_CMPX_LG_F32: _VOP3AOp_V_CMPX_LG_F32,
  VOP3AOp.V_CMPX_GE_F32: _VOP3AOp_V_CMPX_GE_F32,
  VOP3AOp.V_CMPX_O_F32: _VOP3AOp_V_CMPX_O_F32,
  VOP3AOp.V_CMPX_U_F32: _VOP3AOp_V_CMPX_U_F32,
  VOP3AOp.V_CMPX_NGE_F32: _VOP3AOp_V_CMPX_NGE_F32,
  VOP3AOp.V_CMPX_NLG_F32: _VOP3AOp_V_CMPX_NLG_F32,
  VOP3AOp.V_CMPX_NGT_F32: _VOP3AOp_V_CMPX_NGT_F32,
  VOP3AOp.V_CMPX_NLE_F32: _VOP3AOp_V_CMPX_NLE_F32,
  VOP3AOp.V_CMPX_NEQ_F32: _VOP3AOp_V_CMPX_NEQ_F32,
  VOP3AOp.V_CMPX_NLT_F32: _VOP3AOp_V_CMPX_NLT_F32,
  VOP3AOp.V_CMPX_TRU_F32: _VOP3AOp_V_CMPX_TRU_F32,
  VOP3AOp.V_CMP_F_F64: _VOP3AOp_V_CMP_F_F64,
  VOP3AOp.V_CMP_LT_F64: _VOP3AOp_V_CMP_LT_F64,
  VOP3AOp.V_CMP_EQ_F64: _VOP3AOp_V_CMP_EQ_F64,
  VOP3AOp.V_CMP_LE_F64: _VOP3AOp_V_CMP_LE_F64,
  VOP3AOp.V_CMP_GT_F64: _VOP3AOp_V_CMP_GT_F64,
  VOP3AOp.V_CMP_LG_F64: _VOP3AOp_V_CMP_LG_F64,
  VOP3AOp.V_CMP_GE_F64: _VOP3AOp_V_CMP_GE_F64,
  VOP3AOp.V_CMP_O_F64: _VOP3AOp_V_CMP_O_F64,
  VOP3AOp.V_CMP_U_F64: _VOP3AOp_V_CMP_U_F64,
  VOP3AOp.V_CMP_NGE_F64: _VOP3AOp_V_CMP_NGE_F64,
  VOP3AOp.V_CMP_NLG_F64: _VOP3AOp_V_CMP_NLG_F64,
  VOP3AOp.V_CMP_NGT_F64: _VOP3AOp_V_CMP_NGT_F64,
  VOP3AOp.V_CMP_NLE_F64: _VOP3AOp_V_CMP_NLE_F64,
  VOP3AOp.V_CMP_NEQ_F64: _VOP3AOp_V_CMP_NEQ_F64,
  VOP3AOp.V_CMP_NLT_F64: _VOP3AOp_V_CMP_NLT_F64,
  VOP3AOp.V_CMP_TRU_F64: _VOP3AOp_V_CMP_TRU_F64,
  VOP3AOp.V_CMPX_F_F64: _VOP3AOp_V_CMPX_F_F64,
  VOP3AOp.V_CMPX_LT_F64: _VOP3AOp_V_CMPX_LT_F64,
  VOP3AOp.V_CMPX_EQ_F64: _VOP3AOp_V_CMPX_EQ_F64,
  VOP3AOp.V_CMPX_LE_F64: _VOP3AOp_V_CMPX_LE_F64,
  VOP3AOp.V_CMPX_GT_F64: _VOP3AOp_V_CMPX_GT_F64,
  VOP3AOp.V_CMPX_LG_F64: _VOP3AOp_V_CMPX_LG_F64,
  VOP3AOp.V_CMPX_GE_F64: _VOP3AOp_V_CMPX_GE_F64,
  VOP3AOp.V_CMPX_O_F64: _VOP3AOp_V_CMPX_O_F64,
  VOP3AOp.V_CMPX_U_F64: _VOP3AOp_V_CMPX_U_F64,
  VOP3AOp.V_CMPX_NGE_F64: _VOP3AOp_V_CMPX_NGE_F64,
  VOP3AOp.V_CMPX_NLG_F64: _VOP3AOp_V_CMPX_NLG_F64,
  VOP3AOp.V_CMPX_NGT_F64: _VOP3AOp_V_CMPX_NGT_F64,
  VOP3AOp.V_CMPX_NLE_F64: _VOP3AOp_V_CMPX_NLE_F64,
  VOP3AOp.V_CMPX_NEQ_F64: _VOP3AOp_V_CMPX_NEQ_F64,
  VOP3AOp.V_CMPX_NLT_F64: _VOP3AOp_V_CMPX_NLT_F64,
  VOP3AOp.V_CMPX_TRU_F64: _VOP3AOp_V_CMPX_TRU_F64,
  VOP3AOp.V_CMP_F_I16: _VOP3AOp_V_CMP_F_I16,
  VOP3AOp.V_CMP_LT_I16: _VOP3AOp_V_CMP_LT_I16,
  VOP3AOp.V_CMP_EQ_I16: _VOP3AOp_V_CMP_EQ_I16,
  VOP3AOp.V_CMP_LE_I16: _VOP3AOp_V_CMP_LE_I16,
  VOP3AOp.V_CMP_GT_I16: _VOP3AOp_V_CMP_GT_I16,
  VOP3AOp.V_CMP_NE_I16: _VOP3AOp_V_CMP_NE_I16,
  VOP3AOp.V_CMP_GE_I16: _VOP3AOp_V_CMP_GE_I16,
  VOP3AOp.V_CMP_T_I16: _VOP3AOp_V_CMP_T_I16,
  VOP3AOp.V_CMP_F_U16: _VOP3AOp_V_CMP_F_U16,
  VOP3AOp.V_CMP_LT_U16: _VOP3AOp_V_CMP_LT_U16,
  VOP3AOp.V_CMP_EQ_U16: _VOP3AOp_V_CMP_EQ_U16,
  VOP3AOp.V_CMP_LE_U16: _VOP3AOp_V_CMP_LE_U16,
  VOP3AOp.V_CMP_GT_U16: _VOP3AOp_V_CMP_GT_U16,
  VOP3AOp.V_CMP_NE_U16: _VOP3AOp_V_CMP_NE_U16,
  VOP3AOp.V_CMP_GE_U16: _VOP3AOp_V_CMP_GE_U16,
  VOP3AOp.V_CMP_T_U16: _VOP3AOp_V_CMP_T_U16,
  VOP3AOp.V_CMPX_F_I16: _VOP3AOp_V_CMPX_F_I16,
  VOP3AOp.V_CMPX_LT_I16: _VOP3AOp_V_CMPX_LT_I16,
  VOP3AOp.V_CMPX_EQ_I16: _VOP3AOp_V_CMPX_EQ_I16,
  VOP3AOp.V_CMPX_LE_I16: _VOP3AOp_V_CMPX_LE_I16,
  VOP3AOp.V_CMPX_GT_I16: _VOP3AOp_V_CMPX_GT_I16,
  VOP3AOp.V_CMPX_NE_I16: _VOP3AOp_V_CMPX_NE_I16,
  VOP3AOp.V_CMPX_GE_I16: _VOP3AOp_V_CMPX_GE_I16,
  VOP3AOp.V_CMPX_T_I16: _VOP3AOp_V_CMPX_T_I16,
  VOP3AOp.V_CMPX_F_U16: _VOP3AOp_V_CMPX_F_U16,
  VOP3AOp.V_CMPX_LT_U16: _VOP3AOp_V_CMPX_LT_U16,
  VOP3AOp.V_CMPX_EQ_U16: _VOP3AOp_V_CMPX_EQ_U16,
  VOP3AOp.V_CMPX_LE_U16: _VOP3AOp_V_CMPX_LE_U16,
  VOP3AOp.V_CMPX_GT_U16: _VOP3AOp_V_CMPX_GT_U16,
  VOP3AOp.V_CMPX_NE_U16: _VOP3AOp_V_CMPX_NE_U16,
  VOP3AOp.V_CMPX_GE_U16: _VOP3AOp_V_CMPX_GE_U16,
  VOP3AOp.V_CMPX_T_U16: _VOP3AOp_V_CMPX_T_U16,
  VOP3AOp.V_CMP_F_I32: _VOP3AOp_V_CMP_F_I32,
  VOP3AOp.V_CMP_LT_I32: _VOP3AOp_V_CMP_LT_I32,
  VOP3AOp.V_CMP_EQ_I32: _VOP3AOp_V_CMP_EQ_I32,
  VOP3AOp.V_CMP_LE_I32: _VOP3AOp_V_CMP_LE_I32,
  VOP3AOp.V_CMP_GT_I32: _VOP3AOp_V_CMP_GT_I32,
  VOP3AOp.V_CMP_NE_I32: _VOP3AOp_V_CMP_NE_I32,
  VOP3AOp.V_CMP_GE_I32: _VOP3AOp_V_CMP_GE_I32,
  VOP3AOp.V_CMP_T_I32: _VOP3AOp_V_CMP_T_I32,
  VOP3AOp.V_CMP_F_U32: _VOP3AOp_V_CMP_F_U32,
  VOP3AOp.V_CMP_LT_U32: _VOP3AOp_V_CMP_LT_U32,
  VOP3AOp.V_CMP_EQ_U32: _VOP3AOp_V_CMP_EQ_U32,
  VOP3AOp.V_CMP_LE_U32: _VOP3AOp_V_CMP_LE_U32,
  VOP3AOp.V_CMP_GT_U32: _VOP3AOp_V_CMP_GT_U32,
  VOP3AOp.V_CMP_NE_U32: _VOP3AOp_V_CMP_NE_U32,
  VOP3AOp.V_CMP_GE_U32: _VOP3AOp_V_CMP_GE_U32,
  VOP3AOp.V_CMP_T_U32: _VOP3AOp_V_CMP_T_U32,
  VOP3AOp.V_CMPX_F_I32: _VOP3AOp_V_CMPX_F_I32,
  VOP3AOp.V_CMPX_LT_I32: _VOP3AOp_V_CMPX_LT_I32,
  VOP3AOp.V_CMPX_EQ_I32: _VOP3AOp_V_CMPX_EQ_I32,
  VOP3AOp.V_CMPX_LE_I32: _VOP3AOp_V_CMPX_LE_I32,
  VOP3AOp.V_CMPX_GT_I32: _VOP3AOp_V_CMPX_GT_I32,
  VOP3AOp.V_CMPX_NE_I32: _VOP3AOp_V_CMPX_NE_I32,
  VOP3AOp.V_CMPX_GE_I32: _VOP3AOp_V_CMPX_GE_I32,
  VOP3AOp.V_CMPX_T_I32: _VOP3AOp_V_CMPX_T_I32,
  VOP3AOp.V_CMPX_F_U32: _VOP3AOp_V_CMPX_F_U32,
  VOP3AOp.V_CMPX_LT_U32: _VOP3AOp_V_CMPX_LT_U32,
  VOP3AOp.V_CMPX_EQ_U32: _VOP3AOp_V_CMPX_EQ_U32,
  VOP3AOp.V_CMPX_LE_U32: _VOP3AOp_V_CMPX_LE_U32,
  VOP3AOp.V_CMPX_GT_U32: _VOP3AOp_V_CMPX_GT_U32,
  VOP3AOp.V_CMPX_NE_U32: _VOP3AOp_V_CMPX_NE_U32,
  VOP3AOp.V_CMPX_GE_U32: _VOP3AOp_V_CMPX_GE_U32,
  VOP3AOp.V_CMPX_T_U32: _VOP3AOp_V_CMPX_T_U32,
  VOP3AOp.V_CMP_F_I64: _VOP3AOp_V_CMP_F_I64,
  VOP3AOp.V_CMP_LT_I64: _VOP3AOp_V_CMP_LT_I64,
  VOP3AOp.V_CMP_EQ_I64: _VOP3AOp_V_CMP_EQ_I64,
  VOP3AOp.V_CMP_LE_I64: _VOP3AOp_V_CMP_LE_I64,
  VOP3AOp.V_CMP_GT_I64: _VOP3AOp_V_CMP_GT_I64,
  VOP3AOp.V_CMP_NE_I64: _VOP3AOp_V_CMP_NE_I64,
  VOP3AOp.V_CMP_GE_I64: _VOP3AOp_V_CMP_GE_I64,
  VOP3AOp.V_CMP_T_I64: _VOP3AOp_V_CMP_T_I64,
  VOP3AOp.V_CMP_F_U64: _VOP3AOp_V_CMP_F_U64,
  VOP3AOp.V_CMP_LT_U64: _VOP3AOp_V_CMP_LT_U64,
  VOP3AOp.V_CMP_EQ_U64: _VOP3AOp_V_CMP_EQ_U64,
  VOP3AOp.V_CMP_LE_U64: _VOP3AOp_V_CMP_LE_U64,
  VOP3AOp.V_CMP_GT_U64: _VOP3AOp_V_CMP_GT_U64,
  VOP3AOp.V_CMP_NE_U64: _VOP3AOp_V_CMP_NE_U64,
  VOP3AOp.V_CMP_GE_U64: _VOP3AOp_V_CMP_GE_U64,
  VOP3AOp.V_CMP_T_U64: _VOP3AOp_V_CMP_T_U64,
  VOP3AOp.V_CMPX_F_I64: _VOP3AOp_V_CMPX_F_I64,
  VOP3AOp.V_CMPX_LT_I64: _VOP3AOp_V_CMPX_LT_I64,
  VOP3AOp.V_CMPX_EQ_I64: _VOP3AOp_V_CMPX_EQ_I64,
  VOP3AOp.V_CMPX_LE_I64: _VOP3AOp_V_CMPX_LE_I64,
  VOP3AOp.V_CMPX_GT_I64: _VOP3AOp_V_CMPX_GT_I64,
  VOP3AOp.V_CMPX_NE_I64: _VOP3AOp_V_CMPX_NE_I64,
  VOP3AOp.V_CMPX_GE_I64: _VOP3AOp_V_CMPX_GE_I64,
  VOP3AOp.V_CMPX_T_I64: _VOP3AOp_V_CMPX_T_I64,
  VOP3AOp.V_CMPX_F_U64: _VOP3AOp_V_CMPX_F_U64,
  VOP3AOp.V_CMPX_LT_U64: _VOP3AOp_V_CMPX_LT_U64,
  VOP3AOp.V_CMPX_EQ_U64: _VOP3AOp_V_CMPX_EQ_U64,
  VOP3AOp.V_CMPX_LE_U64: _VOP3AOp_V_CMPX_LE_U64,
  VOP3AOp.V_CMPX_GT_U64: _VOP3AOp_V_CMPX_GT_U64,
  VOP3AOp.V_CMPX_NE_U64: _VOP3AOp_V_CMPX_NE_U64,
  VOP3AOp.V_CMPX_GE_U64: _VOP3AOp_V_CMPX_GE_U64,
  VOP3AOp.V_CMPX_T_U64: _VOP3AOp_V_CMPX_T_U64,
  VOP3AOp.V_MOV_B32: _VOP3AOp_V_MOV_B32,
  VOP3AOp.V_READFIRSTLANE_B32: _VOP3AOp_V_READFIRSTLANE_B32,
  VOP3AOp.V_CVT_I32_F64: _VOP3AOp_V_CVT_I32_F64,
  VOP3AOp.V_CVT_F64_I32: _VOP3AOp_V_CVT_F64_I32,
  VOP3AOp.V_CVT_F32_I32: _VOP3AOp_V_CVT_F32_I32,
  VOP3AOp.V_CVT_F32_U32: _VOP3AOp_V_CVT_F32_U32,
  VOP3AOp.V_CVT_U32_F32: _VOP3AOp_V_CVT_U32_F32,
  VOP3AOp.V_CVT_I32_F32: _VOP3AOp_V_CVT_I32_F32,
  VOP3AOp.V_CVT_F16_F32: _VOP3AOp_V_CVT_F16_F32,
  VOP3AOp.V_CVT_F32_F16: _VOP3AOp_V_CVT_F32_F16,
  VOP3AOp.V_CVT_RPI_I32_F32: _VOP3AOp_V_CVT_RPI_I32_F32,
  VOP3AOp.V_CVT_FLR_I32_F32: _VOP3AOp_V_CVT_FLR_I32_F32,
  VOP3AOp.V_CVT_F32_F64: _VOP3AOp_V_CVT_F32_F64,
  VOP3AOp.V_CVT_F64_F32: _VOP3AOp_V_CVT_F64_F32,
  VOP3AOp.V_CVT_F32_UBYTE0: _VOP3AOp_V_CVT_F32_UBYTE0,
  VOP3AOp.V_CVT_F32_UBYTE1: _VOP3AOp_V_CVT_F32_UBYTE1,
  VOP3AOp.V_CVT_F32_UBYTE2: _VOP3AOp_V_CVT_F32_UBYTE2,
  VOP3AOp.V_CVT_F32_UBYTE3: _VOP3AOp_V_CVT_F32_UBYTE3,
  VOP3AOp.V_CVT_U32_F64: _VOP3AOp_V_CVT_U32_F64,
  VOP3AOp.V_CVT_F64_U32: _VOP3AOp_V_CVT_F64_U32,
  VOP3AOp.V_TRUNC_F64: _VOP3AOp_V_TRUNC_F64,
  VOP3AOp.V_CEIL_F64: _VOP3AOp_V_CEIL_F64,
  VOP3AOp.V_RNDNE_F64: _VOP3AOp_V_RNDNE_F64,
  VOP3AOp.V_FLOOR_F64: _VOP3AOp_V_FLOOR_F64,
  VOP3AOp.V_FRACT_F32: _VOP3AOp_V_FRACT_F32,
  VOP3AOp.V_TRUNC_F32: _VOP3AOp_V_TRUNC_F32,
  VOP3AOp.V_CEIL_F32: _VOP3AOp_V_CEIL_F32,
  VOP3AOp.V_RNDNE_F32: _VOP3AOp_V_RNDNE_F32,
  VOP3AOp.V_FLOOR_F32: _VOP3AOp_V_FLOOR_F32,
  VOP3AOp.V_EXP_F32: _VOP3AOp_V_EXP_F32,
  VOP3AOp.V_LOG_F32: _VOP3AOp_V_LOG_F32,
  VOP3AOp.V_RCP_F32: _VOP3AOp_V_RCP_F32,
  VOP3AOp.V_RCP_IFLAG_F32: _VOP3AOp_V_RCP_IFLAG_F32,
  VOP3AOp.V_RSQ_F32: _VOP3AOp_V_RSQ_F32,
  VOP3AOp.V_RCP_F64: _VOP3AOp_V_RCP_F64,
  VOP3AOp.V_RSQ_F64: _VOP3AOp_V_RSQ_F64,
  VOP3AOp.V_SQRT_F32: _VOP3AOp_V_SQRT_F32,
  VOP3AOp.V_SQRT_F64: _VOP3AOp_V_SQRT_F64,
  VOP3AOp.V_SIN_F32: _VOP3AOp_V_SIN_F32,
  VOP3AOp.V_COS_F32: _VOP3AOp_V_COS_F32,
  VOP3AOp.V_NOT_B32: _VOP3AOp_V_NOT_B32,
  VOP3AOp.V_BFREV_B32: _VOP3AOp_V_BFREV_B32,
  VOP3AOp.V_FFBH_U32: _VOP3AOp_V_FFBH_U32,
  VOP3AOp.V_FFBL_B32: _VOP3AOp_V_FFBL_B32,
  VOP3AOp.V_FFBH_I32: _VOP3AOp_V_FFBH_I32,
  VOP3AOp.V_FREXP_EXP_I32_F64: _VOP3AOp_V_FREXP_EXP_I32_F64,
  VOP3AOp.V_FREXP_MANT_F64: _VOP3AOp_V_FREXP_MANT_F64,
  VOP3AOp.V_FRACT_F64: _VOP3AOp_V_FRACT_F64,
  VOP3AOp.V_FREXP_EXP_I32_F32: _VOP3AOp_V_FREXP_EXP_I32_F32,
  VOP3AOp.V_FREXP_MANT_F32: _VOP3AOp_V_FREXP_MANT_F32,
  VOP3AOp.V_MOV_B64: _VOP3AOp_V_MOV_B64,
  VOP3AOp.V_CVT_F16_U16: _VOP3AOp_V_CVT_F16_U16,
  VOP3AOp.V_CVT_F16_I16: _VOP3AOp_V_CVT_F16_I16,
  VOP3AOp.V_CVT_U16_F16: _VOP3AOp_V_CVT_U16_F16,
  VOP3AOp.V_CVT_I16_F16: _VOP3AOp_V_CVT_I16_F16,
  VOP3AOp.V_RCP_F16: _VOP3AOp_V_RCP_F16,
  VOP3AOp.V_SQRT_F16: _VOP3AOp_V_SQRT_F16,
  VOP3AOp.V_RSQ_F16: _VOP3AOp_V_RSQ_F16,
  VOP3AOp.V_LOG_F16: _VOP3AOp_V_LOG_F16,
  VOP3AOp.V_EXP_F16: _VOP3AOp_V_EXP_F16,
  VOP3AOp.V_CNDMASK_B32: _VOP3AOp_V_CNDMASK_B32,
  VOP3AOp.V_ADD_F32: _VOP3AOp_V_ADD_F32,
  VOP3AOp.V_SUB_F32: _VOP3AOp_V_SUB_F32,
  VOP3AOp.V_SUBREV_F32: _VOP3AOp_V_SUBREV_F32,
  VOP3AOp.V_FMAC_F64: _VOP3AOp_V_FMAC_F64,
  VOP3AOp.V_MUL_F32: _VOP3AOp_V_MUL_F32,
  VOP3AOp.V_MUL_I32_I24: _VOP3AOp_V_MUL_I32_I24,
  VOP3AOp.V_MUL_HI_I32_I24: _VOP3AOp_V_MUL_HI_I32_I24,
  VOP3AOp.V_MUL_U32_U24: _VOP3AOp_V_MUL_U32_U24,
  VOP3AOp.V_MUL_HI_U32_U24: _VOP3AOp_V_MUL_HI_U32_U24,
  VOP3AOp.V_MIN_F32: _VOP3AOp_V_MIN_F32,
  VOP3AOp.V_MAX_F32: _VOP3AOp_V_MAX_F32,
  VOP3AOp.V_MIN_I32: _VOP3AOp_V_MIN_I32,
  VOP3AOp.V_MAX_I32: _VOP3AOp_V_MAX_I32,
  VOP3AOp.V_MIN_U32: _VOP3AOp_V_MIN_U32,
  VOP3AOp.V_MAX_U32: _VOP3AOp_V_MAX_U32,
  VOP3AOp.V_LSHRREV_B32: _VOP3AOp_V_LSHRREV_B32,
  VOP3AOp.V_ASHRREV_I32: _VOP3AOp_V_ASHRREV_I32,
  VOP3AOp.V_LSHLREV_B32: _VOP3AOp_V_LSHLREV_B32,
  VOP3AOp.V_AND_B32: _VOP3AOp_V_AND_B32,
  VOP3AOp.V_OR_B32: _VOP3AOp_V_OR_B32,
  VOP3AOp.V_XOR_B32: _VOP3AOp_V_XOR_B32,
  VOP3AOp.V_ADD_F16: _VOP3AOp_V_ADD_F16,
  VOP3AOp.V_SUB_F16: _VOP3AOp_V_SUB_F16,
  VOP3AOp.V_SUBREV_F16: _VOP3AOp_V_SUBREV_F16,
  VOP3AOp.V_MUL_F16: _VOP3AOp_V_MUL_F16,
  VOP3AOp.V_MAC_F16: _VOP3AOp_V_MAC_F16,
  VOP3AOp.V_ADD_U16: _VOP3AOp_V_ADD_U16,
  VOP3AOp.V_SUB_U16: _VOP3AOp_V_SUB_U16,
  VOP3AOp.V_SUBREV_U16: _VOP3AOp_V_SUBREV_U16,
  VOP3AOp.V_MUL_LO_U16: _VOP3AOp_V_MUL_LO_U16,
  VOP3AOp.V_LSHLREV_B16: _VOP3AOp_V_LSHLREV_B16,
  VOP3AOp.V_LSHRREV_B16: _VOP3AOp_V_LSHRREV_B16,
  VOP3AOp.V_ASHRREV_I16: _VOP3AOp_V_ASHRREV_I16,
  VOP3AOp.V_MAX_F16: _VOP3AOp_V_MAX_F16,
  VOP3AOp.V_MIN_F16: _VOP3AOp_V_MIN_F16,
  VOP3AOp.V_MAX_U16: _VOP3AOp_V_MAX_U16,
  VOP3AOp.V_MAX_I16: _VOP3AOp_V_MAX_I16,
  VOP3AOp.V_MIN_U16: _VOP3AOp_V_MIN_U16,
  VOP3AOp.V_MIN_I16: _VOP3AOp_V_MIN_I16,
  VOP3AOp.V_LDEXP_F16: _VOP3AOp_V_LDEXP_F16,
  VOP3AOp.V_ADD_U32: _VOP3AOp_V_ADD_U32,
  VOP3AOp.V_SUB_U32: _VOP3AOp_V_SUB_U32,
  VOP3AOp.V_SUBREV_U32: _VOP3AOp_V_SUBREV_U32,
  VOP3AOp.V_DOT2C_F32_F16: _VOP3AOp_V_DOT2C_F32_F16,
  VOP3AOp.V_DOT2C_I32_I16: _VOP3AOp_V_DOT2C_I32_I16,
  VOP3AOp.V_DOT4C_I32_I8: _VOP3AOp_V_DOT4C_I32_I8,
  VOP3AOp.V_DOT8C_I32_I4: _VOP3AOp_V_DOT8C_I32_I4,
  VOP3AOp.V_FMAC_F32: _VOP3AOp_V_FMAC_F32,
  VOP3AOp.V_PK_FMAC_F16: _VOP3AOp_V_PK_FMAC_F16,
  VOP3AOp.V_XNOR_B32: _VOP3AOp_V_XNOR_B32,
  VOP3AOp.V_MAD_I32_I24: _VOP3AOp_V_MAD_I32_I24,
  VOP3AOp.V_MAD_U32_U24: _VOP3AOp_V_MAD_U32_U24,
  VOP3AOp.V_CUBEID_F32: _VOP3AOp_V_CUBEID_F32,
  VOP3AOp.V_CUBESC_F32: _VOP3AOp_V_CUBESC_F32,
  VOP3AOp.V_CUBETC_F32: _VOP3AOp_V_CUBETC_F32,
  VOP3AOp.V_CUBEMA_F32: _VOP3AOp_V_CUBEMA_F32,
  VOP3AOp.V_BFE_U32: _VOP3AOp_V_BFE_U32,
  VOP3AOp.V_BFE_I32: _VOP3AOp_V_BFE_I32,
  VOP3AOp.V_BFI_B32: _VOP3AOp_V_BFI_B32,
  VOP3AOp.V_FMA_F32: _VOP3AOp_V_FMA_F32,
  VOP3AOp.V_FMA_F64: _VOP3AOp_V_FMA_F64,
  VOP3AOp.V_LERP_U8: _VOP3AOp_V_LERP_U8,
  VOP3AOp.V_ALIGNBIT_B32: _VOP3AOp_V_ALIGNBIT_B32,
  VOP3AOp.V_ALIGNBYTE_B32: _VOP3AOp_V_ALIGNBYTE_B32,
  VOP3AOp.V_MIN3_F32: _VOP3AOp_V_MIN3_F32,
  VOP3AOp.V_MIN3_I32: _VOP3AOp_V_MIN3_I32,
  VOP3AOp.V_MIN3_U32: _VOP3AOp_V_MIN3_U32,
  VOP3AOp.V_MAX3_F32: _VOP3AOp_V_MAX3_F32,
  VOP3AOp.V_MAX3_I32: _VOP3AOp_V_MAX3_I32,
  VOP3AOp.V_MAX3_U32: _VOP3AOp_V_MAX3_U32,
  VOP3AOp.V_MED3_F32: _VOP3AOp_V_MED3_F32,
  VOP3AOp.V_MED3_I32: _VOP3AOp_V_MED3_I32,
  VOP3AOp.V_MED3_U32: _VOP3AOp_V_MED3_U32,
  VOP3AOp.V_SAD_U8: _VOP3AOp_V_SAD_U8,
  VOP3AOp.V_SAD_U16: _VOP3AOp_V_SAD_U16,
  VOP3AOp.V_SAD_U32: _VOP3AOp_V_SAD_U32,
  VOP3AOp.V_CVT_PK_U8_F32: _VOP3AOp_V_CVT_PK_U8_F32,
  VOP3AOp.V_DIV_FIXUP_F32: _VOP3AOp_V_DIV_FIXUP_F32,
  VOP3AOp.V_DIV_FIXUP_F64: _VOP3AOp_V_DIV_FIXUP_F64,
  VOP3AOp.V_DIV_FMAS_F32: _VOP3AOp_V_DIV_FMAS_F32,
  VOP3AOp.V_DIV_FMAS_F64: _VOP3AOp_V_DIV_FMAS_F64,
  VOP3AOp.V_MSAD_U8: _VOP3AOp_V_MSAD_U8,
  VOP3AOp.V_MAD_LEGACY_F16: _VOP3AOp_V_MAD_LEGACY_F16,
  VOP3AOp.V_MAD_LEGACY_U16: _VOP3AOp_V_MAD_LEGACY_U16,
  VOP3AOp.V_MAD_LEGACY_I16: _VOP3AOp_V_MAD_LEGACY_I16,
  VOP3AOp.V_FMA_LEGACY_F16: _VOP3AOp_V_FMA_LEGACY_F16,
  VOP3AOp.V_DIV_FIXUP_LEGACY_F16: _VOP3AOp_V_DIV_FIXUP_LEGACY_F16,
  VOP3AOp.V_CVT_PKACCUM_U8_F32: _VOP3AOp_V_CVT_PKACCUM_U8_F32,
  VOP3AOp.V_MAD_U32_U16: _VOP3AOp_V_MAD_U32_U16,
  VOP3AOp.V_MAD_I32_I16: _VOP3AOp_V_MAD_I32_I16,
  VOP3AOp.V_XAD_U32: _VOP3AOp_V_XAD_U32,
  VOP3AOp.V_MIN3_F16: _VOP3AOp_V_MIN3_F16,
  VOP3AOp.V_MIN3_I16: _VOP3AOp_V_MIN3_I16,
  VOP3AOp.V_MIN3_U16: _VOP3AOp_V_MIN3_U16,
  VOP3AOp.V_MAX3_F16: _VOP3AOp_V_MAX3_F16,
  VOP3AOp.V_MAX3_I16: _VOP3AOp_V_MAX3_I16,
  VOP3AOp.V_MAX3_U16: _VOP3AOp_V_MAX3_U16,
  VOP3AOp.V_MED3_F16: _VOP3AOp_V_MED3_F16,
  VOP3AOp.V_MED3_I16: _VOP3AOp_V_MED3_I16,
  VOP3AOp.V_MED3_U16: _VOP3AOp_V_MED3_U16,
  VOP3AOp.V_LSHL_ADD_U32: _VOP3AOp_V_LSHL_ADD_U32,
  VOP3AOp.V_ADD_LSHL_U32: _VOP3AOp_V_ADD_LSHL_U32,
  VOP3AOp.V_ADD3_U32: _VOP3AOp_V_ADD3_U32,
  VOP3AOp.V_LSHL_OR_B32: _VOP3AOp_V_LSHL_OR_B32,
  VOP3AOp.V_AND_OR_B32: _VOP3AOp_V_AND_OR_B32,
  VOP3AOp.V_OR3_B32: _VOP3AOp_V_OR3_B32,
  VOP3AOp.V_MAD_F16: _VOP3AOp_V_MAD_F16,
  VOP3AOp.V_MAD_U16: _VOP3AOp_V_MAD_U16,
  VOP3AOp.V_MAD_I16: _VOP3AOp_V_MAD_I16,
  VOP3AOp.V_FMA_F16: _VOP3AOp_V_FMA_F16,
  VOP3AOp.V_DIV_FIXUP_F16: _VOP3AOp_V_DIV_FIXUP_F16,
  VOP3AOp.V_LSHL_ADD_U64: _VOP3AOp_V_LSHL_ADD_U64,
  VOP3AOp.V_BITOP3_B16: _VOP3AOp_V_BITOP3_B16,
  VOP3AOp.V_BITOP3_B32: _VOP3AOp_V_BITOP3_B32,
  VOP3AOp.V_CVT_SCALEF32_PK_FP8_F32: _VOP3AOp_V_CVT_SCALEF32_PK_FP8_F32,
  VOP3AOp.V_CVT_SCALEF32_PK_BF8_F32: _VOP3AOp_V_CVT_SCALEF32_PK_BF8_F32,
  VOP3AOp.V_CVT_SCALEF32_SR_FP8_F32: _VOP3AOp_V_CVT_SCALEF32_SR_FP8_F32,
  VOP3AOp.V_CVT_SCALEF32_SR_BF8_F32: _VOP3AOp_V_CVT_SCALEF32_SR_BF8_F32,
  VOP3AOp.V_CVT_SCALEF32_PK_F32_FP8: _VOP3AOp_V_CVT_SCALEF32_PK_F32_FP8,
  VOP3AOp.V_CVT_SCALEF32_PK_F32_BF8: _VOP3AOp_V_CVT_SCALEF32_PK_F32_BF8,
  VOP3AOp.V_CVT_SCALEF32_F32_FP8: _VOP3AOp_V_CVT_SCALEF32_F32_FP8,
  VOP3AOp.V_CVT_SCALEF32_F32_BF8: _VOP3AOp_V_CVT_SCALEF32_F32_BF8,
  VOP3AOp.V_CVT_SCALEF32_PK_FP4_F32: _VOP3AOp_V_CVT_SCALEF32_PK_FP4_F32,
  VOP3AOp.V_CVT_SCALEF32_SR_PK_FP4_F32: _VOP3AOp_V_CVT_SCALEF32_SR_PK_FP4_F32,
  VOP3AOp.V_CVT_SCALEF32_PK_F32_FP4: _VOP3AOp_V_CVT_SCALEF32_PK_F32_FP4,
  VOP3AOp.V_CVT_SCALEF32_PK_FP8_F16: _VOP3AOp_V_CVT_SCALEF32_PK_FP8_F16,
  VOP3AOp.V_CVT_SCALEF32_PK_BF8_F16: _VOP3AOp_V_CVT_SCALEF32_PK_BF8_F16,
  VOP3AOp.V_CVT_SCALEF32_SR_FP8_F16: _VOP3AOp_V_CVT_SCALEF32_SR_FP8_F16,
  VOP3AOp.V_CVT_SCALEF32_SR_BF8_F16: _VOP3AOp_V_CVT_SCALEF32_SR_BF8_F16,
  VOP3AOp.V_CVT_SCALEF32_PK_F16_FP8: _VOP3AOp_V_CVT_SCALEF32_PK_F16_FP8,
  VOP3AOp.V_CVT_SCALEF32_PK_F16_BF8: _VOP3AOp_V_CVT_SCALEF32_PK_F16_BF8,
  VOP3AOp.V_CVT_SCALEF32_F16_FP8: _VOP3AOp_V_CVT_SCALEF32_F16_FP8,
  VOP3AOp.V_CVT_SCALEF32_F16_BF8: _VOP3AOp_V_CVT_SCALEF32_F16_BF8,
  VOP3AOp.V_CVT_SCALEF32_PK_FP4_F16: _VOP3AOp_V_CVT_SCALEF32_PK_FP4_F16,
  VOP3AOp.V_CVT_SCALEF32_SR_PK_FP4_F16: _VOP3AOp_V_CVT_SCALEF32_SR_PK_FP4_F16,
  VOP3AOp.V_CVT_SCALEF32_PK_F16_FP4: _VOP3AOp_V_CVT_SCALEF32_PK_F16_FP4,
  VOP3AOp.V_CVT_SCALEF32_2XPK16_FP6_F32: _VOP3AOp_V_CVT_SCALEF32_2XPK16_FP6_F32,
  VOP3AOp.V_CVT_SCALEF32_2XPK16_BF6_F32: _VOP3AOp_V_CVT_SCALEF32_2XPK16_BF6_F32,
  VOP3AOp.V_CVT_SCALEF32_SR_PK32_FP6_F32: _VOP3AOp_V_CVT_SCALEF32_SR_PK32_FP6_F32,
  VOP3AOp.V_CVT_SCALEF32_SR_PK32_BF6_F32: _VOP3AOp_V_CVT_SCALEF32_SR_PK32_BF6_F32,
  VOP3AOp.V_CVT_SCALEF32_PK32_F32_FP6: _VOP3AOp_V_CVT_SCALEF32_PK32_F32_FP6,
  VOP3AOp.V_CVT_SCALEF32_PK32_F32_BF6: _VOP3AOp_V_CVT_SCALEF32_PK32_F32_BF6,
  VOP3AOp.V_CVT_SCALEF32_PK32_BF6_F16: _VOP3AOp_V_CVT_SCALEF32_PK32_BF6_F16,
  VOP3AOp.V_CVT_SCALEF32_SR_PK32_FP6_F16: _VOP3AOp_V_CVT_SCALEF32_SR_PK32_FP6_F16,
  VOP3AOp.V_CVT_SCALEF32_SR_PK32_BF6_F16: _VOP3AOp_V_CVT_SCALEF32_SR_PK32_BF6_F16,
  VOP3AOp.V_CVT_SCALEF32_PK32_F16_FP6: _VOP3AOp_V_CVT_SCALEF32_PK32_F16_FP6,
  VOP3AOp.V_CVT_SCALEF32_PK32_F16_BF6: _VOP3AOp_V_CVT_SCALEF32_PK32_F16_BF6,
  VOP3AOp.V_ASHR_PK_I8_I32: _VOP3AOp_V_ASHR_PK_I8_I32,
  VOP3AOp.V_ASHR_PK_U8_I32: _VOP3AOp_V_ASHR_PK_U8_I32,
  VOP3AOp.V_CVT_PK_F16_F32: _VOP3AOp_V_CVT_PK_F16_F32,
  VOP3AOp.V_ADD_F64: _VOP3AOp_V_ADD_F64,
  VOP3AOp.V_MUL_F64: _VOP3AOp_V_MUL_F64,
  VOP3AOp.V_MIN_F64: _VOP3AOp_V_MIN_F64,
  VOP3AOp.V_MAX_F64: _VOP3AOp_V_MAX_F64,
  VOP3AOp.V_LDEXP_F64: _VOP3AOp_V_LDEXP_F64,
  VOP3AOp.V_MUL_LO_U32: _VOP3AOp_V_MUL_LO_U32,
  VOP3AOp.V_MUL_HI_U32: _VOP3AOp_V_MUL_HI_U32,
  VOP3AOp.V_MUL_HI_I32: _VOP3AOp_V_MUL_HI_I32,
  VOP3AOp.V_LDEXP_F32: _VOP3AOp_V_LDEXP_F32,
  VOP3AOp.V_READLANE_B32: _VOP3AOp_V_READLANE_B32,
  VOP3AOp.V_BCNT_U32_B32: _VOP3AOp_V_BCNT_U32_B32,
  VOP3AOp.V_LSHLREV_B64: _VOP3AOp_V_LSHLREV_B64,
  VOP3AOp.V_LSHRREV_B64: _VOP3AOp_V_LSHRREV_B64,
  VOP3AOp.V_ASHRREV_I64: _VOP3AOp_V_ASHRREV_I64,
  VOP3AOp.V_BFM_B32: _VOP3AOp_V_BFM_B32,
  VOP3AOp.V_CVT_PKNORM_I16_F32: _VOP3AOp_V_CVT_PKNORM_I16_F32,
  VOP3AOp.V_CVT_PKNORM_U16_F32: _VOP3AOp_V_CVT_PKNORM_U16_F32,
  VOP3AOp.V_CVT_PKRTZ_F16_F32: _VOP3AOp_V_CVT_PKRTZ_F16_F32,
  VOP3AOp.V_CVT_PK_U16_U32: _VOP3AOp_V_CVT_PK_U16_U32,
  VOP3AOp.V_CVT_PK_I16_I32: _VOP3AOp_V_CVT_PK_I16_I32,
  VOP3AOp.V_CVT_PKNORM_I16_F16: _VOP3AOp_V_CVT_PKNORM_I16_F16,
  VOP3AOp.V_CVT_PKNORM_U16_F16: _VOP3AOp_V_CVT_PKNORM_U16_F16,
  VOP3AOp.V_ADD_I32: _VOP3AOp_V_ADD_I32,
  VOP3AOp.V_SUB_I32: _VOP3AOp_V_SUB_I32,
  VOP3AOp.V_ADD_I16: _VOP3AOp_V_ADD_I16,
  VOP3AOp.V_SUB_I16: _VOP3AOp_V_SUB_I16,
  VOP3AOp.V_PACK_B32_F16: _VOP3AOp_V_PACK_B32_F16,
  VOP3AOp.V_MUL_LEGACY_F32: _VOP3AOp_V_MUL_LEGACY_F32,
  VOP3AOp.V_MINIMUM3_F32: _VOP3AOp_V_MINIMUM3_F32,
  VOP3AOp.V_MAXIMUM3_F32: _VOP3AOp_V_MAXIMUM3_F32,
}

def _VOP3BOp_V_ADD_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 64'U(S0.u32) + 64'U(S1.u32);
  # VCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_ADDC_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg((S0.u32) + (S1.u32))
  VCC.u64[laneId] = ((1) if (tmp >= 0x100000000) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3BOp_V_SUB_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32 - S1.u32;
  # VCC.u64[laneId] = S1.u32 > S0.u32 ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_SUBB_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32 - S1.u32)
  VCC.u64[laneId] = ((1) if (S1.u32 > S0.u32) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3BOp_V_SUBREV_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S1.u32 - S0.u32;
  # VCC.u64[laneId] = S0.u32 > S1.u32 ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_SUBB_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg(S1.u32 - S0.u32)
  VCC.u64[laneId] = ((1) if (S0.u32 > S1.u32) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3BOp_V_ADDC_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 64'U(S0.u32) + 64'U(S1.u32) + VCC.u64[laneId].u64;
  # VCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_ADDC_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg((S0.u32) + (S1.u32) + VCC.u64[laneId])
  VCC.u64[laneId] = ((1) if (tmp >= 0x100000000) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3BOp_V_SUBB_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32 - S1.u32 - VCC.u64[laneId].u32;
  # VCC.u64[laneId] = 64'U(S1.u32) + VCC.u64[laneId].u64 > 64'U(S0.u32) ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_SUBB_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32 - S1.u32 - VCC.u64[laneId])
  VCC.u64[laneId] = ((1) if ((S1.u32) + VCC.u64[laneId] > (S0.u32)) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3BOp_V_SUBBREV_CO_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S1.u32 - S0.u32 - VCC.u64[laneId].u32;
  # VCC.u64[laneId] = 64'U(S0.u32) + VCC.u64[laneId].u64 > 64'U(S1.u32) ? 1'1U : 1'0U;
  # // VCC is an UNSIGNED overflow/carry-out for V_SUBB_CO_U32.
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  tmp = Reg(0)
  laneId = lane
  # --- compiled pseudocode ---
  tmp = Reg(S1.u32 - S0.u32 - VCC.u64[laneId])
  VCC.u64[laneId] = ((1) if ((S0.u32) + VCC.u64[laneId] > (S1.u32)) else (0))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3BOp_V_DIV_SCALE_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VCC = 0x0LL;
  # if ((64'F(S2.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then
  # D0.f32 = NAN.f32
  # elsif exponent(S2.f32) - exponent(S1.f32) >= 96 then
  # // N/D near MAX_FLOAT_F32
  # VCC = 0x1LL;
  # if S0.f32 == S1.f32 then
  # // Only scale the denominator
  # D0.f32 = ldexp(S0.f32, 64)
  # endif
  # elsif S1.f32 == DENORM.f32 then
  # D0.f32 = ldexp(S0.f32, 64)
  # elsif ((1.0 / 64'F(S1.f32) == DENORM.f64) && (S2.f32 / S1.f32 == DENORM.f32)) then
  # VCC = 0x1LL;
  # if S0.f32 == S1.f32 then
  # // Only scale the denominator
  # D0.f32 = ldexp(S0.f32, 64)
  # endif
  # elsif 1.0 / 64'F(S1.f32) == DENORM.f64 then
  # D0.f32 = ldexp(S0.f32, -64)
  # elsif S2.f32 / S1.f32 == DENORM.f32 then
  # VCC = 0x1LL;
  # if S0.f32 == S2.f32 then
  # // Only scale the numerator
  # D0.f32 = ldexp(S0.f32, 64)
  # endif
  # elsif exponent(S2.f32) <= 23 then
  # // Numerator is tiny
  # D0.f32 = ldexp(S0.f32, 64)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(s0)
  VCC = Reg(vcc)
  # --- compiled pseudocode ---
  VCC = Reg(0x0)
  if ((F(S2.f32) == 0.0)  or  (F(S1.f32) == 0.0)):
    VCC = Reg(0x1); D0.f32 = float("nan")
  elif exponent(S2.f32) - exponent(S1.f32) >= 96:
    VCC = Reg(0x1)
    if S0.f32 == S1.f32:
      D0.f32 = ldexp(S0.f32, 64)
  elif False:
    pass  # denorm check moved to end
  elif ((1.0 / F(S1.f32) == DENORM.f64)  and  (S2.f32 / S1.f32 == DENORM.f32)):
    VCC = Reg(0x1)
    if S0.f32 == S1.f32:
      D0.f32 = ldexp(S0.f32, 64)
  elif 1.0 / F(S1.f32) == DENORM.f64:
    D0.f32 = ldexp(S0.f32, -64)
  elif S2.f32 / S1.f32 == DENORM.f32:
    VCC = Reg(0x1)
  elif exponent(S2.f32) <= 23:
    VCC = Reg(0x1); D0.f32 = ldexp(S0.f32, 64)
  if S1.f32 == DENORM.f32:
    D0.f32 = float("nan")
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  return result

def _VOP3BOp_V_DIV_SCALE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # VCC = 0x0LL;
  # if ((S2.f64 == 0.0) || (S1.f64 == 0.0)) then
  # D0.f64 = NAN.f64
  # elsif exponent(S2.f64) - exponent(S1.f64) >= 768 then
  # // N/D near MAX_FLOAT_F64
  # VCC = 0x1LL;
  # if S0.f64 == S1.f64 then
  # // Only scale the denominator
  # D0.f64 = ldexp(S0.f64, 128)
  # endif
  # elsif S1.f64 == DENORM.f64 then
  # D0.f64 = ldexp(S0.f64, 128)
  # elsif ((1.0 / S1.f64 == DENORM.f64) && (S2.f64 / S1.f64 == DENORM.f64)) then
  # VCC = 0x1LL;
  # if S0.f64 == S1.f64 then
  # // Only scale the denominator
  # D0.f64 = ldexp(S0.f64, 128)
  # endif
  # elsif 1.0 / S1.f64 == DENORM.f64 then
  # D0.f64 = ldexp(S0.f64, -128)
  # elsif S2.f64 / S1.f64 == DENORM.f64 then
  # VCC = 0x1LL;
  # if S0.f64 == S2.f64 then
  # // Only scale the numerator
  # D0.f64 = ldexp(S0.f64, 128)
  # endif
  # elsif exponent(S2.f64) <= 53 then
  # // Numerator is tiny
  # D0.f64 = ldexp(S0.f64, 128)
  # endif
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(s0)
  VCC = Reg(vcc)
  # --- compiled pseudocode ---
  VCC = Reg(0x0)
  if ((S2.f64 == 0.0)  or  (S1.f64 == 0.0)):
    VCC = Reg(0x1); D0.f64 = float("nan")
  elif exponent(S2.f64) - exponent(S1.f64) >= 768:
    VCC = Reg(0x1)
    if S0.f64 == S1.f64:
      D0.f64 = ldexp(S0.f64, 128)
  elif False:
    pass  # denorm check moved to end
  elif ((1.0 / S1.f64 == DENORM.f64)  and  (S2.f64 / S1.f64 == DENORM.f64)):
    VCC = Reg(0x1)
    if S0.f64 == S1.f64:
      D0.f64 = ldexp(S0.f64, 128)
  elif 1.0 / S1.f64 == DENORM.f64:
    D0.f64 = ldexp(S0.f64, -128)
  elif S2.f64 / S1.f64 == DENORM.f64:
    VCC = Reg(0x1)
  elif exponent(S2.f64) <= 53:
    D0.f64 = ldexp(S0.f64, 128)
  if S1.f64 == DENORM.f64:
    D0.f64 = float("nan")
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOP3BOp_V_MAD_U64_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # { D1.u1, D0.u64 } = 65'B(65'U(S0.u32) * 65'U(S1.u32) + 65'U(S2.u64))
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  D1 = Reg(0)
  # --- compiled pseudocode ---
  _full = ((S0.u32) * (S1.u32) + (S2.u64))
  D0.u64 = int(_full) & 0xffffffffffffffff
  D1 = Reg((int(_full) >> 64) & 1)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  result['d1'] = D1._val & 1
  return result

def _VOP3BOp_V_MAD_I64_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # { D1.i1, D0.i64 } = 65'B(65'I(S0.i32) * 65'I(S1.i32) + 65'I(S2.i64))
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  D1 = Reg(0)
  # --- compiled pseudocode ---
  _full = ((S0.i32) * (S1.i32) + (S2.i64))
  D0.u64 = int(_full) & 0xffffffffffffffff
  D1 = Reg((int(_full) >> 64) & 1)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  result['d1'] = D1._val & 1
  return result

VOP3BOp_FUNCTIONS = {
  VOP3BOp.V_ADD_CO_U32: _VOP3BOp_V_ADD_CO_U32,
  VOP3BOp.V_SUB_CO_U32: _VOP3BOp_V_SUB_CO_U32,
  VOP3BOp.V_SUBREV_CO_U32: _VOP3BOp_V_SUBREV_CO_U32,
  VOP3BOp.V_ADDC_CO_U32: _VOP3BOp_V_ADDC_CO_U32,
  VOP3BOp.V_SUBB_CO_U32: _VOP3BOp_V_SUBB_CO_U32,
  VOP3BOp.V_SUBBREV_CO_U32: _VOP3BOp_V_SUBBREV_CO_U32,
  VOP3BOp.V_DIV_SCALE_F32: _VOP3BOp_V_DIV_SCALE_F32,
  VOP3BOp.V_DIV_SCALE_F64: _VOP3BOp_V_DIV_SCALE_F64,
  VOP3BOp.V_MAD_U64_U32: _VOP3BOp_V_MAD_U64_U32,
  VOP3BOp.V_MAD_I64_I32: _VOP3BOp_V_MAD_I64_I32,
}

COMPILED_FUNCTIONS = {
  SOP1Op: SOP1Op_FUNCTIONS,
  SOP2Op: SOP2Op_FUNCTIONS,
  SOPCOp: SOPCOp_FUNCTIONS,
  SOPKOp: SOPKOp_FUNCTIONS,
  SOPPOp: SOPPOp_FUNCTIONS,
  VOP1Op: VOP1Op_FUNCTIONS,
  VOP2Op: VOP2Op_FUNCTIONS,
  VOP3POp: VOP3POp_FUNCTIONS,
  VOP3AOp: VOP3AOp_FUNCTIONS,
  VOP3BOp: VOP3BOp_FUNCTIONS,
}

def get_compiled_functions(): return COMPILED_FUNCTIONS