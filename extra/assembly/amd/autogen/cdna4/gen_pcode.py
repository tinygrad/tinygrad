# autogenerated by pcode.py - do not edit
# to regenerate: python -m extra.assembly.amd.pcode --arch cdna4
# ruff: noqa: E501,F405,F403
# mypy: ignore-errors
from extra.assembly.amd.autogen.cdna4 import SOP1Op, SOP2Op, SOPCOp, SOPKOp, SOPPOp, VOP1Op, VOP2Op, VOP3Op, VOP3SDOp, VOP3POp, VOPCOp
from extra.assembly.amd.pcode import *

def _SOP1Op_S_MOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b32 = S0.b32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b32 = S0.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP1Op_S_MOV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b64 = S0.b64
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b64 = S0.b64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _SOP1Op_S_CMOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if SCC then
  # D0.b32 = S0.b32
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  if SCC:
    D0.b32 = S0.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP1Op_S_CMOV_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # if SCC then
  # D0.b64 = S0.b64
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  if SCC:
    D0.b64 = S0.b64
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  result['d0_64'] = True
  return result

SOP1Op_FUNCTIONS = {
  SOP1Op.S_MOV_B32: _SOP1Op_S_MOV_B32,
  SOP1Op.S_MOV_B64: _SOP1Op_S_MOV_B64,
  SOP1Op.S_CMOV_B32: _SOP1Op_S_CMOV_B32,
  SOP1Op.S_CMOV_B64: _SOP1Op_S_CMOV_B64,
}

def _SOP2Op_S_ADD_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 64'U(S0.u32) + 64'U(S1.u32);
  # SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg((S0.u32) + (S1.u32))
  SCC = Reg(((1) if (tmp >= 0x100000000) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_SUB_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32 - S1.u32;
  # SCC = S1.u32 > S0.u32 ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32 - S1.u32)
  SCC = Reg(((1) if (S1.u32 > S0.u32) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_ADD_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.i32 + S1.i32;
  # SCC = ((S0.u32[31] == S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));
  # D0.i32 = tmp.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.i32 + S1.i32)
  SCC = Reg(((S0.u32[31] == S1.u32[31])  and  (S0.u32[31] != tmp.u32[31])))
  D0.i32 = tmp.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_SUB_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.i32 - S1.i32;
  # SCC = ((S0.u32[31] != S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));
  # D0.i32 = tmp.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.i32 - S1.i32)
  SCC = Reg(((S0.u32[31] != S1.u32[31])  and  (S0.u32[31] != tmp.u32[31])))
  D0.i32 = tmp.i32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_ADDC_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = 64'U(S0.u32) + 64'U(S1.u32) + SCC.u64;
  # SCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg((S0.u32) + (S1.u32) + SCC.u64)
  SCC = Reg(((1) if (tmp >= 0x100000000) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_SUBB_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp = S0.u32 - S1.u32 - SCC.u32;
  # SCC = 64'U(S1.u32) + SCC.u64 > 64'U(S0.u32) ? 1'1U : 1'0U;
  # D0.u32 = tmp.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  SCC = Reg(scc)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp = Reg(S0.u32 - S1.u32 - SCC.u32)
  SCC = Reg(((1) if ((S1.u32) + SCC.u64 > (S0.u32)) else (0)))
  D0.u32 = tmp.u32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': SCC._val & 1}
  return result

def _SOP2Op_S_PACK_LL_B32_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0 = { S1[15 : 0].u16, S0[15 : 0].u16 }
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0 = Reg(_pack(S1[15 : 0].u16, S0[15 : 0].u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP2Op_S_PACK_LH_B32_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0 = { S1[31 : 16].u16, S0[15 : 0].u16 }
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0 = Reg(_pack(S1[31 : 16].u16, S0[15 : 0].u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _SOP2Op_S_PACK_HH_B32_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0 = { S1[31 : 16].u16, S0[31 : 16].u16 }
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0 = Reg(_pack(S1[31 : 16].u16, S0[31 : 16].u16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

SOP2Op_FUNCTIONS = {
  SOP2Op.S_ADD_U32: _SOP2Op_S_ADD_U32,
  SOP2Op.S_SUB_U32: _SOP2Op_S_SUB_U32,
  SOP2Op.S_ADD_I32: _SOP2Op_S_ADD_I32,
  SOP2Op.S_SUB_I32: _SOP2Op_S_SUB_I32,
  SOP2Op.S_ADDC_U32: _SOP2Op_S_ADDC_U32,
  SOP2Op.S_SUBB_U32: _SOP2Op_S_SUBB_U32,
  SOP2Op.S_PACK_LL_B32_B16: _SOP2Op_S_PACK_LL_B32_B16,
  SOP2Op.S_PACK_LH_B32_B16: _SOP2Op_S_PACK_LH_B32_B16,
  SOP2Op.S_PACK_HH_B32_B16: _SOP2Op_S_PACK_HH_B32_B16,
}

def _SOPCOp_S_CMP_EQ_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 == S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 == S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LG_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 <> S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32  !=  S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_GT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 > S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 > S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_GE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 >= S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 >= S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LT_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 < S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 < S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LE_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.i32 <= S1.i32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.i32 <= S1.i32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_EQ_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 == S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 == S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LG_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 <> S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32  !=  S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_GT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 > S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 > S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_GE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 >= S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 >= S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LT_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 < S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 < S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_CMP_LE_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32 <= S1.u32
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32 <= S1.u32)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_BITCMP0_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32[S1.u32[4 : 0]] == 1'0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32[S1.u32[4 : 0]] == 0)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_BITCMP1_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u32[S1.u32[4 : 0]] == 1'1U
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u32[S1.u32[4 : 0]] == 1)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_BITCMP0_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u64[S1.u32[5 : 0]] == 1'0U
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u64[S1.u32[5 : 0]] == 0)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

def _SOPCOp_S_BITCMP1_B64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # SCC = S0.u64[S1.u32[5 : 0]] == 1'1U
  S0 = Reg(s0)
  S1 = Reg(s1)
  SCC = Reg(scc)
  # --- compiled pseudocode ---
  SCC = Reg(S0.u64[S1.u32[5 : 0]] == 1)
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': SCC._val & 1}
  return result

SOPCOp_FUNCTIONS = {
  SOPCOp.S_CMP_EQ_I32: _SOPCOp_S_CMP_EQ_I32,
  SOPCOp.S_CMP_LG_I32: _SOPCOp_S_CMP_LG_I32,
  SOPCOp.S_CMP_GT_I32: _SOPCOp_S_CMP_GT_I32,
  SOPCOp.S_CMP_GE_I32: _SOPCOp_S_CMP_GE_I32,
  SOPCOp.S_CMP_LT_I32: _SOPCOp_S_CMP_LT_I32,
  SOPCOp.S_CMP_LE_I32: _SOPCOp_S_CMP_LE_I32,
  SOPCOp.S_CMP_EQ_U32: _SOPCOp_S_CMP_EQ_U32,
  SOPCOp.S_CMP_LG_U32: _SOPCOp_S_CMP_LG_U32,
  SOPCOp.S_CMP_GT_U32: _SOPCOp_S_CMP_GT_U32,
  SOPCOp.S_CMP_GE_U32: _SOPCOp_S_CMP_GE_U32,
  SOPCOp.S_CMP_LT_U32: _SOPCOp_S_CMP_LT_U32,
  SOPCOp.S_CMP_LE_U32: _SOPCOp_S_CMP_LE_U32,
  SOPCOp.S_BITCMP0_B32: _SOPCOp_S_BITCMP0_B32,
  SOPCOp.S_BITCMP1_B32: _SOPCOp_S_BITCMP1_B32,
  SOPCOp.S_BITCMP0_B64: _SOPCOp_S_BITCMP0_B64,
  SOPCOp.S_BITCMP1_B64: _SOPCOp_S_BITCMP1_B64,
}

def _SOPKOp_S_MOVK_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = 32'I(signext(S0.i16))
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = (signext(S0.i16))
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

SOPKOp_FUNCTIONS = {
  SOPKOp.S_MOVK_I32: _SOPKOp_S_MOVK_I32,
}

def _SOPPOp_S_NOP(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # for i in 0U : SIMM16.u16[3 : 0].u32 do
  # endfor
  SIMM16 = Reg(literal)
  # --- compiled pseudocode ---
  for i in range(0, int(SIMM16.u16[3 : 0].u32)+1):
    pass
  # --- end pseudocode ---
  result = {'d0': d0, 'scc': scc & 1}
  return result

SOPPOp_FUNCTIONS = {
  SOPPOp.S_NOP: _SOPPOp_S_NOP,
}

def _VOP1Op_V_MOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b32 = S0.b32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b32 = S0.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_READFIRSTLANE_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare lane : 32'I;
  # if EXEC == 0x0LL then
  # lane = 0;
  # // Force lane 0 if all lanes are disabled
  # else
  # lane = s_ff1_i32_b64(EXEC);
  # // Lowest active lane
  # endif;
  # D0.b32 = VGPR[lane][SRC0.u32]
  D0 = Reg(d0)
  EXEC = Reg(exec_mask)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  if EXEC == 0x0:
    lane = 0
  else:
    lane = s_ff1_i32_b64(EXEC)
  D0.b32 = VGPR[lane][SRC0.u32]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  return result

def _VOP1Op_V_CVT_I32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f64_to_i32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f64_to_i32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F64_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = i32_to_f64(S0.i32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = i32_to_f64(S0.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_CVT_F32_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = i32_to_f32(S0.i32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = i32_to_f32(S0.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0.u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_U32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = f32_to_u32(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = f32_to_u32(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f32_to_i32(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f32_to_i32(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F16_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = f32_to_f16(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = f32_to_f16(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = f16_to_f32(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = f16_to_f32(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = f64_to_f32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = f64_to_f32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F64_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = f32_to_f64(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = f32_to_f64(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_CVT_F32_UBYTE0(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[7 : 0].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[7 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_UBYTE1(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[15 : 8].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[15 : 8].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_UBYTE2(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[23 : 16].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[23 : 16].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F32_UBYTE3(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[31 : 24].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[31 : 24].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_U32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = f64_to_u32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = f64_to_u32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP1Op_V_CVT_F64_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = u32_to_f64(S0.u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = u32_to_f64(S0.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_TRUNC_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_CEIL_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64);
  # if ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then
  # D0.f64 += 1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  if ((S0.f64 > 0.0)  and  (S0.f64 != D0.f64)):
    D0.f64 += 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_RNDNE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = floor(S0.f64 + 0.5);
  # if (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then
  # D0.f64 -= 1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = floor(S0.f64 + 0.5)
  if (isEven(floor(S0.f64))  and  (fract(S0.f64) == 0.5)):
    D0.f64 -= 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP1Op_V_FLOOR_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64);
  # if ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then
  # D0.f64 += -1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  if ((S0.f64 < 0.0)  and  (S0.f64 != D0.f64)):
    D0.f64 += -1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

VOP1Op_FUNCTIONS = {
  VOP1Op.V_MOV_B32: _VOP1Op_V_MOV_B32,
  VOP1Op.V_READFIRSTLANE_B32: _VOP1Op_V_READFIRSTLANE_B32,
  VOP1Op.V_CVT_I32_F64: _VOP1Op_V_CVT_I32_F64,
  VOP1Op.V_CVT_F64_I32: _VOP1Op_V_CVT_F64_I32,
  VOP1Op.V_CVT_F32_I32: _VOP1Op_V_CVT_F32_I32,
  VOP1Op.V_CVT_F32_U32: _VOP1Op_V_CVT_F32_U32,
  VOP1Op.V_CVT_U32_F32: _VOP1Op_V_CVT_U32_F32,
  VOP1Op.V_CVT_I32_F32: _VOP1Op_V_CVT_I32_F32,
  VOP1Op.V_CVT_F16_F32: _VOP1Op_V_CVT_F16_F32,
  VOP1Op.V_CVT_F32_F16: _VOP1Op_V_CVT_F32_F16,
  VOP1Op.V_CVT_F32_F64: _VOP1Op_V_CVT_F32_F64,
  VOP1Op.V_CVT_F64_F32: _VOP1Op_V_CVT_F64_F32,
  VOP1Op.V_CVT_F32_UBYTE0: _VOP1Op_V_CVT_F32_UBYTE0,
  VOP1Op.V_CVT_F32_UBYTE1: _VOP1Op_V_CVT_F32_UBYTE1,
  VOP1Op.V_CVT_F32_UBYTE2: _VOP1Op_V_CVT_F32_UBYTE2,
  VOP1Op.V_CVT_F32_UBYTE3: _VOP1Op_V_CVT_F32_UBYTE3,
  VOP1Op.V_CVT_U32_F64: _VOP1Op_V_CVT_U32_F64,
  VOP1Op.V_CVT_F64_U32: _VOP1Op_V_CVT_F64_U32,
  VOP1Op.V_TRUNC_F64: _VOP1Op_V_TRUNC_F64,
  VOP1Op.V_CEIL_F64: _VOP1Op_V_CEIL_F64,
  VOP1Op.V_RNDNE_F64: _VOP1Op_V_RNDNE_F64,
  VOP1Op.V_FLOOR_F64: _VOP1Op_V_FLOOR_F64,
}

def _VOP2Op_V_PK_FMAC_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16);
  # D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16)
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16)
  D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

VOP2Op_FUNCTIONS = {
  VOP2Op.V_PK_FMAC_F16: _VOP2Op_V_PK_FMAC_F16,
}

def _VOP3Op_V_MOV_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.b32 = S0.b32
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.b32 = S0.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_READFIRSTLANE_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare lane : 32'I;
  # if EXEC == 0x0LL then
  # lane = 0;
  # // Force lane 0 if all lanes are disabled
  # else
  # lane = s_ff1_i32_b64(EXEC);
  # // Lowest active lane
  # endif;
  # D0.b32 = VGPR[lane][SRC0.u32]
  D0 = Reg(d0)
  EXEC = Reg(exec_mask)
  SRC0 = Reg(src0_idx)
  # --- compiled pseudocode ---
  if EXEC == 0x0:
    lane = 0
  else:
    lane = s_ff1_i32_b64(EXEC)
  D0.b32 = VGPR[lane][SRC0.u32]
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if EXEC._val != exec_mask: result['exec'] = EXEC._val
  return result

def _VOP3Op_V_CVT_I32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f64_to_i32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f64_to_i32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F64_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = i32_to_f64(S0.i32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = i32_to_f64(S0.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3Op_V_CVT_F32_I32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = i32_to_f32(S0.i32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = i32_to_f32(S0.i32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F32_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0.u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_U32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = f32_to_u32(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = f32_to_u32(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_I32_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.i32 = f32_to_i32(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.i32 = f32_to_i32(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F16_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f16 = f32_to_f16(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f16 = f32_to_f16(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F32_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = f16_to_f32(S0.f16)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = f16_to_f32(S0.f16)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = f64_to_f32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = f64_to_f32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F64_F32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = f32_to_f64(S0.f32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = f32_to_f64(S0.f32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3Op_V_CVT_F32_UBYTE0(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[7 : 0].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[7 : 0].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F32_UBYTE1(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[15 : 8].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[15 : 8].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F32_UBYTE2(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[23 : 16].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[23 : 16].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F32_UBYTE3(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f32 = u32_to_f32(S0[31 : 24].u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f32 = u32_to_f32(S0[31 : 24].u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_U32_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.u32 = f64_to_u32(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.u32 = f64_to_u32(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3Op_V_CVT_F64_U32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = u32_to_f64(S0.u32)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = u32_to_f64(S0.u32)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3Op_V_TRUNC_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64)
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3Op_V_CEIL_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64);
  # if ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then
  # D0.f64 += 1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  if ((S0.f64 > 0.0)  and  (S0.f64 != D0.f64)):
    D0.f64 += 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3Op_V_RNDNE_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = floor(S0.f64 + 0.5);
  # if (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then
  # D0.f64 -= 1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = floor(S0.f64 + 0.5)
  if (isEven(floor(S0.f64))  and  (fract(S0.f64) == 0.5)):
    D0.f64 -= 1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

def _VOP3Op_V_FLOOR_F64(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # D0.f64 = trunc(S0.f64);
  # if ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then
  # D0.f64 += -1.0
  # endif
  S0 = Reg(s0)
  D0 = Reg(d0)
  # --- compiled pseudocode ---
  D0.f64 = trunc(S0.f64)
  if ((S0.f64 < 0.0)  and  (S0.f64 != D0.f64)):
    D0.f64 += -1.0
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  result['d0_64'] = True
  return result

VOP3Op_FUNCTIONS = {
  VOP3Op.V_MOV_B32: _VOP3Op_V_MOV_B32,
  VOP3Op.V_READFIRSTLANE_B32: _VOP3Op_V_READFIRSTLANE_B32,
  VOP3Op.V_CVT_I32_F64: _VOP3Op_V_CVT_I32_F64,
  VOP3Op.V_CVT_F64_I32: _VOP3Op_V_CVT_F64_I32,
  VOP3Op.V_CVT_F32_I32: _VOP3Op_V_CVT_F32_I32,
  VOP3Op.V_CVT_F32_U32: _VOP3Op_V_CVT_F32_U32,
  VOP3Op.V_CVT_U32_F32: _VOP3Op_V_CVT_U32_F32,
  VOP3Op.V_CVT_I32_F32: _VOP3Op_V_CVT_I32_F32,
  VOP3Op.V_CVT_F16_F32: _VOP3Op_V_CVT_F16_F32,
  VOP3Op.V_CVT_F32_F16: _VOP3Op_V_CVT_F32_F16,
  VOP3Op.V_CVT_F32_F64: _VOP3Op_V_CVT_F32_F64,
  VOP3Op.V_CVT_F64_F32: _VOP3Op_V_CVT_F64_F32,
  VOP3Op.V_CVT_F32_UBYTE0: _VOP3Op_V_CVT_F32_UBYTE0,
  VOP3Op.V_CVT_F32_UBYTE1: _VOP3Op_V_CVT_F32_UBYTE1,
  VOP3Op.V_CVT_F32_UBYTE2: _VOP3Op_V_CVT_F32_UBYTE2,
  VOP3Op.V_CVT_F32_UBYTE3: _VOP3Op_V_CVT_F32_UBYTE3,
  VOP3Op.V_CVT_U32_F64: _VOP3Op_V_CVT_U32_F64,
  VOP3Op.V_CVT_F64_U32: _VOP3Op_V_CVT_F64_U32,
  VOP3Op.V_TRUNC_F64: _VOP3Op_V_TRUNC_F64,
  VOP3Op.V_CEIL_F64: _VOP3Op_V_CEIL_F64,
  VOP3Op.V_RNDNE_F64: _VOP3Op_V_RNDNE_F64,
  VOP3Op.V_FLOOR_F64: _VOP3Op_V_FLOOR_F64,
}

def _VOP3POp_V_PK_MAD_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 * S1[15 : 0].i16 + S2[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 * S1[31 : 16].i16 + S2[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = S0[15 : 0].i16 * S1[15 : 0].i16 + S2[15 : 0].i16
  tmp[31 : 16].i16 = S0[31 : 16].i16 * S1[31 : 16].i16 + S2[31 : 16].i16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MUL_LO_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16;
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16
  tmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_ADD_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 + S1[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 + S1[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = S0[15 : 0].i16 + S1[15 : 0].i16
  tmp[31 : 16].i16 = S0[31 : 16].i16 + S1[31 : 16].i16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_SUB_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 - S1[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 - S1[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = S0[15 : 0].i16 - S1[15 : 0].i16
  tmp[31 : 16].i16 = S0[31 : 16].i16 - S1[31 : 16].i16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_LSHLREV_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].u16 = (S1[31 : 16].u16 << S0.u32[19 : 16].u32);
  # tmp[15 : 0].u16 = (S1[15 : 0].u16 << S0.u32[3 : 0].u32);
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].u16 = (S1[31 : 16].u16 << S0.u32[19 : 16].u32)
  tmp[15 : 0].u16 = (S1[15 : 0].u16 << S0.u32[3 : 0].u32)
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_LSHRREV_B16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].u16 = (S1[31 : 16].u16 >> S0.u32[19 : 16].u32);
  # tmp[15 : 0].u16 = (S1[15 : 0].u16 >> S0.u32[3 : 0].u32);
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].u16 = (S1[31 : 16].u16 >> S0.u32[19 : 16].u32)
  tmp[15 : 0].u16 = (S1[15 : 0].u16 >> S0.u32[3 : 0].u32)
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_ASHRREV_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # tmp[31 : 16].i16 = (S1[31 : 16].i16 >> S0.u32[19 : 16].u32);
  # tmp[15 : 0].i16 = (S1[15 : 0].i16 >> S0.u32[3 : 0].u32);
  # D0.b32 = tmp.b32
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[31 : 16].i16 = (S1[31 : 16].i16 >> S0.u32[19 : 16].u32)
  tmp[15 : 0].i16 = (S1[15 : 0].i16 >> S0.u32[3 : 0].u32)
  D0.b32 = tmp.b32
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAX_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 >= S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 >= S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = ((S0[15 : 0].i16) if (S0[15 : 0].i16 >= S1[15 : 0].i16) else (S1[15 : 0].i16))
  tmp[31 : 16].i16 = ((S0[31 : 16].i16) if (S0[31 : 16].i16 >= S1[31 : 16].i16) else (S1[31 : 16].i16))
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MIN_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].i16 = S0[15 : 0].i16 < S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16;
  # tmp[31 : 16].i16 = S0[31 : 16].i16 < S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].i16 = ((S0[15 : 0].i16) if (S0[15 : 0].i16 < S1[15 : 0].i16) else (S1[15 : 0].i16))
  tmp[31 : 16].i16 = ((S0[31 : 16].i16) if (S0[31 : 16].i16 < S1[31 : 16].i16) else (S1[31 : 16].i16))
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAD_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16 + S2[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16 + S2[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16 + S2[15 : 0].u16
  tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16 + S2[31 : 16].u16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_ADD_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 + S1[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 + S1[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = S0[15 : 0].u16 + S1[15 : 0].u16
  tmp[31 : 16].u16 = S0[31 : 16].u16 + S1[31 : 16].u16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_SUB_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 - S1[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 - S1[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = S0[15 : 0].u16 - S1[15 : 0].u16
  tmp[31 : 16].u16 = S0[31 : 16].u16 - S1[31 : 16].u16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAX_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 >= S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 >= S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = ((S0[15 : 0].u16) if (S0[15 : 0].u16 >= S1[15 : 0].u16) else (S1[15 : 0].u16))
  tmp[31 : 16].u16 = ((S0[31 : 16].u16) if (S0[31 : 16].u16 >= S1[31 : 16].u16) else (S1[31 : 16].u16))
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MIN_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].u16 = S0[15 : 0].u16 < S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16;
  # tmp[31 : 16].u16 = S0[31 : 16].u16 < S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].u16 = ((S0[15 : 0].u16) if (S0[15 : 0].u16 < S1[15 : 0].u16) else (S1[15 : 0].u16))
  tmp[31 : 16].u16 = ((S0[31 : 16].u16) if (S0[31 : 16].u16 < S1[31 : 16].u16) else (S1[31 : 16].u16))
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_FMA_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16);
  # tmp[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16);
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  S2 = Reg(s2)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16)
  tmp[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16)
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_ADD_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = S0[15 : 0].f16 + S1[15 : 0].f16;
  # tmp[31 : 16].f16 = S0[31 : 16].f16 + S1[31 : 16].f16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = S0[15 : 0].f16 + S1[15 : 0].f16
  tmp[31 : 16].f16 = S0[31 : 16].f16 + S1[31 : 16].f16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MUL_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = S0[15 : 0].f16 * S1[15 : 0].f16;
  # tmp[31 : 16].f16 = S0[31 : 16].f16 * S1[31 : 16].f16;
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = S0[15 : 0].f16 * S1[15 : 0].f16
  tmp[31 : 16].f16 = S0[31 : 16].f16 * S1[31 : 16].f16
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MIN_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = v_min_f16(S0[15 : 0].f16, S1[15 : 0].f16);
  # tmp[31 : 16].f16 = v_min_f16(S0[31 : 16].f16, S1[31 : 16].f16);
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = v_min_f16(S0[15 : 0].f16, S1[15 : 0].f16)
  tmp[31 : 16].f16 = v_min_f16(S0[31 : 16].f16, S1[31 : 16].f16)
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

def _VOP3POp_V_PK_MAX_F16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # declare tmp : 32'B;
  # tmp[15 : 0].f16 = v_max_f16(S0[15 : 0].f16, S1[15 : 0].f16);
  # tmp[31 : 16].f16 = v_max_f16(S0[31 : 16].f16, S1[31 : 16].f16);
  # D0.b32 = tmp
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  tmp = Reg(0)
  # --- compiled pseudocode ---
  tmp[15 : 0].f16 = v_max_f16(S0[15 : 0].f16, S1[15 : 0].f16)
  tmp[31 : 16].f16 = v_max_f16(S0[31 : 16].f16, S1[31 : 16].f16)
  D0.b32 = tmp
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  return result

VOP3POp_FUNCTIONS = {
  VOP3POp.V_PK_MAD_I16: _VOP3POp_V_PK_MAD_I16,
  VOP3POp.V_PK_MUL_LO_U16: _VOP3POp_V_PK_MUL_LO_U16,
  VOP3POp.V_PK_ADD_I16: _VOP3POp_V_PK_ADD_I16,
  VOP3POp.V_PK_SUB_I16: _VOP3POp_V_PK_SUB_I16,
  VOP3POp.V_PK_LSHLREV_B16: _VOP3POp_V_PK_LSHLREV_B16,
  VOP3POp.V_PK_LSHRREV_B16: _VOP3POp_V_PK_LSHRREV_B16,
  VOP3POp.V_PK_ASHRREV_I16: _VOP3POp_V_PK_ASHRREV_I16,
  VOP3POp.V_PK_MAX_I16: _VOP3POp_V_PK_MAX_I16,
  VOP3POp.V_PK_MIN_I16: _VOP3POp_V_PK_MIN_I16,
  VOP3POp.V_PK_MAD_U16: _VOP3POp_V_PK_MAD_U16,
  VOP3POp.V_PK_ADD_U16: _VOP3POp_V_PK_ADD_U16,
  VOP3POp.V_PK_SUB_U16: _VOP3POp_V_PK_SUB_U16,
  VOP3POp.V_PK_MAX_U16: _VOP3POp_V_PK_MAX_U16,
  VOP3POp.V_PK_MIN_U16: _VOP3POp_V_PK_MIN_U16,
  VOP3POp.V_PK_FMA_F16: _VOP3POp_V_PK_FMA_F16,
  VOP3POp.V_PK_ADD_F16: _VOP3POp_V_PK_ADD_F16,
  VOP3POp.V_PK_MUL_F16: _VOP3POp_V_PK_MUL_F16,
  VOP3POp.V_PK_MIN_F16: _VOP3POp_V_PK_MIN_F16,
  VOP3POp.V_PK_MAX_F16: _VOP3POp_V_PK_MAX_F16,
}

def _VOPCOp_V_CMPX_LT_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 < S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 < S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_EQ_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 == S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 == S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_LE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 <= S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 <= S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_GT_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 > S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 > S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_NE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 <> S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16  !=  S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_GE_I16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 >= S1.i16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.i16 >= S1.i16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_LT_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 < S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 < S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_EQ_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 == S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 == S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_LE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 <= S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 <= S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_GT_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 > S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 > S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_NE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC mask and to VCC or a scalar register.
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 <> S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16  !=  S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

def _VOPCOp_V_CMPX_GE_U16(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  # EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 >= S1.u16;
  # // D0 = VCC in VOPC encoding.
  S0 = Reg(s0)
  S1 = Reg(s1)
  D0 = Reg(d0)
  VCC = Reg(vcc)
  EXEC = Reg(exec_mask)
  laneId = lane
  # --- compiled pseudocode ---
  EXEC.u64[laneId] = D0.u64[laneId] = S0.u16 >= S1.u16
  # --- end pseudocode ---
  result = {'d0': D0._val, 'scc': scc & 1}
  if VCC._val != vcc: result['vcc_lane'] = (VCC._val >> lane) & 1
  result['exec_lane'] = (EXEC._val >> lane) & 1
  result['vcc_lane'] = (D0._val >> lane) & 1
  result['d0_64'] = True
  return result

VOPCOp_FUNCTIONS = {
  VOPCOp.V_CMPX_LT_I16: _VOPCOp_V_CMPX_LT_I16,
  VOPCOp.V_CMPX_EQ_I16: _VOPCOp_V_CMPX_EQ_I16,
  VOPCOp.V_CMPX_LE_I16: _VOPCOp_V_CMPX_LE_I16,
  VOPCOp.V_CMPX_GT_I16: _VOPCOp_V_CMPX_GT_I16,
  VOPCOp.V_CMPX_NE_I16: _VOPCOp_V_CMPX_NE_I16,
  VOPCOp.V_CMPX_GE_I16: _VOPCOp_V_CMPX_GE_I16,
  VOPCOp.V_CMPX_LT_U16: _VOPCOp_V_CMPX_LT_U16,
  VOPCOp.V_CMPX_EQ_U16: _VOPCOp_V_CMPX_EQ_U16,
  VOPCOp.V_CMPX_LE_U16: _VOPCOp_V_CMPX_LE_U16,
  VOPCOp.V_CMPX_GT_U16: _VOPCOp_V_CMPX_GT_U16,
  VOPCOp.V_CMPX_NE_U16: _VOPCOp_V_CMPX_NE_U16,
  VOPCOp.V_CMPX_GE_U16: _VOPCOp_V_CMPX_GE_U16,
}


# V_WRITELANE_B32: Write scalar to specific lane's VGPR (not in PDF pseudocode)
def _VOP3Op_V_WRITELANE_B32(s0, s1, s2, d0, scc, vcc, lane, exec_mask, literal, VGPR, _vars, src0_idx=0, vdst_idx=0):
  wr_lane = s1 & 0x1f  # lane select (5 bits for wave32)
  return {'d0': d0, 'scc': scc, 'vgpr_write': (wr_lane, vdst_idx, s0 & 0xffffffff)}
VOP3Op_FUNCTIONS[VOP3Op.V_WRITELANE_B32] = _VOP3Op_V_WRITELANE_B32

COMPILED_FUNCTIONS = {
  SOP1Op: SOP1Op_FUNCTIONS,
  SOP2Op: SOP2Op_FUNCTIONS,
  SOPCOp: SOPCOp_FUNCTIONS,
  SOPKOp: SOPKOp_FUNCTIONS,
  SOPPOp: SOPPOp_FUNCTIONS,
  VOP1Op: VOP1Op_FUNCTIONS,
  VOP2Op: VOP2Op_FUNCTIONS,
  VOP3Op: VOP3Op_FUNCTIONS,
  VOP3POp: VOP3POp_FUNCTIONS,
  VOPCOp: VOPCOp_FUNCTIONS,
}

def get_compiled_functions(): return COMPILED_FUNCTIONS