# autogenerated by pdf2.py - do not edit
# to regenerate: python -m extra.assembly.amd.pdf2
# ruff: noqa: E501
from extra.assembly.amd.autogen.rdna3.enum import DSOp, FLATOp, GLOBALOp, MIMGOp, MTBUFOp, MUBUFOp, SCRATCHOp, SMEMOp, SOP1Op, SOP2Op, SOPCOp, SOPKOp, SOPPOp, VINTERPOp, VOP1Op, VOP2Op, VOP3Op, VOP3POp, VOP3SDOp

DSOp_PCODE = {
  DSOp.DS_ADD_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_SUB_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_RSUB_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 = DATA.u32 - MEM[ADDR].u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_INC_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_DEC_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_MIN_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  DSOp.DS_MAX_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  DSOp.DS_MIN_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_MAX_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_AND_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_OR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_XOR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_MSKOR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = ((tmp & ~DATA.b32) | DATA2.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_STORE_B32: 'MEM[ADDR + OFFSET.u32].b32 = DATA[31 : 0]',
  DSOp.DS_STORE_2ADDR_B32: 'MEM[ADDR + OFFSET0.u32 * 4U].b32 = DATA[31 : 0];\nMEM[ADDR + OFFSET1.u32 * 4U].b32 = DATA2[31 : 0]',
  DSOp.DS_STORE_2ADDR_STRIDE64_B32: 'MEM[ADDR + OFFSET0.u32 * 256U].b32 = DATA[31 : 0];\nMEM[ADDR + OFFSET1.u32 * 256U].b32 = DATA2[31 : 0]',
  DSOp.DS_CMPSTORE_B32: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ncmp = DATA2.b32;\nMEM[ADDR].b32 = tmp == cmp ? src : tmp;\nRETURN_DATA.b32 = tmp\nsrc\ncmp',
  DSOp.DS_CMPSTORE_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\ncmp = DATA2.f32;\nMEM[ADDR].f32 = tmp == cmp ? src : tmp;\nRETURN_DATA.f32 = tmp\nsrc\ncmp',
  DSOp.DS_MIN_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src < tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  DSOp.DS_MAX_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src > tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  DSOp.DS_ADD_F32: 'tmp = MEM[ADDR].f32;\nMEM[ADDR].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
  DSOp.DS_STORE_B8: 'MEM[ADDR].b8 = DATA[7 : 0]',
  DSOp.DS_STORE_B16: 'MEM[ADDR].b16 = DATA[15 : 0]',
  DSOp.DS_ADD_RTN_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_SUB_RTN_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_RSUB_RTN_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 = DATA.u32 - MEM[ADDR].u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_INC_RTN_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_DEC_RTN_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_MIN_RTN_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  DSOp.DS_MAX_RTN_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  DSOp.DS_MIN_RTN_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_MAX_RTN_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_AND_RTN_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_OR_RTN_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_XOR_RTN_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_MSKOR_RTN_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = ((tmp & ~DATA.b32) | DATA2.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_STOREXCHG_RTN_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  DSOp.DS_STOREXCHG_2ADDR_RTN_B32: 'addr1 = ADDR_BASE.u32 + OFFSET0.u32 * 4U;\naddr2 = ADDR_BASE.u32 + OFFSET1.u32 * 4U;\ntmp1 = MEM[addr1].b32;\ntmp2 = MEM[addr2].b32;\nMEM[addr1].b32 = DATA.b32;\nMEM[addr2].b32 = DATA2.b32;\n// Note DATA2 can be any other register\nRETURN_DATA[31 : 0] = tmp1;\nRETURN_DATA[63 : 32] = tmp2',
  DSOp.DS_STOREXCHG_2ADDR_STRIDE64_RTN_B32: 'addr1 = ADDR_BASE.u32 + OFFSET0.u32 * 256U;\naddr2 = ADDR_BASE.u32 + OFFSET1.u32 * 256U;\ntmp1 = MEM[addr1].b32;\ntmp2 = MEM[addr2].b32;\nMEM[addr1].b32 = DATA.b32;\nMEM[addr2].b32 = DATA2.b32;\n// Note DATA2 can be any other register\nRETURN_DATA[31 : 0] = tmp1;\nRETURN_DATA[63 : 32] = tmp2',
  DSOp.DS_CMPSTORE_RTN_B32: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ncmp = DATA2.b32;\nMEM[ADDR].b32 = tmp == cmp ? src : tmp;\nRETURN_DATA.b32 = tmp\nsrc\ncmp',
  DSOp.DS_CMPSTORE_RTN_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\ncmp = DATA2.f32;\nMEM[ADDR].f32 = tmp == cmp ? src : tmp;\nRETURN_DATA.f32 = tmp\nsrc\ncmp',
  DSOp.DS_MIN_RTN_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src < tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  DSOp.DS_MAX_RTN_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src > tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  DSOp.DS_WRAP_RTN_B32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 = tmp >= DATA.u32 ? tmp - DATA.u32 : tmp + DATA2.u32;\nRETURN_DATA = tmp',
  DSOp.DS_SWIZZLE_B32: 'Ê       thread_out[i+1] = thread_valid[i+offset[3:2]]?thread_in[i+offset[3:2]]:0;\nÊ       thread_out[i+2] = thread_valid[i+offset[5:4]]?thread_in[i+offset[5:4]]:0;\nÊ       thread_out[i+3] = thread_valid[i+offset[7:6]]?thread_in[i+offset[7:6]]:0;\nÊ   }\n} else { // offset[15] == 0\nÊ   // limited data sharing within 32 consecutive threads\nÊ   xor_mask = offset[14:10];\nÊ   or_mask = offset[9:5];\nÊ   and_mask = offset[4:0];\nÊ   for (i = 0; i < 64; i++) {\nÊ       j = (((i & 0x1f) & and_mask) | or_mask) ^ xor_mask;\nÊ       j |= (i & 0x20); // which group of 32\nÊ       thread_out[i] = thread_valid[j] ? thread_in[j] : 0;\nÊ   }\n}\noffset = offset1:offset0;\nif (offset >= 0xe000) {\nÊ   // FFT decomposition\nÊ   mask = offset[4:0];\nÊ   for (i = 0; i < 64; i++) {\nÊ       j = reverse_bits(i & 0x1f);\nÊ       j = (j >> count_ones(mask));\nÊ       j |= (i & mask);\nÊ       j |= i & 0x20;\nÊ       thread_out[i] = thread_valid[j] ? thread_in[j] : 0;\nÊ   }\n} elsif (offset >= 0xc000) {\nÊ   // rotate\nÊ   rotate = offset[9:5];\nÊ   mask = offset[4:0];\nÊ   if (offset[10]) {\nÊ       rotate = -rotate;\nÊ   }\nÊ   for (i = 0; i < 64; i++) {\nÊ       j = (i & mask) | ((i + rotate) & ~mask);\nÊ       j |= i & 0x20;\nÊ       thread_out[i] = thread_valid[j] ? thread_in[j] : 0;\nÊ   }\n} elsif (offset[15]) {\nÊ   // full data sharing within 4 consecutive threads\nÊ   for (i = 0; i < 64; i+=4) {\nÊ       thread_out[i+0] = thread_valid[i+offset[1:0]]?thread_in[i+offset[1:0]]:0;',
  DSOp.DS_LOAD_B32: 'RETURN_DATA[31 : 0] = MEM[ADDR + OFFSET.u32].b32',
  DSOp.DS_LOAD_2ADDR_B32: 'RETURN_DATA[31 : 0] = MEM[ADDR + OFFSET0.u32 * 4U].b32;\nRETURN_DATA[63 : 32] = MEM[ADDR + OFFSET1.u32 * 4U].b32',
  DSOp.DS_LOAD_2ADDR_STRIDE64_B32: 'RETURN_DATA[31 : 0] = MEM[ADDR + OFFSET0.u32 * 256U].b32;\nRETURN_DATA[63 : 32] = MEM[ADDR + OFFSET1.u32 * 256U].b32',
  DSOp.DS_LOAD_I8: "RETURN_DATA.i32 = 32'I(signext(MEM[ADDR].i8))",
  DSOp.DS_LOAD_U8: "RETURN_DATA.u32 = 32'U({ 24'0U, MEM[ADDR].u8 })",
  DSOp.DS_LOAD_I16: "RETURN_DATA.i32 = 32'I(signext(MEM[ADDR].i16))",
  DSOp.DS_LOAD_U16: "RETURN_DATA.u32 = 32'U({ 16'0U, MEM[ADDR].u16 })",
  DSOp.DS_CONSUME: 'addr = M0.base + offset; // offset by LDS HWBASE, limit to M.size\nrtnval =  LDS(addr);\nLDS(addr) = LDS(addr) - countbits(valid mask);\nGPR[VDST] = rtnval; // return to all valid threads',
  DSOp.DS_APPEND: 'addr = M0.base + offset; // offset by LDS HWBASE, limit to M.size\nrtnval =  LDS(addr);\nLDS(addr) = LDS(addr) + countbits(valid mask);\nGPR[VDST] = rtnval; // return to all valid threads',
  DSOp.DS_ADD_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_SUB_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_RSUB_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 = DATA.u64 - MEM[ADDR].u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_INC_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_DEC_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_MIN_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  DSOp.DS_MAX_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  DSOp.DS_MIN_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_MAX_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src >= tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_AND_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_OR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_XOR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_MSKOR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = ((tmp & ~DATA.b64) | DATA2.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_STORE_B64: 'MEM[ADDR + OFFSET.u32].b32 = DATA[31 : 0];\nMEM[ADDR + OFFSET.u32 + 4U].b32 = DATA[63 : 32]',
  DSOp.DS_STORE_2ADDR_B64: 'MEM[ADDR + OFFSET0.u32 * 8U].b32 = DATA[31 : 0];\nMEM[ADDR + OFFSET0.u32 * 8U + 4U].b32 = DATA[63 : 32];\nMEM[ADDR + OFFSET1.u32 * 8U].b32 = DATA2[31 : 0];\nMEM[ADDR + OFFSET1.u32 * 8U + 4U].b32 = DATA2[63 : 32]',
  DSOp.DS_STORE_2ADDR_STRIDE64_B64: 'MEM[ADDR + OFFSET1.u32 * 512U + 4U].b32 = DATA2[63 : 32]\nMEM[ADDR + OFFSET0.u32 * 512U].b32 = DATA[31 : 0];\nMEM[ADDR + OFFSET0.u32 * 512U + 4U].b32 = DATA[63 : 32];\nMEM[ADDR + OFFSET1.u32 * 512U].b32 = DATA2[31 : 0];',
  DSOp.DS_CMPSTORE_B64: 'tmp = MEM[ADDR].b64;\nsrc = DATA.b64;\ncmp = DATA2.b64;\nMEM[ADDR].b64 = tmp == cmp ? src : tmp;\nRETURN_DATA.b64 = tmp\nsrc\ncmp',
  DSOp.DS_CMPSTORE_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\ncmp = DATA2.f64;\nMEM[ADDR].f64 = tmp == cmp ? src : tmp;\nRETURN_DATA.f64 = tmp\nsrc\ncmp',
  DSOp.DS_MIN_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nMEM[ADDR].f64 = src < tmp ? src : tmp;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_MAX_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nMEM[ADDR].f64 = src > tmp ? src : tmp;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_ADD_RTN_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_SUB_RTN_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_RSUB_RTN_U64: 'MEM[ADDR].u64 = DATA.u64 - MEM[ADDR].u64;\nRETURN_DATA.u64 = tmp\ntmp = MEM[ADDR].u64;',
  DSOp.DS_INC_RTN_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_DEC_RTN_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_MIN_RTN_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  DSOp.DS_MAX_RTN_I64: 'src = DATA.i64;\nMEM[ADDR].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp\ntmp = MEM[ADDR].i64;',
  DSOp.DS_MIN_RTN_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_MAX_RTN_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src >= tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_AND_RTN_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_OR_RTN_B64: 'RETURN_DATA.b64 = tmp\ntmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);',
  DSOp.DS_XOR_RTN_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_MSKOR_RTN_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = ((tmp & ~DATA.b64) | DATA2.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_STOREXCHG_RTN_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp',
  DSOp.DS_STOREXCHG_2ADDR_RTN_B64: 'RETURN_DATA[127 : 64] = tmp2\naddr1 = ADDR_BASE.u32 + OFFSET0.u32 * 8U;\naddr2 = ADDR_BASE.u32 + OFFSET1.u32 * 8U;\ntmp1 = MEM[addr1].b64;\ntmp2 = MEM[addr2].b64;\nMEM[addr1].b64 = DATA.b64;\nMEM[addr2].b64 = DATA2.b64;\n// Note DATA2 can be any other register\nRETURN_DATA[63 : 0] = tmp1;',
  DSOp.DS_STOREXCHG_2ADDR_STRIDE64_RTN_B64: 'addr1 = ADDR_BASE.u32 + OFFSET0.u32 * 512U;\naddr2 = ADDR_BASE.u32 + OFFSET1.u32 * 512U;\ntmp1 = MEM[addr1].b64;\ntmp2 = MEM[addr2].b64;\nMEM[addr1].b64 = DATA.b64;\nMEM[addr2].b64 = DATA2.b64;\n// Note DATA2 can be any other register\nRETURN_DATA[63 : 0] = tmp1;\nRETURN_DATA[127 : 64] = tmp2',
  DSOp.DS_CMPSTORE_RTN_B64: 'tmp = MEM[ADDR].b64;\nsrc = DATA.b64;\ncmp = DATA2.b64;\nMEM[ADDR].b64 = tmp == cmp ? src : tmp;\nRETURN_DATA.b64 = tmp\nsrc\ncmp',
  DSOp.DS_CMPSTORE_RTN_F64: 'src\ncmp\ntmp = MEM[ADDR].f64;\nsrc = DATA.f64;\ncmp = DATA2.f64;\nMEM[ADDR].f64 = tmp == cmp ? src : tmp;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_MIN_RTN_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nMEM[ADDR].f64 = src < tmp ? src : tmp;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_MAX_RTN_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nMEM[ADDR].f64 = src > tmp ? src : tmp;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_LOAD_B64: 'RETURN_DATA[31 : 0] = MEM[ADDR + OFFSET.u32].b32;\nRETURN_DATA[63 : 32] = MEM[ADDR + OFFSET.u32 + 4U].b32',
  DSOp.DS_LOAD_2ADDR_B64: 'RETURN_DATA[31 : 0] = MEM[ADDR + OFFSET0.u32 * 8U].b32;\nRETURN_DATA[63 : 32] = MEM[ADDR + OFFSET0.u32 * 8U + 4U].b32;\nRETURN_DATA[95 : 64] = MEM[ADDR + OFFSET1.u32 * 8U].b32;\nRETURN_DATA[127 : 96] = MEM[ADDR + OFFSET1.u32 * 8U + 4U].b32',
  DSOp.DS_LOAD_2ADDR_STRIDE64_B64: 'RETURN_DATA[31 : 0] = MEM[ADDR + OFFSET0.u32 * 512U].b32;\nRETURN_DATA[63 : 32] = MEM[ADDR + OFFSET0.u32 * 512U + 4U].b32;\nRETURN_DATA[95 : 64] = MEM[ADDR + OFFSET1.u32 * 512U].b32;\nRETURN_DATA[127 : 96] = MEM[ADDR + OFFSET1.u32 * 512U + 4U].b32',
  DSOp.DS_ADD_RTN_F32: 'tmp = MEM[ADDR].f32;\nMEM[ADDR].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
  DSOp.DS_ADD_GS_REG_RTN: 'Ê   VDST[0] = GS_REGS(addr + 0);\nÊ   VDST[1] = GS_REGS(addr + 1);\nÊ   {GS_REGS(addr + 1), GS_REGS(addr)} += DATA0[0]; // source is 32 bit\nelse\nÊ   addr = OFFSET0[5:2];\nÊ   VDST[0] = GS_REGS(addr);\nÊ   GS_REGS(addr) += DATA0[0];\nendif.\nif OFFSET0[5:2] > 7\nÊ   // 64-bit GS register access\nÊ   addr = (OFFSET0[5:2] - 8) * 2 + 8;',
  DSOp.DS_SUB_GS_REG_RTN: 'Ê   GS_REGS(addr) -= DATA0[0];\nendif.\nif OFFSET0[5:2] > 7\nÊ   // 64-bit GS register access\nÊ   addr = (OFFSET0[5:2] - 8) * 2 + 8;\nÊ   VDST[0] = GS_REGS(addr + 0);\nÊ   VDST[1] = GS_REGS(addr + 1);\nÊ   {GS_REGS(addr + 1), GS_REGS(addr)} -= DATA0[0]; // source is 32 bit\nelse\nÊ   addr = OFFSET0[5:2];\nÊ   VDST[0] = GS_REGS(addr);',
  DSOp.DS_CONDXCHG32_RTN_B64: "declare OFFSET0 : 8'U;\ndeclare OFFSET1 : 8'U;\ndeclare RETURN_DATA : 32'U[2];\nADDR = S0.u32;\nDATA = S1.u64;\noffset = { OFFSET1, OFFSET0 };\nADDR0 = ((ADDR + offset.u32) & 0xfff8U);\nADDR1 = ADDR0 + 4U;\nRETURN_DATA[0] = LDS[ADDR0].u32;\nif DATA[31] then\nÊ   LDS[ADDR0] = { 1'0, DATA[30 : 0] }\nendif;\nRETURN_DATA[1] = LDS[ADDR1].u32;\nif DATA[63] then\nÊ   LDS[ADDR1] = { 1'0, DATA[62 : 32] }\nendif",
  DSOp.DS_STORE_B8_D16_HI: 'MEM[ADDR].b8 = DATA[23 : 16]',
  DSOp.DS_STORE_B16_D16_HI: 'MEM[ADDR].b16 = DATA[31 : 16]',
  DSOp.DS_LOAD_U8_D16: "RETURN_DATA[15 : 0].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// RETURN_DATA[31:16] is preserved.",
  DSOp.DS_LOAD_U8_D16_HI: "RETURN_DATA[31 : 16].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// RETURN_DATA[15:0] is preserved.",
  DSOp.DS_LOAD_I8_D16: "RETURN_DATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// RETURN_DATA[31:16] is preserved.",
  DSOp.DS_LOAD_I8_D16_HI: "RETURN_DATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));\n// RETURN_DATA[15:0] is preserved.",
  DSOp.DS_LOAD_U16_D16: 'RETURN_DATA[15 : 0].u16 = MEM[ADDR].u16;\n// RETURN_DATA[31:16] is preserved.',
  DSOp.DS_LOAD_U16_D16_HI: 'RETURN_DATA[31 : 16].u16 = MEM[ADDR].u16;\n// RETURN_DATA[15:0] is preserved.',
  DSOp.DS_BVH_STACK_RTN_B32: 'Ê   (stack_base, stack_index) = DECODE_ADDR(ADDR, OFFSET1);\nÊ   last_node_ptr = DATA0;\nÊ   // First 3 passes: push data onto stack\nÊ   for i = 0..2 do\nÊ       if DATA_VALID(DATA1[i])\nÊ           MEM[stack_base + stack_index] = DATA1[i];\nÊ           Increment stack_index\nÊ       elsif DATA1[i] == last_node_ptr\nÊ           // Treat all further data as invalid as well.\nÊ           break\nÊ       endif\nÊ   endfor\nÊ   // Fourth pass: return data or pop\nÊ   if DATA_VALID(DATA1[3])\nÊ       VGPR_RTN = DATA1[3]\nÊ   else\nÊ       VGPR_RTN = MEM[stack_base + stack_index];\nÊ       MEM[stack_base + stack_index] = INVALID_NODE;\nÊ       Decrement stack_index\nÊ   endif\nÊ   ADDR = ENCODE_ADDR(stack_base, stack_index).\nfunction DATA_VALID(data):\nÊ   if data == INVALID_NODE\nÊ       return false\nÊ   elsif last_node_ptr != INVALID_NODE && data == last_node_ptr\nÊ       // Match last_node_ptr\nÊ       return false\nÊ   else\nÊ       return true\nÊ   endif\nendfunction.',
  DSOp.DS_STORE_ADDTID_B32: "declare OFFSET0 : 8'U;\ndeclare OFFSET1 : 8'U;\nMEM[32'I({ OFFSET1, OFFSET0 } + M0[15 : 0]) + laneID.i32 * 4].u32 = DATA0.u32",
  DSOp.DS_LOAD_ADDTID_B32: "declare OFFSET1 : 8'U;\nRETURN_DATA.u32 = MEM[32'I({ OFFSET1, OFFSET0 } + M0[15 : 0]) + laneID.i32 * 4].u32\ndeclare OFFSET0 : 8'U;",
  DSOp.DS_PERMUTE_B32: "Ê   VGPR[VDST] = { B, D, 0, C }\nÊ   VGPR[SRC0] = { A, B, C, D }\nÊ   VGPR[ADDR] = { 0, 0, 12, 4 }\nÊ   EXEC = 0xA, OFFSET = 0\nÊ   VGPR[VDST] = { -, D, -, 0 }\n// VGPR[laneId][index] is the VGPR RAM\n// VDST, ADDR and DATA0 are from the microcode DS encoding\ndeclare tmp : 32'B[64];\ndeclare OFFSET : 16'U;\ndeclare DATA0 : 32'U;\ndeclare VDST : 32'U;\nfor i in 0 : WAVE64 ? 63 : 31 do\nÊ   tmp[i] = 0x0\nendfor;\nfor i in 0 : WAVE64 ? 63 : 31 do\nÊ   // If a source thread is disabled, it does not propagate data.\nÊ   if EXEC[i].u1 then\nÊ       // ADDR needs to be divided by 4.\nÊ       // High-order bits are ignored.\nÊ       // NOTE: destination lane is MOD 32 regardless of wave size.\nÊ       dst_lane = 32'I(VGPR[i][ADDR] + OFFSET.b32) / 4 % 32;\nÊ       tmp[dst_lane] = VGPR[i][DATA0]\nÊ   endif\nendfor;\n// Copy data into destination VGPRs. If multiple sources\n// select the same destination thread, the highest-numbered\n// source thread wins.\nfor i in 0 : WAVE64 ? 63 : 31 do\nÊ   if EXEC[i].u1 then\nÊ       VGPR[i][VDST] = tmp[i]\nÊ   endif\nendfor\nÊ   VGPR[SRC0] = { A, B, C, D }\nÊ   VGPR[ADDR] = { 0, 0, 12, 4 }\nÊ   EXEC = 0xF, OFFSET = 0",
  DSOp.DS_BPERMUTE_B32: "Ê   VGPR[SRC0] = { A, B, C, D }\nÊ   VGPR[ADDR] = { 0, 0, 12, 4 }\nÊ   EXEC = 0xF, OFFSET = 0\nÊ   VGPR[VDST] = { A, A, D, B }\nÊ   VGPR[SRC0] = { A, B, C, D }\nÊ   VGPR[ADDR] = { 0, 0, 12, 4 }\nÊ   EXEC = 0xA, OFFSET = 0\nÊ   VGPR[VDST] = { -, 0, -, B }\n// VGPR[laneId][index] is the VGPR RAM\n// VDST, ADDR and DATA0 are from the microcode DS encoding\ndeclare tmp : 32'B[64];\ndeclare OFFSET : 16'U;\ndeclare DATA0 : 32'U;\ndeclare VDST : 32'U;\nfor i in 0 : WAVE64 ? 63 : 31 do\nÊ   tmp[i] = 0x0\nendfor;\nfor i in 0 : WAVE64 ? 63 : 31 do\nÊ   // ADDR needs to be divided by 4.\nÊ   // High-order bits are ignored.\nÊ   // NOTE: destination lane is MOD 32 regardless of wave size.\nÊ   src_lane = 32'I(VGPR[i][ADDR] + OFFSET.b32) / 4 % 32;\nÊ   // EXEC is applied to the source VGPR reads.\nÊ   if EXEC[src_lane].u1 then\nÊ       tmp[i] = VGPR[src_lane][DATA0]\nÊ   endif\nendfor;\n// Copy data into destination VGPRs. Some source\n// data may be broadcast to multiple lanes.\nfor i in 0 : WAVE64 ? 63 : 31 do\nÊ   if EXEC[i].u1 then\nÊ       VGPR[i][VDST] = tmp[i]\nÊ   endif\nendfor",
  DSOp.DS_STORE_B96: 'MEM[ADDR + OFFSET.u32].b32 = DATA[31 : 0];\nMEM[ADDR + OFFSET.u32 + 4U].b32 = DATA[63 : 32];\nMEM[ADDR + OFFSET.u32 + 8U].b32 = DATA[95 : 64]',
  DSOp.DS_STORE_B128: 'MEM[ADDR + OFFSET.u32].b32 = DATA[31 : 0];\nMEM[ADDR + OFFSET.u32 + 4U].b32 = DATA[63 : 32];\nMEM[ADDR + OFFSET.u32 + 8U].b32 = DATA[95 : 64];\nMEM[ADDR + OFFSET.u32 + 12U].b32 = DATA[127 : 96]',
  DSOp.DS_LOAD_B96: 'RETURN_DATA[31 : 0] = MEM[ADDR + OFFSET.u32].b32;\nRETURN_DATA[63 : 32] = MEM[ADDR + OFFSET.u32 + 4U].b32;\nRETURN_DATA[95 : 64] = MEM[ADDR + OFFSET.u32 + 8U].b32',
  DSOp.DS_LOAD_B128: 'RETURN_DATA[31 : 0] = MEM[ADDR + OFFSET.u32].b32;\nRETURN_DATA[63 : 32] = MEM[ADDR + OFFSET.u32 + 4U].b32;\nRETURN_DATA[95 : 64] = MEM[ADDR + OFFSET.u32 + 8U].b32;\nRETURN_DATA[127 : 96] = MEM[ADDR + OFFSET.u32 + 12U].b32',
}

FLATOp_PCODE = {
  FLATOp.FLAT_LOAD_U8: "VDATA.u32 = 32'U({ 24'0U, MEM[ADDR].u8 })",
  FLATOp.FLAT_LOAD_I8: "VDATA.i32 = 32'I(signext(MEM[ADDR].i8))",
  FLATOp.FLAT_LOAD_U16: "VDATA.u32 = 32'U({ 16'0U, MEM[ADDR].u16 })",
  FLATOp.FLAT_LOAD_I16: "VDATA.i32 = 32'I(signext(MEM[ADDR].i16))",
  FLATOp.FLAT_LOAD_B32: 'VDATA[31 : 0] = MEM[ADDR].b32',
  FLATOp.FLAT_LOAD_B64: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32',
  FLATOp.FLAT_LOAD_B96: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32;\nVDATA[95 : 64] = MEM[ADDR + 8U].b32',
  FLATOp.FLAT_LOAD_B128: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32;\nVDATA[95 : 64] = MEM[ADDR + 8U].b32;\nVDATA[127 : 96] = MEM[ADDR + 12U].b32',
  FLATOp.FLAT_STORE_B8: 'MEM[ADDR].b8 = VDATA[7 : 0]',
  FLATOp.FLAT_STORE_B16: 'MEM[ADDR].b16 = VDATA[15 : 0]',
  FLATOp.FLAT_STORE_B32: 'MEM[ADDR].b32 = VDATA[31 : 0]',
  FLATOp.FLAT_STORE_B64: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32]',
  FLATOp.FLAT_STORE_B96: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32];\nMEM[ADDR + 8U].b32 = VDATA[95 : 64]',
  FLATOp.FLAT_STORE_B128: 'MEM[ADDR + 8U].b32 = VDATA[95 : 64];\nMEM[ADDR + 12U].b32 = VDATA[127 : 96]\nMEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32];',
  FLATOp.FLAT_LOAD_D16_U8: "VDATA[15 : 0].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// VDATA[31:16] is preserved.",
  FLATOp.FLAT_LOAD_D16_I8: "VDATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[31:16] is preserved.",
  FLATOp.FLAT_LOAD_D16_B16: 'VDATA[15 : 0].b16 = MEM[ADDR].b16;\n// VDATA[31:16] is preserved.',
  FLATOp.FLAT_LOAD_D16_HI_U8: "VDATA[31 : 16].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// VDATA[15:0] is preserved.",
  FLATOp.FLAT_LOAD_D16_HI_I8: "VDATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[15:0] is preserved.",
  FLATOp.FLAT_LOAD_D16_HI_B16: 'VDATA[31 : 16].b16 = MEM[ADDR].b16;\n// VDATA[15:0] is preserved.',
  FLATOp.FLAT_STORE_D16_HI_B8: 'MEM[ADDR].b8 = VDATA[23 : 16]',
  FLATOp.FLAT_STORE_D16_HI_B16: 'MEM[ADDR].b16 = VDATA[31 : 16]',
  FLATOp.FLAT_ATOMIC_SWAP_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  FLATOp.FLAT_ATOMIC_CMPSWAP_B32: 'tmp = MEM[ADDR].u32;\nsrc = DATA[31 : 0].u32;\ncmp = DATA[63 : 32].u32;\nMEM[ADDR].u32 = tmp == cmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  FLATOp.FLAT_ATOMIC_ADD_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  FLATOp.FLAT_ATOMIC_SUB_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  FLATOp.FLAT_ATOMIC_MIN_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  FLATOp.FLAT_ATOMIC_MIN_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  FLATOp.FLAT_ATOMIC_MAX_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  FLATOp.FLAT_ATOMIC_MAX_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  FLATOp.FLAT_ATOMIC_AND_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  FLATOp.FLAT_ATOMIC_OR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  FLATOp.FLAT_ATOMIC_XOR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  FLATOp.FLAT_ATOMIC_INC_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  FLATOp.FLAT_ATOMIC_DEC_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  FLATOp.FLAT_ATOMIC_SWAP_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp',
  FLATOp.FLAT_ATOMIC_CMPSWAP_B64: 'tmp = MEM[ADDR].u64;\nsrc = DATA[63 : 0].u64;\ncmp = DATA[127 : 64].u64;\nMEM[ADDR].u64 = tmp == cmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  FLATOp.FLAT_ATOMIC_ADD_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  FLATOp.FLAT_ATOMIC_SUB_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  FLATOp.FLAT_ATOMIC_MIN_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  FLATOp.FLAT_ATOMIC_MIN_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  FLATOp.FLAT_ATOMIC_MAX_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  FLATOp.FLAT_ATOMIC_MAX_U64: 'RETURN_DATA.u64 = tmp\ntmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src >= tmp ? src : tmp;',
  FLATOp.FLAT_ATOMIC_AND_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  FLATOp.FLAT_ATOMIC_OR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  FLATOp.FLAT_ATOMIC_XOR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  FLATOp.FLAT_ATOMIC_INC_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  FLATOp.FLAT_ATOMIC_DEC_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  FLATOp.FLAT_ATOMIC_CMPSWAP_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA[31 : 0].f32;\ncmp = DATA[63 : 32].f32;\nMEM[ADDR].f32 = tmp == cmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  FLATOp.FLAT_ATOMIC_MIN_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src < tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  FLATOp.FLAT_ATOMIC_MAX_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src > tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  FLATOp.FLAT_ATOMIC_ADD_F32: 'tmp = MEM[ADDR].f32;\nMEM[ADDR].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
}

GLOBALOp_PCODE = {
  GLOBALOp.GLOBAL_LOAD_U8: "VDATA.u32 = 32'U({ 24'0U, MEM[ADDR].u8 })",
  GLOBALOp.GLOBAL_LOAD_I8: "VDATA.i32 = 32'I(signext(MEM[ADDR].i8))",
  GLOBALOp.GLOBAL_LOAD_U16: "VDATA.u32 = 32'U({ 16'0U, MEM[ADDR].u16 })",
  GLOBALOp.GLOBAL_LOAD_I16: "VDATA.i32 = 32'I(signext(MEM[ADDR].i16))",
  GLOBALOp.GLOBAL_LOAD_B32: 'VDATA[31 : 0] = MEM[ADDR].b32',
  GLOBALOp.GLOBAL_LOAD_B64: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32',
  GLOBALOp.GLOBAL_LOAD_B96: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32;\nVDATA[95 : 64] = MEM[ADDR + 8U].b32',
  GLOBALOp.GLOBAL_LOAD_B128: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32;\nVDATA[95 : 64] = MEM[ADDR + 8U].b32;\nVDATA[127 : 96] = MEM[ADDR + 12U].b32',
  GLOBALOp.GLOBAL_STORE_B8: 'MEM[ADDR].b8 = VDATA[7 : 0]',
  GLOBALOp.GLOBAL_STORE_B16: 'MEM[ADDR].b16 = VDATA[15 : 0]',
  GLOBALOp.GLOBAL_STORE_B32: 'MEM[ADDR].b32 = VDATA[31 : 0]',
  GLOBALOp.GLOBAL_STORE_B64: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32]',
  GLOBALOp.GLOBAL_STORE_B96: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32];\nMEM[ADDR + 8U].b32 = VDATA[95 : 64]',
  GLOBALOp.GLOBAL_STORE_B128: 'MEM[ADDR + 8U].b32 = VDATA[95 : 64];\nMEM[ADDR + 12U].b32 = VDATA[127 : 96]\nMEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32];',
  GLOBALOp.GLOBAL_LOAD_D16_U8: "VDATA[15 : 0].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// VDATA[31:16] is preserved.",
  GLOBALOp.GLOBAL_LOAD_D16_I8: "VDATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[31:16] is preserved.",
  GLOBALOp.GLOBAL_LOAD_D16_B16: 'VDATA[15 : 0].b16 = MEM[ADDR].b16;\n// VDATA[31:16] is preserved.',
  GLOBALOp.GLOBAL_LOAD_D16_HI_U8: "VDATA[31 : 16].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// VDATA[15:0] is preserved.",
  GLOBALOp.GLOBAL_LOAD_D16_HI_I8: "VDATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[15:0] is preserved.",
  GLOBALOp.GLOBAL_LOAD_D16_HI_B16: 'VDATA[31 : 16].b16 = MEM[ADDR].b16;\n// VDATA[15:0] is preserved.',
  GLOBALOp.GLOBAL_STORE_D16_HI_B8: 'MEM[ADDR].b8 = VDATA[23 : 16]',
  GLOBALOp.GLOBAL_STORE_D16_HI_B16: 'MEM[ADDR].b16 = VDATA[31 : 16]',
  GLOBALOp.GLOBAL_LOAD_ADDTID_B32: "RETURN_DATA.u32 = MEM[SGPR_ADDR[63 : 0] + INST_OFFSET[11 : 0].b64 + 64'B(laneID.i32 * 4)].u32",
  GLOBALOp.GLOBAL_STORE_ADDTID_B32: "MEM[SGPR_ADDR[63 : 0] + INST_OFFSET[11 : 0].b64 + 64'B(laneID.i32 * 4)].u32 = DATA.u32",
  GLOBALOp.GLOBAL_ATOMIC_SWAP_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_CMPSWAP_B32: 'tmp = MEM[ADDR].u32;\nsrc = DATA[31 : 0].u32;\ncmp = DATA[63 : 32].u32;\nMEM[ADDR].u32 = tmp == cmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_ADD_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_SUB_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_CSUB_U32: "declare new_value : 32'U;\nold_value = MEM[ADDR].u32;\nif old_value < DATA.u32 then\nÊ   new_value = 0U\nelse\nÊ   new_value = old_value - DATA.u32\nendif;\nMEM[ADDR].u32 = new_value;\nRETURN_DATA.u32 = old_value",
  GLOBALOp.GLOBAL_ATOMIC_MIN_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MIN_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MAX_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MAX_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_AND_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_OR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_XOR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_INC_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_DEC_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_SWAP_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_CMPSWAP_B64: 'tmp = MEM[ADDR].u64;\nsrc = DATA[63 : 0].u64;\ncmp = DATA[127 : 64].u64;\nMEM[ADDR].u64 = tmp == cmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_ADD_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_SUB_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MIN_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MIN_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MAX_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MAX_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src >= tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_AND_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_OR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_XOR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_INC_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_DEC_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_CMPSWAP_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA[31 : 0].f32;\ncmp = DATA[63 : 32].f32;\nMEM[ADDR].f32 = tmp == cmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MIN_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src < tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_MAX_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src > tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  GLOBALOp.GLOBAL_ATOMIC_ADD_F32: 'tmp = MEM[ADDR].f32;\nMEM[ADDR].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
}

MIMGOp_PCODE = {
  MIMGOp.IMAGE_ATOMIC_SWAP: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  MIMGOp.IMAGE_ATOMIC_CMPSWAP: 'cmp = DATA[63 : 32].u32;\nMEM[ADDR].u32 = tmp == cmp ? src : tmp;\nRETURN_DATA.u32 = tmp\ntmp = MEM[ADDR].u32;\nsrc = DATA[31 : 0].u32;',
  MIMGOp.IMAGE_ATOMIC_ADD: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  MIMGOp.IMAGE_ATOMIC_SUB: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  MIMGOp.IMAGE_ATOMIC_SMIN: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  MIMGOp.IMAGE_ATOMIC_UMIN: 'src = DATA.u32;\nMEM[ADDR].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp\ntmp = MEM[ADDR].u32;',
  MIMGOp.IMAGE_ATOMIC_SMAX: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  MIMGOp.IMAGE_ATOMIC_UMAX: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  MIMGOp.IMAGE_ATOMIC_AND: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  MIMGOp.IMAGE_ATOMIC_OR: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  MIMGOp.IMAGE_ATOMIC_XOR: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  MIMGOp.IMAGE_ATOMIC_INC: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  MIMGOp.IMAGE_ATOMIC_DEC: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  MIMGOp.IMAGE_GET_LOD: 'VDATA[1] = rawLOD.\nVDATA[0] = clampedLOD;',
}

MTBUFOp_PCODE = {
  MTBUFOp.TBUFFER_LOAD_FORMAT_X: 'VDATA[31 : 0].b32 = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format',
  MTBUFOp.TBUFFER_LOAD_FORMAT_XY: 'VDATA[31 : 0].b32 = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[TADDR.Y])',
  MTBUFOp.TBUFFER_LOAD_FORMAT_XYZ: 'VDATA[31 : 0].b32 = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[TADDR.Y]);\nVDATA[95 : 64].b32 = ConvertFromFormat(MEM[TADDR.Z])',
  MTBUFOp.TBUFFER_LOAD_FORMAT_XYZW: 'VDATA[31 : 0].b32 = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[TADDR.Y]);\nVDATA[95 : 64].b32 = ConvertFromFormat(MEM[TADDR.Z]);\nVDATA[127 : 96].b32 = ConvertFromFormat(MEM[TADDR.W])',
  MTBUFOp.TBUFFER_STORE_FORMAT_X: 'MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format',
  MTBUFOp.TBUFFER_STORE_FORMAT_XY: 'MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b32)',
  MTBUFOp.TBUFFER_STORE_FORMAT_XYZ: 'MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b32);\nMEM[TADDR.Z] = ConvertToFormat(VDATA[95 : 64].b32)',
  MTBUFOp.TBUFFER_STORE_FORMAT_XYZW: 'MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b32);\nMEM[TADDR.Z] = ConvertToFormat(VDATA[95 : 64].b32);\nMEM[TADDR.W] = ConvertToFormat(VDATA[127 : 96].b32)',
  MTBUFOp.TBUFFER_LOAD_D16_FORMAT_X: "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\n// VDATA[31:16].b16 is preserved.",
  MTBUFOp.TBUFFER_LOAD_D16_FORMAT_XY: "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]))",
  MTBUFOp.TBUFFER_LOAD_D16_FORMAT_XYZ: "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Z]));\n// VDATA[63:48].b16 is preserved.",
  MTBUFOp.TBUFFER_LOAD_D16_FORMAT_XYZW: "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Z]));\nVDATA[63 : 48].b16 = 16'B(ConvertFromFormat(MEM[TADDR.W]))",
  MTBUFOp.TBUFFER_STORE_D16_FORMAT_X: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format",
  MTBUFOp.TBUFFER_STORE_D16_FORMAT_XY: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16))",
  MTBUFOp.TBUFFER_STORE_D16_FORMAT_XYZ: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[TADDR.Z] = ConvertToFormat(32'B(VDATA[47 : 32].b16))",
  MTBUFOp.TBUFFER_STORE_D16_FORMAT_XYZW: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[TADDR.Z] = ConvertToFormat(32'B(VDATA[47 : 32].b16));\nMEM[TADDR.W] = ConvertToFormat(32'B(VDATA[63 : 48].b16))",
}

MUBUFOp_PCODE = {
  MUBUFOp.BUFFER_LOAD_FORMAT_X: 'VDATA[31 : 0].b32 = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format',
  MUBUFOp.BUFFER_LOAD_FORMAT_XY: 'VDATA[31 : 0].b32 = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[TADDR.Y])',
  MUBUFOp.BUFFER_LOAD_FORMAT_XYZ: 'VDATA[31 : 0].b32 = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[TADDR.Y]);\nVDATA[95 : 64].b32 = ConvertFromFormat(MEM[TADDR.Z])',
  MUBUFOp.BUFFER_LOAD_FORMAT_XYZW: 'VDATA[31 : 0].b32 = ConvertFromFormat(MEM[TADDR.X]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[TADDR.Y]);\nVDATA[95 : 64].b32 = ConvertFromFormat(MEM[TADDR.Z]);\nVDATA[127 : 96].b32 = ConvertFromFormat(MEM[TADDR.W])',
  MUBUFOp.BUFFER_STORE_FORMAT_X: 'MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format',
  MUBUFOp.BUFFER_STORE_FORMAT_XY: 'MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b32)',
  MUBUFOp.BUFFER_STORE_FORMAT_XYZ: 'MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b32);\nMEM[TADDR.Z] = ConvertToFormat(VDATA[95 : 64].b32)',
  MUBUFOp.BUFFER_STORE_FORMAT_XYZW: 'MEM[TADDR.X] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(VDATA[63 : 32].b32);\nMEM[TADDR.Z] = ConvertToFormat(VDATA[95 : 64].b32);\nMEM[TADDR.W] = ConvertToFormat(VDATA[127 : 96].b32)',
  MUBUFOp.BUFFER_LOAD_D16_FORMAT_X: "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\n// VDATA[31:16].b16 is preserved.",
  MUBUFOp.BUFFER_LOAD_D16_FORMAT_XY: "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]))",
  MUBUFOp.BUFFER_LOAD_D16_FORMAT_XYZ: "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Z]));\n// VDATA[63:48].b16 is preserved.",
  MUBUFOp.BUFFER_LOAD_D16_FORMAT_XYZW: "VDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Y]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[TADDR.Z]));\nVDATA[63 : 48].b16 = 16'B(ConvertFromFormat(MEM[TADDR.W]))",
  MUBUFOp.BUFFER_STORE_D16_FORMAT_X: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format",
  MUBUFOp.BUFFER_STORE_D16_FORMAT_XY: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16))",
  MUBUFOp.BUFFER_STORE_D16_FORMAT_XYZ: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[TADDR.Z] = ConvertToFormat(32'B(VDATA[47 : 32].b16))",
  MUBUFOp.BUFFER_STORE_D16_FORMAT_XYZW: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[TADDR.Y] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[TADDR.Z] = ConvertToFormat(32'B(VDATA[47 : 32].b16));\nMEM[TADDR.W] = ConvertToFormat(32'B(VDATA[63 : 48].b16))",
  MUBUFOp.BUFFER_LOAD_U8: "VDATA.u32 = 32'U({ 24'0U, MEM[ADDR].u8 })",
  MUBUFOp.BUFFER_LOAD_I8: "VDATA.i32 = 32'I(signext(MEM[ADDR].i8))",
  MUBUFOp.BUFFER_LOAD_U16: "VDATA.u32 = 32'U({ 16'0U, MEM[ADDR].u16 })",
  MUBUFOp.BUFFER_LOAD_I16: "VDATA.i32 = 32'I(signext(MEM[ADDR].i16))",
  MUBUFOp.BUFFER_LOAD_B32: 'VDATA[31 : 0] = MEM[ADDR].b32',
  MUBUFOp.BUFFER_LOAD_B64: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32',
  MUBUFOp.BUFFER_LOAD_B96: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32;\nVDATA[95 : 64] = MEM[ADDR + 8U].b32',
  MUBUFOp.BUFFER_LOAD_B128: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32;\nVDATA[95 : 64] = MEM[ADDR + 8U].b32;\nVDATA[127 : 96] = MEM[ADDR + 12U].b32',
  MUBUFOp.BUFFER_STORE_B8: 'MEM[ADDR].b8 = VDATA[7 : 0]',
  MUBUFOp.BUFFER_STORE_B16: 'MEM[ADDR].b16 = VDATA[15 : 0]',
  MUBUFOp.BUFFER_STORE_B32: 'MEM[ADDR].b32 = VDATA[31 : 0]',
  MUBUFOp.BUFFER_STORE_B64: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32]',
  MUBUFOp.BUFFER_STORE_B96: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32];\nMEM[ADDR + 8U].b32 = VDATA[95 : 64]',
  MUBUFOp.BUFFER_STORE_B128: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32];\nMEM[ADDR + 8U].b32 = VDATA[95 : 64];\nMEM[ADDR + 12U].b32 = VDATA[127 : 96]',
  MUBUFOp.BUFFER_LOAD_D16_U8: "VDATA[15 : 0].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// VDATA[31:16] is preserved.",
  MUBUFOp.BUFFER_LOAD_D16_I8: "VDATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[31:16] is preserved.",
  MUBUFOp.BUFFER_LOAD_D16_B16: 'VDATA[15 : 0].b16 = MEM[ADDR].b16;\n// VDATA[31:16] is preserved.',
  MUBUFOp.BUFFER_LOAD_D16_HI_U8: "VDATA[31 : 16].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// VDATA[15:0] is preserved.",
  MUBUFOp.BUFFER_LOAD_D16_HI_I8: "// VDATA[15:0] is preserved.\nVDATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));",
  MUBUFOp.BUFFER_LOAD_D16_HI_B16: 'VDATA[31 : 16].b16 = MEM[ADDR].b16;\n// VDATA[15:0] is preserved.',
  MUBUFOp.BUFFER_STORE_D16_HI_B8: 'MEM[ADDR].b8 = VDATA[23 : 16]',
  MUBUFOp.BUFFER_STORE_D16_HI_B16: 'MEM[ADDR].b16 = VDATA[31 : 16]',
  MUBUFOp.BUFFER_LOAD_D16_HI_FORMAT_X: "VDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[TADDR.X]));\n// Mem access size depends on format\n// VDATA[15:0].b16 is preserved.",
  MUBUFOp.BUFFER_STORE_D16_HI_FORMAT_X: "MEM[TADDR.X] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\n// Mem access size depends on format",
  MUBUFOp.BUFFER_ATOMIC_SWAP_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_CMPSWAP_B32: 'tmp = MEM[ADDR].u32;\nsrc = DATA[31 : 0].u32;\ncmp = DATA[63 : 32].u32;\nMEM[ADDR].u32 = tmp == cmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_ADD_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_SUB_U32: 'tmp = MEM[ADDR].u32;\nMEM[ADDR].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_CSUB_U32: "declare new_value : 32'U;\nold_value = MEM[ADDR].u32;\nif old_value < DATA.u32 then\nÊ   new_value = 0U\nelse\nÊ   new_value = old_value - DATA.u32\nendif;\nMEM[ADDR].u32 = new_value;\nRETURN_DATA.u32 = old_value",
  MUBUFOp.BUFFER_ATOMIC_MIN_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MIN_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MAX_I32: 'tmp = MEM[ADDR].i32;\nsrc = DATA.i32;\nMEM[ADDR].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MAX_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_AND_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_OR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_XOR_B32: 'tmp = MEM[ADDR].b32;\nMEM[ADDR].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_INC_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_DEC_U32: 'tmp = MEM[ADDR].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_SWAP_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_CMPSWAP_B64: 'tmp = MEM[ADDR].u64;\nsrc = DATA[63 : 0].u64;\ncmp = DATA[127 : 64].u64;\nMEM[ADDR].u64 = tmp == cmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_ADD_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_SUB_U64: 'tmp = MEM[ADDR].u64;\nMEM[ADDR].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MIN_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MIN_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MAX_I64: 'tmp = MEM[ADDR].i64;\nsrc = DATA.i64;\nMEM[ADDR].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MAX_U64: 'RETURN_DATA.u64 = tmp\ntmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = src >= tmp ? src : tmp;',
  MUBUFOp.BUFFER_ATOMIC_AND_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_OR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_XOR_B64: 'tmp = MEM[ADDR].b64;\nMEM[ADDR].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_INC_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_DEC_U64: 'tmp = MEM[ADDR].u64;\nsrc = DATA.u64;\nMEM[ADDR].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  MUBUFOp.BUFFER_ATOMIC_CMPSWAP_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA[31 : 0].f32;\ncmp = DATA[63 : 32].f32;\nMEM[ADDR].f32 = tmp == cmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MIN_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src < tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_MAX_F32: 'tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nMEM[ADDR].f32 = src > tmp ? src : tmp;\nRETURN_DATA.f32 = tmp',
  MUBUFOp.BUFFER_ATOMIC_ADD_F32: 'tmp = MEM[ADDR].f32;\nMEM[ADDR].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
}

SCRATCHOp_PCODE = {
  SCRATCHOp.SCRATCH_LOAD_U8: "VDATA.u32 = 32'U({ 24'0U, MEM[ADDR].u8 })",
  SCRATCHOp.SCRATCH_LOAD_I8: "VDATA.i32 = 32'I(signext(MEM[ADDR].i8))",
  SCRATCHOp.SCRATCH_LOAD_U16: "VDATA.u32 = 32'U({ 16'0U, MEM[ADDR].u16 })",
  SCRATCHOp.SCRATCH_LOAD_I16: "VDATA.i32 = 32'I(signext(MEM[ADDR].i16))",
  SCRATCHOp.SCRATCH_LOAD_B32: 'VDATA[31 : 0] = MEM[ADDR].b32',
  SCRATCHOp.SCRATCH_LOAD_B64: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32',
  SCRATCHOp.SCRATCH_LOAD_B96: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32;\nVDATA[95 : 64] = MEM[ADDR + 8U].b32',
  SCRATCHOp.SCRATCH_LOAD_B128: 'VDATA[31 : 0] = MEM[ADDR].b32;\nVDATA[63 : 32] = MEM[ADDR + 4U].b32;\nVDATA[95 : 64] = MEM[ADDR + 8U].b32;\nVDATA[127 : 96] = MEM[ADDR + 12U].b32',
  SCRATCHOp.SCRATCH_STORE_B8: 'MEM[ADDR].b8 = VDATA[7 : 0]',
  SCRATCHOp.SCRATCH_STORE_B16: 'MEM[ADDR].b16 = VDATA[15 : 0]',
  SCRATCHOp.SCRATCH_STORE_B32: 'MEM[ADDR].b32 = VDATA[31 : 0]',
  SCRATCHOp.SCRATCH_STORE_B64: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32]',
  SCRATCHOp.SCRATCH_STORE_B96: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32];\nMEM[ADDR + 8U].b32 = VDATA[95 : 64]',
  SCRATCHOp.SCRATCH_STORE_B128: 'MEM[ADDR].b32 = VDATA[31 : 0];\nMEM[ADDR + 4U].b32 = VDATA[63 : 32];\nMEM[ADDR + 8U].b32 = VDATA[95 : 64];\nMEM[ADDR + 12U].b32 = VDATA[127 : 96]',
  SCRATCHOp.SCRATCH_LOAD_D16_U8: "VDATA[15 : 0].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// VDATA[31:16] is preserved.",
  SCRATCHOp.SCRATCH_LOAD_D16_I8: "VDATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[31:16] is preserved.",
  SCRATCHOp.SCRATCH_LOAD_D16_B16: 'VDATA[15 : 0].b16 = MEM[ADDR].b16;\n// VDATA[31:16] is preserved.',
  SCRATCHOp.SCRATCH_LOAD_D16_HI_U8: "VDATA[31 : 16].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// VDATA[15:0] is preserved.",
  SCRATCHOp.SCRATCH_LOAD_D16_HI_I8: "VDATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));\n// VDATA[15:0] is preserved.",
  SCRATCHOp.SCRATCH_LOAD_D16_HI_B16: 'VDATA[31 : 16].b16 = MEM[ADDR].b16;\n// VDATA[15:0] is preserved.',
  SCRATCHOp.SCRATCH_STORE_D16_HI_B8: 'MEM[ADDR].b8 = VDATA[23 : 16]',
  SCRATCHOp.SCRATCH_STORE_D16_HI_B16: 'MEM[ADDR].b16 = VDATA[31 : 16]',
}

SMEMOp_PCODE = {
  SMEMOp.S_LOAD_B32: 'SDATA[31 : 0] = MEM[ADDR].b32',
  SMEMOp.S_LOAD_B64: 'SDATA[31 : 0] = MEM[ADDR].b32;\nSDATA[63 : 32] = MEM[ADDR + 4U].b32',
  SMEMOp.S_LOAD_B128: 'SDATA[31 : 0] = MEM[ADDR].b32;\nSDATA[63 : 32] = MEM[ADDR + 4U].b32;\nSDATA[95 : 64] = MEM[ADDR + 8U].b32;\nSDATA[127 : 96] = MEM[ADDR + 12U].b32',
  SMEMOp.S_LOAD_B256: 'SDATA[31 : 0] = MEM[ADDR].b32;\nSDATA[63 : 32] = MEM[ADDR + 4U].b32;\nSDATA[95 : 64] = MEM[ADDR + 8U].b32;\nSDATA[127 : 96] = MEM[ADDR + 12U].b32;\nSDATA[159 : 128] = MEM[ADDR + 16U].b32;\nSDATA[191 : 160] = MEM[ADDR + 20U].b32;\nSDATA[223 : 192] = MEM[ADDR + 24U].b32;\nSDATA[255 : 224] = MEM[ADDR + 28U].b32',
  SMEMOp.S_LOAD_B512: 'SDATA[31 : 0] = MEM[ADDR].b32;\nSDATA[63 : 32] = MEM[ADDR + 4U].b32;\nSDATA[95 : 64] = MEM[ADDR + 8U].b32;\nSDATA[127 : 96] = MEM[ADDR + 12U].b32;\nSDATA[159 : 128] = MEM[ADDR + 16U].b32;\nSDATA[191 : 160] = MEM[ADDR + 20U].b32;\nSDATA[223 : 192] = MEM[ADDR + 24U].b32;\nSDATA[255 : 224] = MEM[ADDR + 28U].b32;\nSDATA[287 : 256] = MEM[ADDR + 32U].b32;\nSDATA[319 : 288] = MEM[ADDR + 36U].b32;\nSDATA[351 : 320] = MEM[ADDR + 40U].b32;\nSDATA[383 : 352] = MEM[ADDR + 44U].b32;\nSDATA[415 : 384] = MEM[ADDR + 48U].b32;\nSDATA[447 : 416] = MEM[ADDR + 52U].b32;\nSDATA[479 : 448] = MEM[ADDR + 56U].b32;\nSDATA[511 : 480] = MEM[ADDR + 60U].b32',
  SMEMOp.S_BUFFER_LOAD_B32: 'SDATA[31 : 0] = MEM[ADDR].b32',
  SMEMOp.S_BUFFER_LOAD_B64: 'SDATA[31 : 0] = MEM[ADDR].b32;\nSDATA[63 : 32] = MEM[ADDR + 4U].b32',
  SMEMOp.S_BUFFER_LOAD_B128: 'SDATA[31 : 0] = MEM[ADDR].b32;\nSDATA[63 : 32] = MEM[ADDR + 4U].b32;\nSDATA[95 : 64] = MEM[ADDR + 8U].b32;\nSDATA[127 : 96] = MEM[ADDR + 12U].b32',
  SMEMOp.S_BUFFER_LOAD_B256: 'SDATA[31 : 0] = MEM[ADDR].b32;\nSDATA[63 : 32] = MEM[ADDR + 4U].b32;\nSDATA[95 : 64] = MEM[ADDR + 8U].b32;\nSDATA[127 : 96] = MEM[ADDR + 12U].b32;\nSDATA[159 : 128] = MEM[ADDR + 16U].b32;\nSDATA[191 : 160] = MEM[ADDR + 20U].b32;\nSDATA[223 : 192] = MEM[ADDR + 24U].b32;\nSDATA[255 : 224] = MEM[ADDR + 28U].b32',
  SMEMOp.S_BUFFER_LOAD_B512: 'SDATA[31 : 0] = MEM[ADDR].b32;\nSDATA[63 : 32] = MEM[ADDR + 4U].b32;\nSDATA[95 : 64] = MEM[ADDR + 8U].b32;\nSDATA[127 : 96] = MEM[ADDR + 12U].b32;\nSDATA[159 : 128] = MEM[ADDR + 16U].b32;\nSDATA[191 : 160] = MEM[ADDR + 20U].b32;\nSDATA[223 : 192] = MEM[ADDR + 24U].b32;\nSDATA[255 : 224] = MEM[ADDR + 28U].b32;\nSDATA[287 : 256] = MEM[ADDR + 32U].b32;\nSDATA[319 : 288] = MEM[ADDR + 36U].b32;\nSDATA[351 : 320] = MEM[ADDR + 40U].b32;\nSDATA[383 : 352] = MEM[ADDR + 44U].b32;\nSDATA[415 : 384] = MEM[ADDR + 48U].b32;\nSDATA[447 : 416] = MEM[ADDR + 52U].b32;\nSDATA[479 : 448] = MEM[ADDR + 56U].b32;\nSDATA[511 : 480] = MEM[ADDR + 60U].b32',
}

SOP1Op_PCODE = {
  SOP1Op.S_MOV_B32: 'D0.b32 = S0.b32',
  SOP1Op.S_MOV_B64: 'D0.b64 = S0.b64',
  SOP1Op.S_CMOV_B32: 'if SCC then\nÊ   D0.b32 = S0.b32\nendif',
  SOP1Op.S_CMOV_B64: 'if SCC then\nÊ   D0.b64 = S0.b64\nendif',
  SOP1Op.S_BREV_B32: 'D0.u32[31 : 0] = S0.u32[0 : 31]',
  SOP1Op.S_BREV_B64: 'D0.u64[63 : 0] = S0.u64[0 : 63]',
  SOP1Op.S_CTZ_I32_B32: "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\nÊ   // Search from LSB\nÊ   if S0.u32[i] == 1'1U then\nÊ       tmp = i;\nÊ       break\nÊ   endif\nendfor;\nD0.i32 = tmp\nS_CTZ_I32_B32(0xaaaaaaaa) => 1\nS_CTZ_I32_B32(0x55555555) => 0\nS_CTZ_I32_B32(0x00000000) => 0xffffffff\nS_CTZ_I32_B32(0xffffffff) => 0\nS_CTZ_I32_B32(0x00010000) => 16",
  SOP1Op.S_CTZ_I32_B64: "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 63 do\nÊ   // Search from LSB\nÊ   if S0.u64[i] == 1'1U then\nÊ       tmp = i;\nÊ       break\nÊ   endif\nendfor;\nD0.i32 = tmp",
  SOP1Op.S_CLZ_I32_U32: "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\nÊ   // Search from MSB\nÊ   if S0.u32[31 - i] == 1'1U then\nÊ       tmp = i;\nÊ       break\nÊ   endif\nendfor;\nD0.i32 = tmp\nS_CLZ_I32_U32(0x00000000) => 0xffffffff\nS_CLZ_I32_U32(0x0000cccc) => 16\nS_CLZ_I32_U32(0xffff3333) => 0\nS_CLZ_I32_U32(0x7fffffff) => 1\nS_CLZ_I32_U32(0x80000000) => 0\nS_CLZ_I32_U32(0xffffffff) => 0",
  SOP1Op.S_CLZ_I32_U64: "// Set if no ones are found\nfor i in 0 : 63 do\nÊ   // Search from MSB\nÊ   if S0.u64[63 - i] == 1'1U then\nÊ       tmp = i;\nÊ       break\nÊ   endif\nendfor;\nD0.i32 = tmp\ntmp = -1;",
  SOP1Op.S_CLS_I32: 'tmp = -1;\n// Set if all bits are the same\nfor i in 1 : 31 do\nÊ   // Search from MSB\nÊ   if S0.u32[31 - i] != S0.u32[31] then\nÊ       tmp = i;\nÊ       break\nÊ   endif\nendfor;\nD0.i32 = tmp\nS_CLS_I32(0x00000000) => 0xffffffff\nS_CLS_I32(0x0000cccc) => 16\nS_CLS_I32(0xffff3333) => 16\nS_CLS_I32(0x7fffffff) => 1\nS_CLS_I32(0x80000000) => 1\nS_CLS_I32(0xffffffff) => 0xffffffff',
  SOP1Op.S_CLS_I32_I64: 'Ê   // Search from MSB\nÊ   if S0.u64[63 - i] != S0.u64[63] then\nÊ       tmp = i;\nÊ       break\nÊ   endif\nendfor;\nD0.i32 = tmp\ntmp = -1;\n// Set if all bits are the same\nfor i in 1 : 63 do',
  SOP1Op.S_SEXT_I32_I8: "D0.i32 = 32'I(signext(S0.i8))",
  SOP1Op.S_SEXT_I32_I16: "D0.i32 = 32'I(signext(S0.i16))",
  SOP1Op.S_BITSET0_B32: "D0.u32[S0.u32[4 : 0]] = 1'0U",
  SOP1Op.S_BITSET0_B64: "D0.u64[S0.u32[5 : 0]] = 1'0U",
  SOP1Op.S_BITSET1_B32: "D0.u32[S0.u32[4 : 0]] = 1'1U",
  SOP1Op.S_BITSET1_B64: "D0.u64[S0.u32[5 : 0]] = 1'1U",
  SOP1Op.S_BITREPLICATE_B64_B32: 'tmp = S0.u32;\nfor i in 0 : 31 do\nÊ   D0.u64[i * 2] = tmp[i];\nÊ   D0.u64[i * 2 + 1] = tmp[i]\nendfor\nÊ   s_bitreplicate_b64 s2, s0\nÊ   s_bitreplicate_b64 s2, s2',
  SOP1Op.S_ABS_I32: 'S_ABS_I32(0x00000001) => 0x00000001\nS_ABS_I32(0x7fffffff) => 0x7fffffff\nS_ABS_I32(0x80000000) => 0x80000000     // Note this is negative!\nS_ABS_I32(0x80000001) => 0x7fffffff\nS_ABS_I32(0x80000002) => 0x7ffffffe\nS_ABS_I32(0xffffffff) => 0x00000001\nD0.i32 = S0.i32 < 0 ? -S0.i32 : S0.i32;\nSCC = D0.i32 != 0',
  SOP1Op.S_BCNT0_I32_B32: "tmp = 0;\nfor i in 0 : 31 do\nÊ   tmp += S0.u32[i] == 1'0U ? 1 : 0\nendfor;\nD0.i32 = tmp;\nSCC = D0.u32 != 0U\nS_BCNT0_I32_B32(0x00000000) => 32\nS_BCNT0_I32_B32(0xcccccccc) => 16\nS_BCNT0_I32_B32(0xffffffff) => 0",
  SOP1Op.S_BCNT0_I32_B64: "tmp = 0;\nfor i in 0 : 63 do\nÊ   tmp += S0.u64[i] == 1'0U ? 1 : 0\nendfor;\nD0.i32 = tmp;\nSCC = D0.u64 != 0ULL",
  SOP1Op.S_BCNT1_I32_B32: "tmp = 0;\nfor i in 0 : 31 do\nÊ   tmp += S0.u32[i] == 1'1U ? 1 : 0\nendfor;\nD0.i32 = tmp;\nSCC = D0.u32 != 0U\nS_BCNT1_I32_B32(0x00000000) => 0\nS_BCNT1_I32_B32(0xcccccccc) => 16\nS_BCNT1_I32_B32(0xffffffff) => 32",
  SOP1Op.S_BCNT1_I32_B64: "tmp = 0;\nfor i in 0 : 63 do\nÊ   tmp += S0.u64[i] == 1'1U ? 1 : 0\nendfor;\nD0.i32 = tmp;\nSCC = D0.u64 != 0ULL",
  SOP1Op.S_QUADMASK_B32: 'tmp = 0U;\nfor i in 0 : 7 do\nÊ   tmp[i] = S0.u32[i * 4 +: 4] != 0U\nendfor;\nD0.u32 = tmp;\nSCC = D0.u32 != 0U',
  SOP1Op.S_QUADMASK_B64: 'tmp = 0ULL;\nfor i in 0 : 15 do\nÊ   tmp[i] = S0.u64[i * 4 +: 4] != 0ULL\nendfor;\nD0.u64 = tmp;\nSCC = D0.u64 != 0ULL',
  SOP1Op.S_WQM_B32: "tmp = 0U;\ndeclare i : 6'U;\nfor i in 6'0U : 6'31U do\nÊ   tmp[i] = S0.u32[i & 6'60U +: 6'4U] != 0U\nendfor;\nD0.u32 = tmp;\nSCC = D0.u32 != 0U",
  SOP1Op.S_WQM_B64: "SCC = D0.u64 != 0ULL\ntmp = 0ULL;\ndeclare i : 6'U;\nfor i in 6'0U : 6'63U do\nÊ   tmp[i] = S0.u64[i & 6'60U +: 6'4U] != 0ULL\nendfor;\nD0.u64 = tmp;",
  SOP1Op.S_NOT_B32: 'D0.u32 = ~S0.u32;\nSCC = D0.u32 != 0U',
  SOP1Op.S_NOT_B64: 'D0.u64 = ~S0.u64;\nSCC = D0.u64 != 0ULL',
  SOP1Op.S_AND_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 & EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_OR_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 | EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_OR_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_XOR_SAVEEXEC_B32: 'SCC = EXEC.u32 != 0U\nsaveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 ^ EXEC.u32);\nD0.u32 = saveexec.u32;',
  SOP1Op.S_XOR_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 ^ EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_NAND_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = ~(S0.u32 & EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_NAND_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_NOR_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = ~(S0.u32 | EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_NOR_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_XNOR_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = ~(S0.u32 ^ EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_XNOR_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 ^ EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_AND_NOT0_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (~S0.u32 & EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_NOT0_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (~S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_OR_NOT0_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (~S0.u32 | EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_OR_NOT0_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (~S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_AND_NOT1_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 & ~EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_NOT1_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 & ~EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_OR_NOT1_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 | ~EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_OR_NOT1_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 | ~EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_AND_NOT0_WREXEC_B32: 'EXEC.u32 = (~S0.u32 & EXEC.u32);\nD0.u32 = EXEC.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_NOT0_WREXEC_B64: 'SCC = EXEC.u64 != 0ULL\nEXEC.u64 = (~S0.u64 & EXEC.u64);\nD0.u64 = EXEC.u64;',
  SOP1Op.S_AND_NOT1_WREXEC_B32: 'EXEC.u32 = (S0.u32 & ~EXEC.u32);\nD0.u32 = EXEC.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_NOT1_WREXEC_B64: 'v_cmpx_eq s0, v0\n<OP>        // do the operation using the current EXEC mask. S0 holds the index.\n// mask out thread that was just executed\n// s_andn2_b64  s4, s4, exec\n// s_mov_b64    exec, s4\ns_andn2_wrexec_b64 s4, s4     // replaces above 2 ops\n// repeat until EXEC==0\ns_cbranch_scc1  loop\ns_mov_b64    exec, s2\nEXEC.u64 = (S0.u64 & ~EXEC.u64);\nD0.u64 = EXEC.u64;\nSCC = EXEC.u64 != 0ULL\n// V0 holds the index value per lane\n// save exec mask for restore at the end\ns_mov_b64 s2, exec\n// exec mask of remaining (unprocessed) threads\ns_mov_b64 s4, exec\nloop:\n// get the index value for the first active lane\nv_readfirstlane_b32  s0, v0\n// find all other lanes with same index value',
  SOP1Op.S_MOVRELS_B32: 'addr = SRC0.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nD0.b32 = SGPR[addr].b32\nÊ   s_mov_b32 m0, 10\nÊ   s_movrels_b32 s5, s7',
  SOP1Op.S_MOVRELS_B64: 'addr = SRC0.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nD0.b64 = SGPR[addr].b64',
  SOP1Op.S_MOVRELD_B32: 'addr += M0.u32[31 : 0];\nSGPR[addr].b32 = S0.b32\nÊ   s_mov_b32 m0, 10\nÊ   s_movreld_b32 s5, s7\naddr = DST.u32;\n// Raw value from instruction',
  SOP1Op.S_MOVRELD_B64: 'addr = DST.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nSGPR[addr].b64 = S0.b64',
  SOP1Op.S_MOVRELSD_2_B32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[9 : 0].u32;\naddrd += M0.u32[25 : 16].u32;\nSGPR[addrd].b32 = SGPR[addrs].b32\nÊ   s_mov_b32 m0, ((20 << 16) | 10)\nÊ   s_movrelsd_2_b32 s5, s7',
  SOP1Op.S_GETPC_B64: 'D0.i64 = PC + 4LL',
  SOP1Op.S_SETPC_B64: 'PC = S0.i64',
  SOP1Op.S_SWAPPC_B64: 'jump_addr = S0.i64;\nD0.i64 = PC + 4LL;\nPC = jump_addr.i64',
  SOP1Op.S_RFE_B64: "WAVE_STATUS.PRIV = 1'0U;\nPC = S0.i64",
  SOP1Op.S_CEIL_F32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then\nÊ   D0.f32 += 1.0F\nendif',
  SOP1Op.S_FLOOR_F32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then\nÊ   D0.f32 += -1.0F\nendif',
  SOP1Op.S_TRUNC_F32: 'D0.f32 = trunc(S0.f32)',
  SOP1Op.S_RNDNE_F32: "D0.f32 = floor(S0.f32 + 0.5F);\nif (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then\nÊ   D0.f32 -= 1.0F\nendif",
  SOP1Op.S_CVT_F32_I32: 'D0.f32 = i32_to_f32(S0.i32)',
  SOP1Op.S_CVT_F32_U32: 'D0.f32 = u32_to_f32(S0.u32)',
  SOP1Op.S_CVT_I32_F32: 'D0.i32 = f32_to_i32(S0.f32)',
  SOP1Op.S_CVT_U32_F32: 'D0.u32 = f32_to_u32(S0.f32)',
  SOP1Op.S_CVT_F16_F32: 'D0.f16 = f32_to_f16(S0.f32)',
  SOP1Op.S_CVT_F32_F16: 'D0.f32 = f16_to_f32(S0.f16)',
  SOP1Op.S_CVT_HI_F32_F16: 'D0.f32 = f16_to_f32(S0[31 : 16].f16)',
  SOP1Op.S_CEIL_F16: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then\nÊ   D0.f16 += 16'1.0\nendif",
  SOP1Op.S_FLOOR_F16: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then\nÊ   D0.f16 += -16'1.0\nendif",
  SOP1Op.S_TRUNC_F16: 'D0.f16 = trunc(S0.f16)',
  SOP1Op.S_RNDNE_F16: "endif\nD0.f16 = floor(S0.f16 + 16'0.5);\nif (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then\nÊ   D0.f16 -= 16'1.0",
}

SOP2Op_PCODE = {
  SOP2Op.S_ADD_U32: "tmp = 64'U(S0.u32) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_ADDC_U32.\nD0.u32 = tmp.u32",
  SOP2Op.S_SUB_U32: "tmp = S0.u32 - S1.u32;\nSCC = S1.u32 > S0.u32 ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_SUBB_U32.\nD0.u32 = tmp.u32",
  SOP2Op.S_ADD_I32: 'tmp = S0.i32 + S1.i32;\nSCC = ((S0.u32[31] == S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));\n// signed overflow.\nD0.i32 = tmp.i32',
  SOP2Op.S_SUB_I32: 'tmp = S0.i32 - S1.i32;\nSCC = ((S0.u32[31] != S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));\n// signed overflow.\nD0.i32 = tmp.i32',
  SOP2Op.S_ADDC_U32: "tmp = 64'U(S0.u32) + 64'U(S1.u32) + SCC.u64;\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_ADDC_U32.\nD0.u32 = tmp.u32",
  SOP2Op.S_SUBB_U32: "tmp = S0.u32 - S1.u32 - SCC.u32;\nSCC = 64'U(S1.u32) + SCC.u64 > 64'U(S0.u32) ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_SUBB_U32.\nD0.u32 = tmp.u32",
  SOP2Op.S_ABSDIFF_I32: 'S_ABSDIFF_I32(0x00000002, 0x00000005) => 0x00000003\nS_ABSDIFF_I32(0xffffffff, 0x00000000) => 0x00000001\nS_ABSDIFF_I32(0x80000000, 0x00000000) => 0x80000000     // Note: result is negative!\nS_ABSDIFF_I32(0x80000000, 0x00000001) => 0x7fffffff\nS_ABSDIFF_I32(0x80000000, 0xffffffff) => 0x7fffffff\nS_ABSDIFF_I32(0x80000000, 0xfffffffe) => 0x7ffffffe\nD0.i32 = S0.i32 - S1.i32;\nif D0.i32 < 0 then\nÊ   D0.i32 = -D0.i32\nendif;\nSCC = D0.i32 != 0',
  SOP2Op.S_LSHL_B32: 'D0.u32 = (S0.u32 << S1[4 : 0].u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_LSHL_B64: 'D0.u64 = (S0.u64 << S1[5 : 0].u32);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_LSHR_B32: 'D0.u32 = (S0.u32 >> S1[4 : 0].u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_LSHR_B64: 'D0.u64 = (S0.u64 >> S1[5 : 0].u32);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_ASHR_I32: "D0.i32 = 32'I(signext(S0.i32) >> S1[4 : 0].u32);\nSCC = D0.i32 != 0",
  SOP2Op.S_ASHR_I64: 'D0.i64 = (signext(S0.i64) >> S1[5 : 0].u32);\nSCC = D0.i64 != 0LL',
  SOP2Op.S_LSHL1_ADD_U32: "tmp = (64'U(S0.u32) << 1U) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u32 = tmp.u32",
  SOP2Op.S_LSHL2_ADD_U32: "tmp = (64'U(S0.u32) << 2U) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u32 = tmp.u32",
  SOP2Op.S_LSHL3_ADD_U32: "tmp = (64'U(S0.u32) << 3U) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u32 = tmp.u32",
  SOP2Op.S_LSHL4_ADD_U32: "tmp = (64'U(S0.u32) << 4U) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u32 = tmp.u32",
  SOP2Op.S_MIN_I32: 'SCC = S0.i32 < S1.i32;\nD0.i32 = SCC ? S0.i32 : S1.i32',
  SOP2Op.S_MIN_U32: 'SCC = S0.u32 < S1.u32;\nD0.u32 = SCC ? S0.u32 : S1.u32',
  SOP2Op.S_MAX_I32: 'SCC = S0.i32 >= S1.i32;\nD0.i32 = SCC ? S0.i32 : S1.i32',
  SOP2Op.S_MAX_U32: 'SCC = S0.u32 >= S1.u32;\nD0.u32 = SCC ? S0.u32 : S1.u32',
  SOP2Op.S_AND_B32: 'D0.u32 = (S0.u32 & S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_AND_B64: 'D0.u64 = (S0.u64 & S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_OR_B32: 'D0.u32 = (S0.u32 | S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_OR_B64: 'D0.u64 = (S0.u64 | S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_XOR_B32: 'D0.u32 = (S0.u32 ^ S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_XOR_B64: 'D0.u64 = (S0.u64 ^ S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_NAND_B32: 'D0.u32 = ~(S0.u32 & S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_NAND_B64: 'D0.u64 = ~(S0.u64 & S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_NOR_B32: 'D0.u32 = ~(S0.u32 | S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_NOR_B64: 'D0.u64 = ~(S0.u64 | S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_XNOR_B32: 'D0.u32 = ~(S0.u32 ^ S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_XNOR_B64: 'D0.u64 = ~(S0.u64 ^ S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_AND_NOT1_B32: 'D0.u32 = (S0.u32 & ~S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_AND_NOT1_B64: 'D0.u64 = (S0.u64 & ~S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_OR_NOT1_B32: 'D0.u32 = (S0.u32 | ~S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_OR_NOT1_B64: 'D0.u64 = (S0.u64 | ~S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_BFE_U32: 'D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1U << S1[22 : 16].u32) - 1U));\nSCC = D0.u32 != 0U',
  SOP2Op.S_BFE_I32: 'tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S1[22 : 16].u32) - 1));\nD0.i32 = signext_from_bit(tmp.i32, S1[22 : 16].u32);\nSCC = D0.i32 != 0',
  SOP2Op.S_BFE_U64: 'D0.u64 = ((S0.u64 >> S1[5 : 0].u32) & ((1ULL << S1[22 : 16].u32) - 1ULL));\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_BFE_I64: 'tmp.i64 = ((S0.i64 >> S1[5 : 0].u32) & ((1LL << S1[22 : 16].u32) - 1LL));\nD0.i64 = signext_from_bit(tmp.i64, S1[22 : 16].u32);\nSCC = D0.i64 != 0LL',
  SOP2Op.S_BFM_B32: 'D0.u32 = (((1U << S0[4 : 0].u32) - 1U) << S1[4 : 0].u32)',
  SOP2Op.S_BFM_B64: 'D0.u64 = (((1ULL << S0[5 : 0].u32) - 1ULL) << S1[5 : 0].u32)',
  SOP2Op.S_MUL_I32: 'D0.i32 = S0.i32 * S1.i32',
  SOP2Op.S_MUL_HI_U32: "D0.u32 = 32'U((64'U(S0.u32) * 64'U(S1.u32)) >> 32U)",
  SOP2Op.S_MUL_HI_I32: "D0.i32 = 32'I((64'I(S0.i32) * 64'I(S1.i32)) >> 32U)",
  SOP2Op.S_CSELECT_B32: 'D0.u32 = SCC ? S0.u32 : S1.u32',
  SOP2Op.S_CSELECT_B64: 'D0.u64 = SCC ? S0.u64 : S1.u64',
  SOP2Op.S_PACK_LL_B32_B16: 'D0 = { S1[15 : 0].u16, S0[15 : 0].u16 }',
  SOP2Op.S_PACK_LH_B32_B16: 'D0 = { S1[31 : 16].u16, S0[15 : 0].u16 }',
  SOP2Op.S_PACK_HH_B32_B16: 'D0 = { S1[31 : 16].u16, S0[31 : 16].u16 }',
  SOP2Op.S_PACK_HL_B32_B16: 'D0 = { S1[15 : 0].u16, S0[31 : 16].u16 }',
  SOP2Op.S_ADD_F32: 'D0.f32 = S0.f32 + S1.f32',
  SOP2Op.S_SUB_F32: 'D0.f32 = S0.f32 - S1.f32',
  SOP2Op.S_MIN_F32: "LT_NEG_ZERO = lambda(a, b) (\nÊ   ((a < b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nÊ   elsif isSignalNAN(64'F(S1.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nÊ   elsif isQuietNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isQuietNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif LT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif LT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.",
  SOP2Op.S_MAX_F32: "Ê   elsif isQuietNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif GT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif GT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.\nGT_NEG_ZERO = lambda(a, b) (\nÊ   ((a > b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nÊ   elsif isSignalNAN(64'F(S1.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nÊ   elsif isQuietNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32",
  SOP2Op.S_MUL_F32: 'D0.f32 = S0.f32 * S1.f32',
  SOP2Op.S_FMAAK_F32: 'D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)',
  SOP2Op.S_FMAMK_F32: 'D0.f32 = fma(S0.f32, SIMM32.f32, S1.f32)',
  SOP2Op.S_FMAC_F32: 'D0.f32 = fma(S0.f32, S1.f32, D0.f32)',
  SOP2Op.S_CVT_PK_RTZ_F16_F32: 'prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_TOWARD_ZERO;\ntmp[15 : 0].f16 = f32_to_f16(S0.f32);\ntmp[31 : 16].f16 = f32_to_f16(S1.f32);\nD0 = tmp.b32;\nROUND_MODE = prev_mode;\n// Round-toward-zero regardless of current round mode setting in hardware.',
  SOP2Op.S_ADD_F16: 'D0.f16 = S0.f16 + S1.f16',
  SOP2Op.S_SUB_F16: 'D0.f16 = S0.f16 - S1.f16',
  SOP2Op.S_MIN_F16: "if WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nÊ   elsif isSignalNAN(64'F(S1.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nÊ   elsif isQuietNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isQuietNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif LT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif LT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.\nLT_NEG_ZERO = lambda(a, b) (\nÊ   ((a < b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE",
  SOP2Op.S_MAX_F16: "Ê       D0.f16 = S0.f16\nÊ   elsif isNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif GT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.\nGT_NEG_ZERO = lambda(a, b) (\nÊ   ((a > b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nÊ   elsif isSignalNAN(64'F(S1.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nÊ   elsif isQuietNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isQuietNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif GT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f16)) then",
  SOP2Op.S_MUL_F16: 'D0.f16 = S0.f16 * S1.f16',
  SOP2Op.S_FMAC_F16: 'D0.f16 = fma(S0.f16, S1.f16, D0.f16)',
}

SOPCOp_PCODE = {
  SOPCOp.S_CMP_EQ_I32: 'SCC = S0.i32 == S1.i32',
  SOPCOp.S_CMP_LG_I32: 'SCC = S0.i32 <> S1.i32',
  SOPCOp.S_CMP_GT_I32: 'SCC = S0.i32 > S1.i32',
  SOPCOp.S_CMP_GE_I32: 'SCC = S0.i32 >= S1.i32',
  SOPCOp.S_CMP_LT_I32: 'SCC = S0.i32 < S1.i32',
  SOPCOp.S_CMP_LE_I32: 'SCC = S0.i32 <= S1.i32',
  SOPCOp.S_CMP_EQ_U32: 'SCC = S0.u32 == S1.u32',
  SOPCOp.S_CMP_LG_U32: 'SCC = S0.u32 <> S1.u32',
  SOPCOp.S_CMP_GT_U32: 'SCC = S0.u32 > S1.u32',
  SOPCOp.S_CMP_GE_U32: 'SCC = S0.u32 >= S1.u32',
  SOPCOp.S_CMP_LT_U32: 'SCC = S0.u32 < S1.u32',
  SOPCOp.S_CMP_LE_U32: 'SCC = S0.u32 <= S1.u32',
  SOPCOp.S_BITCMP0_B32: "SCC = S0.u32[S1.u32[4 : 0]] == 1'0U",
  SOPCOp.S_BITCMP1_B32: "SCC = S0.u32[S1.u32[4 : 0]] == 1'1U",
  SOPCOp.S_BITCMP0_B64: "SCC = S0.u64[S1.u32[5 : 0]] == 1'0U",
  SOPCOp.S_BITCMP1_B64: "SCC = S0.u64[S1.u32[5 : 0]] == 1'1U",
  SOPCOp.S_CMP_EQ_U64: 'SCC = S0.u64 == S1.u64',
  SOPCOp.S_CMP_LG_U64: 'SCC = S0.u64 <> S1.u64',
  SOPCOp.S_CMP_LT_F32: 'SCC = S0.f32 < S1.f32',
  SOPCOp.S_CMP_EQ_F32: 'SCC = S0.f32 == S1.f32',
  SOPCOp.S_CMP_LE_F32: 'SCC = S0.f32 <= S1.f32',
  SOPCOp.S_CMP_GT_F32: 'SCC = S0.f32 > S1.f32',
  SOPCOp.S_CMP_LG_F32: 'SCC = S0.f32 <> S1.f32',
  SOPCOp.S_CMP_GE_F32: 'SCC = S0.f32 >= S1.f32',
  SOPCOp.S_CMP_O_F32: "SCC = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)))",
  SOPCOp.S_CMP_U_F32: "SCC = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)))",
  SOPCOp.S_CMP_NGE_F32: 'SCC = !(S0.f32 >= S1.f32);\n// With NAN inputs this is not the same operation as <',
  SOPCOp.S_CMP_NLG_F32: 'SCC = !(S0.f32 <> S1.f32);\n// With NAN inputs this is not the same operation as ==',
  SOPCOp.S_CMP_NGT_F32: 'SCC = !(S0.f32 > S1.f32);\n// With NAN inputs this is not the same operation as <=',
  SOPCOp.S_CMP_NLE_F32: 'SCC = !(S0.f32 <= S1.f32);\n// With NAN inputs this is not the same operation as >',
  SOPCOp.S_CMP_NEQ_F32: 'SCC = !(S0.f32 == S1.f32);\n// With NAN inputs this is not the same operation as !=',
  SOPCOp.S_CMP_NLT_F32: 'SCC = !(S0.f32 < S1.f32);\n// With NAN inputs this is not the same operation as >=',
  SOPCOp.S_CMP_LT_F16: 'SCC = S0.f16 < S1.f16',
  SOPCOp.S_CMP_EQ_F16: 'SCC = S0.f16 == S1.f16',
  SOPCOp.S_CMP_LE_F16: 'SCC = S0.f16 <= S1.f16',
  SOPCOp.S_CMP_GT_F16: 'SCC = S0.f16 > S1.f16',
  SOPCOp.S_CMP_LG_F16: 'SCC = S0.f16 <> S1.f16',
  SOPCOp.S_CMP_GE_F16: 'SCC = S0.f16 >= S1.f16',
  SOPCOp.S_CMP_O_F16: "SCC = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)))",
  SOPCOp.S_CMP_U_F16: "SCC = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)))",
  SOPCOp.S_CMP_NGE_F16: 'SCC = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <',
  SOPCOp.S_CMP_NLG_F16: 'SCC = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==',
  SOPCOp.S_CMP_NGT_F16: 'SCC = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=',
  SOPCOp.S_CMP_NLE_F16: 'SCC = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >',
  SOPCOp.S_CMP_NEQ_F16: 'SCC = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=',
  SOPCOp.S_CMP_NLT_F16: 'SCC = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=',
}

SOPKOp_PCODE = {
  SOPKOp.S_MOVK_I32: "D0.i32 = 32'I(signext(SIMM16.i16))",
  SOPKOp.S_VERSION: 'nop();\n// Do nothing - for use by tools only',
  SOPKOp.S_CMOVK_I32: "Ê   D0.i32 = 32'I(signext(SIMM16.i16))\nendif\nif SCC then",
  SOPKOp.S_CMPK_EQ_I32: "SCC = 64'I(S0.i32) == signext(SIMM16.i16)",
  SOPKOp.S_CMPK_LG_I32: "SCC = 64'I(S0.i32) != signext(SIMM16.i16)",
  SOPKOp.S_CMPK_GT_I32: "SCC = 64'I(S0.i32) > signext(SIMM16.i16)",
  SOPKOp.S_CMPK_GE_I32: "SCC = 64'I(S0.i32) >= signext(SIMM16.i16)",
  SOPKOp.S_CMPK_LT_I32: "SCC = 64'I(S0.i32) < signext(SIMM16.i16)",
  SOPKOp.S_CMPK_LE_I32: "SCC = 64'I(S0.i32) <= signext(SIMM16.i16)",
  SOPKOp.S_CMPK_EQ_U32: "SCC = S0.u32 == 32'U(SIMM16.u16)",
  SOPKOp.S_CMPK_LG_U32: "SCC = S0.u32 != 32'U(SIMM16.u16)",
  SOPKOp.S_CMPK_GT_U32: "SCC = S0.u32 > 32'U(SIMM16.u16)",
  SOPKOp.S_CMPK_GE_U32: "SCC = S0.u32 >= 32'U(SIMM16.u16)",
  SOPKOp.S_CMPK_LT_U32: "SCC = S0.u32 < 32'U(SIMM16.u16)",
  SOPKOp.S_CMPK_LE_U32: "SCC = S0.u32 <= 32'U(SIMM16.u16)",
  SOPKOp.S_ADDK_I32: "tmp = D0.i32;\n// save value so we can check sign bits for overflow later.\nD0.i32 = 32'I(64'I(D0.i32) + signext(SIMM16.i16));\nSCC = ((tmp[31] == SIMM16.i16[15]) && (tmp[31] != D0.i32[31]));\n// signed overflow.",
  SOPKOp.S_MULK_I32: "D0.i32 = 32'I(64'I(D0.i32) * signext(SIMM16.i16))",
  SOPKOp.S_GETREG_B32: "hwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u32 + 1U;\n// logical size is in range 1:32\nvalue = HW_REGISTERS[hwRegId];\nD0.u32 = 32'U(32'I(value >> offset.u32) & ((1 << size) - 1))",
  SOPKOp.S_SETREG_B32: "hwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u32 + 1U;\n// logical size is in range 1:32\nmask = (1 << size) - 1;\nmask = (mask & 32'I(writeableBitMask(hwRegId.u32, WAVE_STATUS.PRIV)));\n// Mask of bits we are allowed to modify\nvalue = ((S0.u32 << offset.u32) & mask.u32);\nvalue = (value | 32'U(HW_REGISTERS[hwRegId].i32 & ~mask));\nHW_REGISTERS[hwRegId] = value.b32;\n// Side-effects may trigger here if certain bits are modified",
  SOPKOp.S_SETREG_IMM32_B32: "hwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u32 + 1U;\n// logical size is in range 1:32\nmask = (1 << size) - 1;\nmask = (mask & 32'I(writeableBitMask(hwRegId.u32, WAVE_STATUS.PRIV)));\n// Mask of bits we are allowed to modify\nvalue = ((SIMM32.u32 << offset.u32) & mask.u32);\nvalue = (value | 32'U(HW_REGISTERS[hwRegId].i32 & ~mask));\nHW_REGISTERS[hwRegId] = value.b32;\n// Side-effects may trigger here if certain bits are modified",
  SOPKOp.S_CALL_B64: "D0.i64 = PC + 4LL;\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL",
  SOPKOp.S_WAITCNT_VSCNT: 'Ê   // Comparison is 6 bits, no clamping is applied for add overflow\nÊ   vscnt <= S0.u[5:0] + S1.u[5:0].',
  SOPKOp.S_WAITCNT_VMCNT: 'Ê   vmcnt <= S0.u[5:0] + S1.u[5:0].\nÊ   // Comparison is 6 bits, no clamping is applied for add overflow',
  SOPKOp.S_WAITCNT_EXPCNT: 'Ê   expcnt <= S0.u[2:0] + S1.u[2:0].\nÊ   // Comparison is 3 bits, no clamping is applied for add overflow',
  SOPKOp.S_WAITCNT_LGKMCNT: 'Ê   lgkmcnt <= S0.u[5:0] + S1.u[5:0].\nÊ   // Comparison is 6 bits, no clamping is applied for add overflow',
}

SOPPOp_PCODE = {
  SOPPOp.S_NOP: 'for i in 0U : SIMM16.u16[3 : 0].u32 do\nÊ   nop()\nendfor\nÊ   s_nop 0         // Wait 1 cycle.\nÊ   s_nop 0xf       // Wait 16 cycles.',
  SOPPOp.S_SLEEP: 'Ê   s_sleep 0       // Wait for 0 clocks.\nÊ   s_sleep 1       // Wait for 1-64 clocks.\nÊ   s_sleep 2       // Wait for 65-128 clocks.',
  SOPPOp.S_DELAY_ALU: 'v_mov_b32 v3, v0\nv_lshlrev_b32   v30, 1, v31\nv_lshlrev_b32   v24, 1, v25\ns_delay_alu instid0(INSTID_VALU_DEP_3) | instskip(INSTSKIP_SKIP_1) | instid1(INSTID_VALU_DEP_1)\nÊ   // 1 cycle delay here\nv_add_f32  v0, v1, v3\nv_sub_f32  v11, v9, v9\nÊ   // 2 cycles delay here\nv_mul_f32  v10, v13, v11',
  SOPPOp.S_WAITCNT: 'Ê   expcnt <= WaitEXPCNT\nÊ   lgkmcnt <= WaitLGKMCNT\nÊ   vmcnt <= WaitVMCNT',
  SOPPOp.S_TRAP: 'TrapID = SIMM16.u16[7 : 0];\n"Wait for all instructions to complete";\n// PC passed into trap handler points to S_TRAP itself,\n// *not* to the next instruction.\n{ TTMP[1], TTMP[0] } = { 7\'0, HT[0], TrapID[7 : 0], PC[47 : 0] };\nPC = TBA.i64;\n// trap base address\nWAVE_STATUS.PRIV = 1\'1U',
  SOPPOp.S_CODE_END: 'Ê   ...\nÊ   s_endpgm     // last real instruction in shader buffer\nÊ   s_code_end      // 1\nÊ   s_code_end      // 2\nÊ   s_code_end      // 3\nÊ   s_code_end      // 4\nÊ   s_code_end      // done!',
  SOPPOp.S_BRANCH: "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL;\n// short jump.\nÊ   s_branch label    // Set SIMM16 = +4 = 0x0004\nÊ   s_nop 0    // 4 bytes\nlabel:\nÊ   s_nop 0    // 4 bytes\nÊ   s_branch label    // Set SIMM16 = -8 = 0xfff8",
  SOPPOp.S_CBRANCH_SCC0: "if SCC == 1'0U then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_SCC1: "if SCC == 1'1U then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_VCCZ: "if VCCZ.u1 == 1'1U then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_VCCNZ: "Ê   PC = PC + 4LL\nendif\nif VCCZ.u1 == 1'0U then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse",
  SOPPOp.S_CBRANCH_EXECZ: "if EXECZ.u1 == 1'1U then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_EXECNZ: "if EXECZ.u1 == 1'0U then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_CDBGSYS: "if WAVE_STATUS.COND_DBG_SYS.u32 != 0U then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_CDBGUSER: "if WAVE_STATUS.COND_DBG_USER.u32 != 0U then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_CDBGSYS_OR_USER: "if (WAVE_STATUS.COND_DBG_SYS || WAVE_STATUS.COND_DBG_USER) then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_CDBGSYS_AND_USER: "if (WAVE_STATUS.COND_DBG_SYS && WAVE_STATUS.COND_DBG_USER) then\nÊ   PC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nÊ   PC = PC + 4LL\nendif",
  SOPPOp.S_SETPRIO: 'Priority = {SysUserPrio[1:0], WaveAge[3:0]}\nSysUserPrio = MIN(3, SysPrio[1:0] + UserPrio[1:0]).',
}

VINTERPOp_PCODE = {
  VINTERPOp.V_INTERP_P10_F32: 'D0.f32 = fma(VGPR[(laneId.u32 & 0xfffffffcU) + 1U][SRC0.u32].f32, S1.f32, VGPR[laneId.u32 &\n0xfffffffcU][SRC2.u32].f32)\ns_mov_b32 m0, s0            // assume s0 contains newprim mask\nlds_param_load v0, attr0    // v0 is a temporary register\nv_interp_p10_f32 v3, v0, v1, v0 // v1 contains i coordinate\nv_interp_p2_f32 v3, v0, v2, v3  // v2 contains j coordinate',
  VINTERPOp.V_INTERP_P2_F32: 'D0.f32 = fma(VGPR[(laneId.u32 & 0xfffffffcU) + 2U][SRC0.u32].f32, S1.f32, S2.f32)',
  VINTERPOp.V_INTERP_P10_F16_F32: "D0.f32 = fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 1U][SRC0.u32].f16), S1.f32, 32'F(VGPR[laneId.u32 &\n0xfffffffcU][SRC2.u32].f16))",
  VINTERPOp.V_INTERP_P2_F16_F32: "D0.f16 = 16'F(fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 2U][SRC0.u32].f16), S1.f32, S2.f32))",
  VINTERPOp.V_INTERP_P10_RTZ_F16_F32: "D0.f32 = fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 1U][SRC0.u32].f16), S1.f32, 32'F(VGPR[laneId.u32 &\n0xfffffffcU][SRC2.u32].f16))",
  VINTERPOp.V_INTERP_P2_RTZ_F16_F32: "OFFSET0  = Unsigned byte offset added to the address from the ADDR VGPR.\nOFFSET1  = Unsigned byte offset added to the address from the ADDR VGPR.\nGDS      = Set if GDS, cleared if LDS.\nOP       = DS instruction opcode\nADDR     = Source LDS address VGPR 0 - 255.\nDATA0    = Source data0 VGPR 0 - 255.\nDATA1    = Source data1 VGPR 0 - 255.\nVDST     = Destination VGPR 0- 255.\nD0.f32 = fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 2U][SRC0.u32].f16), S1.f32, S2.f32)",
}

VOP1Op_PCODE = {
  VOP1Op.V_MOV_B32: 'D0.b32 = S0.b32\nÊ   v_mov_b32 v0, v1    // Move into v0 from v1\nÊ   v_mov_b32 v0, -v1   // Set v0 to the negation of v1\nÊ   v_mov_b32 v0, abs(v1)   // Set v0 to the absolute value of v1',
  VOP1Op.V_READFIRSTLANE_B32: "Ê   // 32 lanes\nÊ   if EXEC_LO.i32 == 0 then\nÊ       lane = 0U;\nÊ       // Force lane 0 if all lanes are disabled\nÊ   else\nÊ       lane = 32'U(s_ff1_i32_b32(EXEC_LO));\nÊ       // Lowest active lane\nÊ   endif\nendif;\nD0.b32 = VGPR[lane][SRC0.u32]\ndeclare lane : 32'U;\nif WAVE64 then\nÊ   // 64 lanes\nÊ   if EXEC == 0x0LL then\nÊ       lane = 0U;\nÊ       // Force lane 0 if all lanes are disabled\nÊ   else\nÊ       lane = 32'U(s_ff1_i32_b64(EXEC));\nÊ       // Lowest active lane\nÊ   endif\nelse",
  VOP1Op.V_CVT_I32_F64: 'D0.i32 = f64_to_i32(S0.f64)',
  VOP1Op.V_CVT_F64_I32: 'D0.f64 = i32_to_f64(S0.i32)',
  VOP1Op.V_CVT_F32_I32: 'D0.f32 = i32_to_f32(S0.i32)',
  VOP1Op.V_CVT_F32_U32: 'D0.f32 = u32_to_f32(S0.u32)',
  VOP1Op.V_CVT_U32_F32: 'D0.u32 = f32_to_u32(S0.f32)',
  VOP1Op.V_CVT_I32_F32: 'D0.i32 = f32_to_i32(S0.f32)',
  VOP1Op.V_CVT_F16_F32: 'D0.f16 = f32_to_f16(S0.f32)',
  VOP1Op.V_CVT_F32_F16: 'D0.f32 = f16_to_f32(S0.f16)',
  VOP1Op.V_CVT_NEAREST_I32_F32: 'D0.i32 = f32_to_i32(floor(S0.f32 + 0.5F))',
  VOP1Op.V_CVT_FLOOR_I32_F32: 'D0.i32 = f32_to_i32(floor(S0.f32))',
  VOP1Op.V_CVT_OFF_F32_I4: "declare CVT_OFF_TABLE : 32'F[16];\nD0.f32 = CVT_OFF_TABLE[S0.u32[3 : 0]]",
  VOP1Op.V_CVT_F32_F64: 'D0.f32 = f64_to_f32(S0.f64)',
  VOP1Op.V_CVT_F64_F32: 'D0.f64 = f32_to_f64(S0.f32)',
  VOP1Op.V_CVT_F32_UBYTE0: 'D0.f32 = u32_to_f32(S0[7 : 0].u32)',
  VOP1Op.V_CVT_F32_UBYTE1: 'D0.f32 = u32_to_f32(S0[15 : 8].u32)',
  VOP1Op.V_CVT_F32_UBYTE2: 'D0.f32 = u32_to_f32(S0[23 : 16].u32)',
  VOP1Op.V_CVT_F32_UBYTE3: 'D0.f32 = u32_to_f32(S0[31 : 24].u32)',
  VOP1Op.V_CVT_U32_F64: 'D0.u32 = f64_to_u32(S0.f64)',
  VOP1Op.V_CVT_F64_U32: 'D0.f64 = u32_to_f64(S0.u32)',
  VOP1Op.V_TRUNC_F64: 'D0.f64 = trunc(S0.f64)',
  VOP1Op.V_CEIL_F64: 'D0.f64 = trunc(S0.f64);\nif ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then\nÊ   D0.f64 += 1.0\nendif',
  VOP1Op.V_RNDNE_F64: 'D0.f64 = floor(S0.f64 + 0.5);\nif (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then\nÊ   D0.f64 -= 1.0\nendif',
  VOP1Op.V_FLOOR_F64: 'D0.f64 = trunc(S0.f64);\nif ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then\nÊ   D0.f64 += -1.0\nendif',
  VOP1Op.V_MOV_B16: 'D0.b16 = S0.b16',
  VOP1Op.V_FRACT_F32: 'D0.f32 = S0.f32 + -floor(S0.f32)',
  VOP1Op.V_TRUNC_F32: 'D0.f32 = trunc(S0.f32)',
  VOP1Op.V_CEIL_F32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then\nÊ   D0.f32 += 1.0F\nendif',
  VOP1Op.V_RNDNE_F32: "D0.f32 = floor(S0.f32 + 0.5F);\nif (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then\nÊ   D0.f32 -= 1.0F\nendif",
  VOP1Op.V_FLOOR_F32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then\nÊ   D0.f32 += -1.0F\nendif',
  VOP1Op.V_EXP_F32: 'D0.f32 = pow(2.0F, S0.f32)\nV_EXP_F32(0xff800000) => 0x00000000     // exp(-INF) = 0\nV_EXP_F32(0x80000000) => 0x3f800000     // exp(-0.0) = 1\nV_EXP_F32(0x7f800000) => 0x7f800000     // exp(+INF) = +INF',
  VOP1Op.V_LOG_F32: 'V_LOG_F32(0xff800000) => 0xffc00000     // log(-INF) = NAN\nV_LOG_F32(0xbf800000) => 0xffc00000     // log(-1.0) = NAN\nV_LOG_F32(0x80000000) => 0xff800000     // log(-0.0) = -INF\nV_LOG_F32(0x00000000) => 0xff800000     // log(+0.0) = -INF\nV_LOG_F32(0x3f800000) => 0x00000000     // log(+1.0) = 0\nV_LOG_F32(0x7f800000) => 0x7f800000     // log(+INF) = +INF\nD0.f32 = log2(S0.f32)',
  VOP1Op.V_RCP_F32: 'D0.f32 = 1.0F / S0.f32\nV_RCP_F32(0xff800000) => 0x80000000     // rcp(-INF) = -0\nV_RCP_F32(0xc0000000) => 0xbf000000     // rcp(-2.0) = -0.5\nV_RCP_F32(0x80000000) => 0xff800000     // rcp(-0.0) = -INF\nV_RCP_F32(0x00000000) => 0x7f800000     // rcp(+0.0) = +INF\nV_RCP_F32(0x7f800000) => 0x00000000     // rcp(+INF) = +0',
  VOP1Op.V_RCP_IFLAG_F32: 'D0.f32 = 1.0F / S0.f32;\n// Can only raise integer DIV_BY_ZERO exception',
  VOP1Op.V_RSQ_F32: 'D0.f32 = 1.0F / sqrt(S0.f32)\nV_RSQ_F32(0xff800000) => 0xffc00000     // rsq(-INF) = NAN\nV_RSQ_F32(0x80000000) => 0xff800000     // rsq(-0.0) = -INF\nV_RSQ_F32(0x00000000) => 0x7f800000     // rsq(+0.0) = +INF\nV_RSQ_F32(0x40800000) => 0x3f000000     // rsq(+4.0) = +0.5\nV_RSQ_F32(0x7f800000) => 0x00000000     // rsq(+INF) = +0',
  VOP1Op.V_RCP_F64: 'D0.f64 = 1.0 / S0.f64',
  VOP1Op.V_RSQ_F64: 'D0.f64 = 1.0 / sqrt(S0.f64)',
  VOP1Op.V_SQRT_F32: 'D0.f32 = sqrt(S0.f32)\nV_SQRT_F32(0xff800000) => 0xffc00000     // sqrt(-INF) = NAN\nV_SQRT_F32(0x80000000) => 0x80000000     // sqrt(-0.0) = -0\nV_SQRT_F32(0x00000000) => 0x00000000     // sqrt(+0.0) = +0\nV_SQRT_F32(0x40800000) => 0x40000000     // sqrt(+4.0) = +2.0\nV_SQRT_F32(0x7f800000) => 0x7f800000     // sqrt(+INF) = +INF',
  VOP1Op.V_SQRT_F64: 'D0.f64 = sqrt(S0.f64)',
  VOP1Op.V_SIN_F32: "D0.f32 = sin(S0.f32 * 32'F(PI * 2.0))\nV_SIN_F32(0xff800000) => 0xffc00000     // sin(-INF) = NAN\nV_SIN_F32(0xff7fffff) => 0x00000000     // -MaxFloat, finite\nV_SIN_F32(0x80000000) => 0x80000000     // sin(-0.0) = -0\nV_SIN_F32(0x3e800000) => 0x3f800000     // sin(0.25) = 1\nV_SIN_F32(0x7f800000) => 0xffc00000     // sin(+INF) = NAN",
  VOP1Op.V_COS_F32: "D0.f32 = cos(S0.f32 * 32'F(PI * 2.0))\nV_COS_F32(0xff800000) => 0xffc00000     // cos(-INF) = NAN\nV_COS_F32(0xff7fffff) => 0x3f800000     // -MaxFloat, finite\nV_COS_F32(0x80000000) => 0x3f800000     // cos(-0.0) = 1\nV_COS_F32(0x3e800000) => 0x00000000     // cos(0.25) = 0\nV_COS_F32(0x7f800000) => 0xffc00000     // cos(+INF) = NAN",
  VOP1Op.V_NOT_B32: 'D0.u32 = ~S0.u32',
  VOP1Op.V_BFREV_B32: 'D0.u32[31 : 0] = S0.u32[0 : 31]',
  VOP1Op.V_CLZ_I32_U32: "D0.i32 = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\nÊ   // Search from MSB\nÊ   if S0.u32[31 - i] == 1'1U then\nÊ       D0.i32 = i;\nÊ       break\nÊ   endif\nendfor\nV_CLZ_I32_U32(0x00000000) => 0xffffffff\nV_CLZ_I32_U32(0x800000ff) => 0\nV_CLZ_I32_U32(0x100000ff) => 3\nV_CLZ_I32_U32(0x0000ffff) => 16\nV_CLZ_I32_U32(0x00000001) => 31",
  VOP1Op.V_CTZ_I32_B32: "D0.i32 = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\nÊ   // Search from LSB\nÊ   if S0.u32[i] == 1'1U then\nÊ       D0.i32 = i;\nÊ       break\nÊ   endif\nendfor\nV_CTZ_I32_B32(0x00000000) => 0xffffffff\nV_CTZ_I32_B32(0xff000001) => 0\nV_CTZ_I32_B32(0xff000008) => 3\nV_CTZ_I32_B32(0xffff0000) => 16\nV_CTZ_I32_B32(0x80000000) => 31",
  VOP1Op.V_CLS_I32: 'V_CLS_I32(0x00000000) => 0xffffffff\nV_CLS_I32(0x40000000) => 1\nV_CLS_I32(0x80000000) => 1\nV_CLS_I32(0x0fffffff) => 4\nV_CLS_I32(0xffff0000) => 16\nV_CLS_I32(0xfffffffe) => 31\nV_CLS_I32(0xffffffff) => 0xffffffff\nD0.i32 = -1;\n// Set if all bits are the same\nfor i in 1 : 31 do\nÊ   // Search from MSB\nÊ   if S0.i32[31 - i] != S0.i32[31] then\nÊ       D0.i32 = i;\nÊ       break\nÊ   endif\nendfor',
  VOP1Op.V_FREXP_EXP_I32_F64: 'if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nÊ   D0.i32 = 0\nelse\nÊ   D0.i32 = exponent(S0.f64) - 1023 + 1\nendif\nfrexp()',
  VOP1Op.V_FREXP_MANT_F64: 'if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nÊ   D0.f64 = S0.f64\nelse\nÊ   D0.f64 = mantissa(S0.f64)\nendif\nfrexp()',
  VOP1Op.V_FRACT_F64: 'D0.f64 = S0.f64 + -floor(S0.f64)',
  VOP1Op.V_FREXP_EXP_I32_F32: "if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then\nÊ   D0.i32 = 0\nelse\nÊ   D0.i32 = exponent(S0.f32) - 127 + 1\nendif\nfrexp()",
  VOP1Op.V_FREXP_MANT_F32: "frexp()\nif ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then\nÊ   D0.f32 = S0.f32\nelse\nÊ   D0.f32 = mantissa(S0.f32)\nendif",
  VOP1Op.V_MOVRELD_B32: 'addr = DST.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nVGPR[laneId][addr].b32 = S0.b32\nÊ   s_mov_b32 m0, 10\nÊ   v_movreld_b32 v5, v7',
  VOP1Op.V_MOVRELS_B32: 'addr = SRC0.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nD0.b32 = VGPR[laneId][addr].b32\nÊ   s_mov_b32 m0, 10\nÊ   v_movrels_b32 v5, v7',
  VOP1Op.V_MOVRELSD_B32: '// Raw value from instruction\naddrs += M0.u32[31 : 0];\naddrd += M0.u32[31 : 0];\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32\nÊ   s_mov_b32 m0, 10\nÊ   v_movrelsd_b32 v5, v7\naddrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;',
  VOP1Op.V_MOVRELSD_2_B32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[9 : 0].u32;\naddrd += M0.u32[25 : 16].u32;\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32\nÊ   s_mov_b32 m0, ((20 << 16) | 10)\nÊ   v_movrelsd_2_b32 v5, v7',
  VOP1Op.V_CVT_F16_U16: 'D0.f16 = u16_to_f16(S0.u16)',
  VOP1Op.V_CVT_F16_I16: 'D0.f16 = i16_to_f16(S0.i16)',
  VOP1Op.V_CVT_U16_F16: 'D0.u16 = f16_to_u16(S0.f16)',
  VOP1Op.V_CVT_I16_F16: 'D0.i16 = f16_to_i16(S0.f16)',
  VOP1Op.V_RCP_F16: "D0.f16 = 16'1.0 / S0.f16\nV_RCP_F16(0xfc00) => 0x8000     // rcp(-INF) = -0\nV_RCP_F16(0xc000) => 0xb800     // rcp(-2.0) = -0.5\nV_RCP_F16(0x8000) => 0xfc00     // rcp(-0.0) = -INF\nV_RCP_F16(0x0000) => 0x7c00     // rcp(+0.0) = +INF\nV_RCP_F16(0x7c00) => 0x0000     // rcp(+INF) = +0",
  VOP1Op.V_SQRT_F16: 'D0.f16 = sqrt(S0.f16)\nV_SQRT_F16(0xfc00) => 0xfe00     // sqrt(-INF) = NAN\nV_SQRT_F16(0x8000) => 0x8000     // sqrt(-0.0) = -0\nV_SQRT_F16(0x0000) => 0x0000     // sqrt(+0.0) = +0\nV_SQRT_F16(0x4400) => 0x4000     // sqrt(+4.0) = +2.0\nV_SQRT_F16(0x7c00) => 0x7c00     // sqrt(+INF) = +INF',
  VOP1Op.V_RSQ_F16: "D0.f16 = 16'1.0 / sqrt(S0.f16)\nV_RSQ_F16(0xfc00) => 0xfe00     // rsq(-INF) = NAN\nV_RSQ_F16(0x8000) => 0xfc00     // rsq(-0.0) = -INF\nV_RSQ_F16(0x0000) => 0x7c00     // rsq(+0.0) = +INF\nV_RSQ_F16(0x4400) => 0x3800     // rsq(+4.0) = +0.5\nV_RSQ_F16(0x7c00) => 0x0000     // rsq(+INF) = +0",
  VOP1Op.V_LOG_F16: 'D0.f16 = log2(S0.f16)\nV_LOG_F16(0xfc00) => 0xfe00     // log(-INF) = NAN\nV_LOG_F16(0xbc00) => 0xfe00     // log(-1.0) = NAN\nV_LOG_F16(0x8000) => 0xfc00     // log(-0.0) = -INF\nV_LOG_F16(0x0000) => 0xfc00     // log(+0.0) = -INF\nV_LOG_F16(0x3c00) => 0x0000     // log(+1.0) = 0\nV_LOG_F16(0x7c00) => 0x7c00     // log(+INF) = +INF',
  VOP1Op.V_EXP_F16: "V_EXP_F16(0xfc00) => 0x0000     // exp(-INF) = 0\nV_EXP_F16(0x8000) => 0x3c00     // exp(-0.0) = 1\nV_EXP_F16(0x7c00) => 0x7c00     // exp(+INF) = +INF\nD0.f16 = pow(16'2.0, S0.f16)",
  VOP1Op.V_FREXP_MANT_F16: "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nÊ   D0.f16 = S0.f16\nelse\nÊ   D0.f16 = mantissa(S0.f16)\nendif\nfrexp()",
  VOP1Op.V_FREXP_EXP_I16_F16: "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nÊ   D0.i16 = 16'0\nelse\nÊ   D0.i16 = 16'I(exponent(S0.f16) - 15 + 1)\nendif\nfrexp()",
  VOP1Op.V_FLOOR_F16: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then\nÊ   D0.f16 += -16'1.0\nendif",
  VOP1Op.V_CEIL_F16: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then\nÊ   D0.f16 += 16'1.0\nendif",
  VOP1Op.V_TRUNC_F16: 'D0.f16 = trunc(S0.f16)',
  VOP1Op.V_RNDNE_F16: "D0.f16 = floor(S0.f16 + 16'0.5);\nif (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then\nÊ   D0.f16 -= 16'1.0\nendif",
  VOP1Op.V_FRACT_F16: 'D0.f16 = S0.f16 + -floor(S0.f16)',
  VOP1Op.V_SIN_F16: "D0.f16 = sin(S0.f16 * 16'F(PI * 2.0))\nV_SIN_F16(0xfc00) => 0xfe00     // sin(-INF) = NAN\nV_SIN_F16(0xfbff) => 0x0000     // Most negative finite FP16\nV_SIN_F16(0x8000) => 0x8000     // sin(-0.0) = -0\nV_SIN_F16(0x3400) => 0x3c00     // sin(0.25) = 1\nV_SIN_F16(0x7bff) => 0x0000     // Most positive finite FP16\nV_SIN_F16(0x7c00) => 0xfe00     // sin(+INF) = NAN",
  VOP1Op.V_COS_F16: "V_COS_F16(0x7bff) => 0x3c00     // Most positive finite FP16\nV_COS_F16(0x7c00) => 0xfe00     // cos(+INF) = NAN\nD0.f16 = cos(S0.f16 * 16'F(PI * 2.0))\nV_COS_F16(0xfc00) => 0xfe00     // cos(-INF) = NAN\nV_COS_F16(0xfbff) => 0x3c00     // Most negative finite FP16\nV_COS_F16(0x8000) => 0x3c00     // cos(-0.0) = 1\nV_COS_F16(0x3400) => 0x0000     // cos(0.25) = 0",
  VOP1Op.V_SAT_PK_U8_I16: "SAT8 = lambda(n) (\nÊ   if n.i32 <= 0 then\nÊ       return 8'0U\nÊ   elsif n >= 16'I(0xff) then\nÊ       return 8'255U\nÊ   else\nÊ       return n[7 : 0].u8\nÊ   endif);\nD0.b16 = { SAT8(S0[31 : 16].i16), SAT8(S0[15 : 0].i16) }",
  VOP1Op.V_CVT_NORM_I16_F16: 'D0.i16 = f16_to_snorm(S0.f16)',
  VOP1Op.V_CVT_NORM_U16_F16: 'D0.u16 = f16_to_unorm(S0.f16)',
  VOP1Op.V_SWAP_B32: 'tmp = D0.b32;\nD0.b32 = S0.b32;\nS0.b32 = tmp',
  VOP1Op.V_SWAP_B16: 'tmp = D0.b16;\nD0.b16 = S0.b16;\nS0.b16 = tmp',
  VOP1Op.V_PERMLANE64_B32: "Ê   endfor\nendif\ndeclare tmp : 32'B[64];\ndeclare lane : 32'U;\nif WAVE32 then\nÊ   // Supported in wave64 ONLY; treated as scalar NOP in wave32\nÊ   s_nop(16'0U)\nelse\nÊ   for lane in 0U : 63U do\nÊ       // Copy original S0 in case D==S0\nÊ       tmp[lane] = VGPR[lane][SRC0.u32]\nÊ   endfor;\nÊ   for lane in 0U : 63U do\nÊ       altlane = { ~lane[5], lane[4 : 0] };\nÊ       // 0<->32, ..., 31<->63\nÊ       if EXEC[lane].u1 then\nÊ           VGPR[lane][VDST.u32] = tmp[altlane]\nÊ       endif",
  VOP1Op.V_SWAPREL_B32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[9 : 0].u32;\naddrd += M0.u32[25 : 16].u32;\ntmp = VGPR[laneId][addrd].b32;\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32;\nVGPR[laneId][addrs].b32 = tmp\nÊ   s_mov_b32 m0, ((20 << 16) | 10)\nÊ   v_swaprel_b32 v5, v7',
  VOP1Op.V_NOT_B16: 'D0.u16 = ~S0.u16',
  VOP1Op.V_CVT_I32_I16: "D0.i32 = 32'I(signext(S0.i16))",
  VOP1Op.V_CVT_U32_U16: "Ê   SRC0  = First operand for instruction.\nÊ   VSRC1 = Second operand for instruction.\nÊ   OP    = Instruction opcode.\nÊ   All VOPC instructions can alternatively be encoded in the VOP3 format.\nD0 = { 16'0, S0.u16 }",
}

VOP2Op_PCODE = {
  VOP2Op.V_CNDMASK_B32: 'D0.u32 = VCC.u64[laneId] ? S1.u32 : S0.u32',
  VOP2Op.V_DOT2ACC_F32_F16: 'tmp = D0.f32;\ntmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16);\ntmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16);\nD0.f32 = tmp',
  VOP2Op.V_ADD_F32: 'D0.f32 = S0.f32 + S1.f32',
  VOP2Op.V_SUB_F32: 'D0.f32 = S0.f32 - S1.f32',
  VOP2Op.V_SUBREV_F32: 'D0.f32 = S1.f32 - S0.f32',
  VOP2Op.V_FMAC_DX9_ZERO_F32: "if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\nÊ   // DX9 rules, 0.0 * x = 0.0\nÊ   D0.f32 = S2.f32\nelse\nÊ   D0.f32 = fma(S0.f32, S1.f32, D0.f32)\nendif",
  VOP2Op.V_MUL_DX9_ZERO_F32: "endif\nif ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\nÊ   // DX9 rules, 0.0 * x = 0.0\nÊ   D0.f32 = 0.0F\nelse\nÊ   D0.f32 = S0.f32 * S1.f32",
  VOP2Op.V_MUL_F32: 'D0.f32 = S0.f32 * S1.f32',
  VOP2Op.V_MUL_I32_I24: "D0.i32 = 32'I(S0.i24) * 32'I(S1.i24)",
  VOP2Op.V_MUL_HI_I32_I24: "D0.i32 = 32'I((64'I(S0.i24) * 64'I(S1.i24)) >> 32U)",
  VOP2Op.V_MUL_U32_U24: "D0.u32 = 32'U(S0.u24) * 32'U(S1.u24)",
  VOP2Op.V_MUL_HI_U32_U24: "D0.u32 = 32'U((64'U(S0.u24) * 64'U(S1.u24)) >> 32U)",
  VOP2Op.V_MIN_F32: "Ê   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.\nLT_NEG_ZERO = lambda(a, b) (\nÊ   ((a < b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nÊ   elsif isSignalNAN(64'F(S1.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nÊ   elsif isQuietNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isQuietNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif LT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif LT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32",
  VOP2Op.V_MAX_F32: "GT_NEG_ZERO = lambda(a, b) (\nÊ   ((a > b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nÊ   elsif isSignalNAN(64'F(S1.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nÊ   elsif isQuietNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isQuietNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif GT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif GT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.",
  VOP2Op.V_MIN_I32: 'D0.i32 = S0.i32 < S1.i32 ? S0.i32 : S1.i32',
  VOP2Op.V_MAX_I32: 'D0.i32 = S0.i32 >= S1.i32 ? S0.i32 : S1.i32',
  VOP2Op.V_MIN_U32: 'D0.u32 = S0.u32 < S1.u32 ? S0.u32 : S1.u32',
  VOP2Op.V_MAX_U32: 'D0.u32 = S0.u32 >= S1.u32 ? S0.u32 : S1.u32',
  VOP2Op.V_LSHLREV_B32: 'D0.u32 = (S1.u32 << S0[4 : 0].u32)',
  VOP2Op.V_LSHRREV_B32: 'D0.u32 = (S1.u32 >> S0[4 : 0].u32)',
  VOP2Op.V_ASHRREV_I32: 'D0.i32 = (S1.i32 >> S0[4 : 0].u32)',
  VOP2Op.V_AND_B32: 'D0.u32 = (S0.u32 & S1.u32)',
  VOP2Op.V_OR_B32: 'D0.u32 = (S0.u32 | S1.u32)',
  VOP2Op.V_XOR_B32: 'D0.u32 = (S0.u32 ^ S1.u32)',
  VOP2Op.V_XNOR_B32: 'D0.u32 = ~(S0.u32 ^ S1.u32)',
  VOP2Op.V_ADD_CO_CI_U32: "tmp = 64'U(S0.u32) + 64'U(S1.u32) + VCC.u64[laneId].u64;\nVCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_ADD_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP2Op.V_SUB_CO_CI_U32: "tmp = S0.u32 - S1.u32 - VCC.u64[laneId].u32;\nVCC.u64[laneId] = 64'U(S1.u32) + VCC.u64[laneId].u64 > 64'U(S0.u32) ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP2Op.V_SUBREV_CO_CI_U32: "tmp = S1.u32 - S0.u32 - VCC.u64[laneId].u32;\nVCC.u64[laneId] = 64'U(S0.u32) + VCC.u64[laneId].u64 > 64'U(S1.u32) ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP2Op.V_ADD_NC_U32: 'D0.u32 = S0.u32 + S1.u32',
  VOP2Op.V_SUB_NC_U32: 'D0.u32 = S0.u32 - S1.u32',
  VOP2Op.V_SUBREV_NC_U32: 'D0.u32 = S1.u32 - S0.u32',
  VOP2Op.V_FMAC_F32: 'D0.f32 = fma(S0.f32, S1.f32, D0.f32)',
  VOP2Op.V_FMAMK_F32: 'D0.f32 = fma(S0.f32, SIMM32.f32, S1.f32)',
  VOP2Op.V_FMAAK_F32: 'D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)',
  VOP2Op.V_CVT_PK_RTZ_F16_F32: 'prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_TOWARD_ZERO;\ntmp[15 : 0].f16 = f32_to_f16(S0.f32);\ntmp[31 : 16].f16 = f32_to_f16(S1.f32);\nD0 = tmp.b32;\nROUND_MODE = prev_mode;\n// Round-toward-zero regardless of current round mode setting in hardware.',
  VOP2Op.V_ADD_F16: 'D0.f16 = S0.f16 + S1.f16',
  VOP2Op.V_SUB_F16: 'D0.f16 = S0.f16 - S1.f16',
  VOP2Op.V_SUBREV_F16: 'D0.f16 = S1.f16 - S0.f16',
  VOP2Op.V_MUL_F16: 'D0.f16 = S0.f16 * S1.f16',
  VOP2Op.V_FMAC_F16: 'D0.f16 = fma(S0.f16, S1.f16, D0.f16)',
  VOP2Op.V_FMAMK_F16: 'D0.f16 = fma(S0.f16, SIMM32.f16, S1.f16)',
  VOP2Op.V_FMAAK_F16: 'D0.f16 = fma(S0.f16, S1.f16, SIMM32.f16)',
  VOP2Op.V_MAX_F16: "Ê   if isNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif GT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.\nGT_NEG_ZERO = lambda(a, b) (\nÊ   ((a > b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nÊ   elsif isSignalNAN(64'F(S1.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nÊ   elsif isQuietNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isQuietNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif GT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nelse",
  VOP2Op.V_MIN_F16: "Ê   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.\nLT_NEG_ZERO = lambda(a, b) (\nÊ   ((a < b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nÊ   elsif isSignalNAN(64'F(S1.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nÊ   elsif isQuietNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isQuietNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif LT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif LT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16",
  VOP2Op.V_LDEXP_F16: "D0.f16 = S0.f16 * 16'F(2.0F ** 32'I(S1.i16))\nldexp()",
  VOP2Op.V_PK_FMAC_F16: 'D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16);\nD0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16)',
}

VOP3Op_PCODE = {
  VOP3Op.V_CMP_F_F16: "// D0 = VCC in VOPC encoding.\nD0.u64[laneId] = 1'0U;",
  VOP3Op.V_CMP_LT_F16: 'D0.u64[laneId] = S0.f16 < S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_F16: 'D0.u64[laneId] = S0.f16 == S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_F16: 'D0.u64[laneId] = S0.f16 <= S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_F16: 'D0.u64[laneId] = S0.f16 > S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LG_F16: 'D0.u64[laneId] = S0.f16 <> S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_F16: 'D0.u64[laneId] = S0.f16 >= S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_O_F16: "D0.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)));\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_U_F16: "D0.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)));\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_NGE_F16: 'D0.u64[laneId] = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLG_F16: 'D0.u64[laneId] = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NGT_F16: 'D0.u64[laneId] = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLE_F16: 'D0.u64[laneId] = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NEQ_F16: 'D0.u64[laneId] = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLT_F16: 'D0.u64[laneId] = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_T_F16: "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_F_F32: "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_LT_F32: '// D0 = VCC in VOPC encoding.\nD0.u64[laneId] = S0.f32 < S1.f32;',
  VOP3Op.V_CMP_EQ_F32: 'D0.u64[laneId] = S0.f32 == S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_F32: 'D0.u64[laneId] = S0.f32 <= S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_F32: 'D0.u64[laneId] = S0.f32 > S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LG_F32: 'D0.u64[laneId] = S0.f32 <> S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_F32: 'D0.u64[laneId] = S0.f32 >= S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_O_F32: "D0.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)));\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_U_F32: "D0.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)));\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_NGE_F32: 'D0.u64[laneId] = !(S0.f32 >= S1.f32);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLG_F32: 'D0.u64[laneId] = !(S0.f32 <> S1.f32);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NGT_F32: 'D0.u64[laneId] = !(S0.f32 > S1.f32);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLE_F32: 'D0.u64[laneId] = !(S0.f32 <= S1.f32);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NEQ_F32: 'D0.u64[laneId] = !(S0.f32 == S1.f32);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLT_F32: 'D0.u64[laneId] = !(S0.f32 < S1.f32);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_T_F32: "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_F_F64: "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_LT_F64: 'D0.u64[laneId] = S0.f64 < S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_F64: '// D0 = VCC in VOPC encoding.\nD0.u64[laneId] = S0.f64 == S1.f64;',
  VOP3Op.V_CMP_LE_F64: 'D0.u64[laneId] = S0.f64 <= S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_F64: 'D0.u64[laneId] = S0.f64 > S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LG_F64: 'D0.u64[laneId] = S0.f64 <> S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_F64: 'D0.u64[laneId] = S0.f64 >= S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_O_F64: 'D0.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64));\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_U_F64: 'D0.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64));\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NGE_F64: 'D0.u64[laneId] = !(S0.f64 >= S1.f64);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLG_F64: 'D0.u64[laneId] = !(S0.f64 <> S1.f64);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NGT_F64: 'D0.u64[laneId] = !(S0.f64 > S1.f64);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLE_F64: 'D0.u64[laneId] = !(S0.f64 <= S1.f64);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NEQ_F64: 'D0.u64[laneId] = !(S0.f64 == S1.f64);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLT_F64: 'D0.u64[laneId] = !(S0.f64 < S1.f64);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_T_F64: "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_LT_I16: 'D0.u64[laneId] = S0.i16 < S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_I16: 'D0.u64[laneId] = S0.i16 == S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_I16: 'D0.u64[laneId] = S0.i16 <= S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_I16: '// D0 = VCC in VOPC encoding.\nD0.u64[laneId] = S0.i16 > S1.i16;',
  VOP3Op.V_CMP_NE_I16: 'D0.u64[laneId] = S0.i16 <> S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_I16: 'D0.u64[laneId] = S0.i16 >= S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_U16: 'D0.u64[laneId] = S0.u16 < S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_U16: 'D0.u64[laneId] = S0.u16 == S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_U16: 'D0.u64[laneId] = S0.u16 <= S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_U16: 'D0.u64[laneId] = S0.u16 > S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_U16: 'D0.u64[laneId] = S0.u16 <> S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_U16: 'D0.u64[laneId] = S0.u16 >= S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_F_I32: "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_LT_I32: 'D0.u64[laneId] = S0.i32 < S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_I32: 'D0.u64[laneId] = S0.i32 == S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_I32: 'D0.u64[laneId] = S0.i32 <= S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_I32: 'D0.u64[laneId] = S0.i32 > S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_I32: 'D0.u64[laneId] = S0.i32 <> S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_I32: 'D0.u64[laneId] = S0.i32 >= S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_T_I32: "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_F_U32: "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_LT_U32: 'D0.u64[laneId] = S0.u32 < S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_U32: 'D0.u64[laneId] = S0.u32 == S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_U32: 'D0.u64[laneId] = S0.u32 <= S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_U32: '// D0 = VCC in VOPC encoding.\nD0.u64[laneId] = S0.u32 > S1.u32;',
  VOP3Op.V_CMP_NE_U32: 'D0.u64[laneId] = S0.u32 <> S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_U32: 'D0.u64[laneId] = S0.u32 >= S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_T_U32: "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_F_I64: "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_LT_I64: 'D0.u64[laneId] = S0.i64 < S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_I64: 'D0.u64[laneId] = S0.i64 == S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_I64: '// D0 = VCC in VOPC encoding.\nD0.u64[laneId] = S0.i64 <= S1.i64;',
  VOP3Op.V_CMP_GT_I64: 'D0.u64[laneId] = S0.i64 > S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_I64: 'D0.u64[laneId] = S0.i64 <> S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_I64: 'D0.u64[laneId] = S0.i64 >= S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_T_I64: "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_F_U64: "D0.u64[laneId] = 1'0U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_LT_U64: 'D0.u64[laneId] = S0.u64 < S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_U64: '// D0 = VCC in VOPC encoding.\nD0.u64[laneId] = S0.u64 == S1.u64;',
  VOP3Op.V_CMP_LE_U64: 'D0.u64[laneId] = S0.u64 <= S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_U64: 'D0.u64[laneId] = S0.u64 > S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_U64: 'D0.u64[laneId] = S0.u64 <> S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_U64: 'D0.u64[laneId] = S0.u64 >= S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_T_U64: "D0.u64[laneId] = 1'1U;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_CLASS_F16: "if isSignalNAN(64'F(S0.f16)) then\nÊ   result = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f16)) then\nÊ   result = S1.u32[1]\nelsif exponent(S0.f16) == 31 then\nÊ   // +-INF\nÊ   result = S1.u32[sign(S0.f16) ? 2 : 9]\nelsif exponent(S0.f16) > 0 then\nÊ   // +-normal value\nÊ   result = S1.u32[sign(S0.f16) ? 3 : 8]\nelsif 64'F(abs(S0.f16)) > 0.0 then\nÊ   // +-denormal value\nÊ   result = S1.u32[sign(S0.f16) ? 4 : 7]\nelse\nÊ   // +-0.0\nÊ   result = S1.u32[sign(S0.f16) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.\ndeclare result : 1'U;",
  VOP3Op.V_CMP_CLASS_F32: "Ê   result = S1.u32[sign(S0.f32) ? 2 : 9]\nelsif exponent(S0.f32) > 0 then\nÊ   // +-normal value\nÊ   result = S1.u32[sign(S0.f32) ? 3 : 8]\nelsif 64'F(abs(S0.f32)) > 0.0 then\nÊ   // +-denormal value\nÊ   result = S1.u32[sign(S0.f32) ? 4 : 7]\nelse\nÊ   // +-0.0\nÊ   result = S1.u32[sign(S0.f32) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.\ndeclare result : 1'U;\nif isSignalNAN(64'F(S0.f32)) then\nÊ   result = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f32)) then\nÊ   result = S1.u32[1]\nelsif exponent(S0.f32) == 255 then\nÊ   // +-INF",
  VOP3Op.V_CMP_CLASS_F64: "Ê   result = S1.u32[sign(S0.f64) ? 4 : 7]\nelse\nÊ   // +-0.0\nÊ   result = S1.u32[sign(S0.f64) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.\ndeclare result : 1'U;\nif isSignalNAN(S0.f64) then\nÊ   result = S1.u32[0]\nelsif isQuietNAN(S0.f64) then\nÊ   result = S1.u32[1]\nelsif exponent(S0.f64) == 2047 then\nÊ   // +-INF\nÊ   result = S1.u32[sign(S0.f64) ? 2 : 9]\nelsif exponent(S0.f64) > 0 then\nÊ   // +-normal value\nÊ   result = S1.u32[sign(S0.f64) ? 3 : 8]\nelsif abs(S0.f64) > 0.0 then\nÊ   // +-denormal value",
  VOP3Op.V_CMPX_F_F16: "EXEC.u64[laneId] = 1'0U",
  VOP3Op.V_CMPX_LT_F16: 'EXEC.u64[laneId] = S0.f16 < S1.f16',
  VOP3Op.V_CMPX_EQ_F16: 'EXEC.u64[laneId] = S0.f16 == S1.f16',
  VOP3Op.V_CMPX_LE_F16: 'EXEC.u64[laneId] = S0.f16 <= S1.f16',
  VOP3Op.V_CMPX_GT_F16: 'EXEC.u64[laneId] = S0.f16 > S1.f16',
  VOP3Op.V_CMPX_LG_F16: 'EXEC.u64[laneId] = S0.f16 <> S1.f16',
  VOP3Op.V_CMPX_GE_F16: 'EXEC.u64[laneId] = S0.f16 >= S1.f16',
  VOP3Op.V_CMPX_O_F16: "EXEC.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)))",
  VOP3Op.V_CMPX_U_F16: "EXEC.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)))",
  VOP3Op.V_CMPX_NGE_F16: 'EXEC.u64[laneId] = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <',
  VOP3Op.V_CMPX_NLG_F16: 'EXEC.u64[laneId] = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==',
  VOP3Op.V_CMPX_NGT_F16: 'EXEC.u64[laneId] = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=',
  VOP3Op.V_CMPX_NLE_F16: 'EXEC.u64[laneId] = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >',
  VOP3Op.V_CMPX_NEQ_F16: '// With NAN inputs this is not the same operation as !=\nEXEC.u64[laneId] = !(S0.f16 == S1.f16);',
  VOP3Op.V_CMPX_NLT_F16: 'EXEC.u64[laneId] = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=',
  VOP3Op.V_CMPX_T_F16: "EXEC.u64[laneId] = 1'1U",
  VOP3Op.V_CMPX_F_F32: "EXEC.u64[laneId] = 1'0U",
  VOP3Op.V_CMPX_LT_F32: 'EXEC.u64[laneId] = S0.f32 < S1.f32',
  VOP3Op.V_CMPX_EQ_F32: 'EXEC.u64[laneId] = S0.f32 == S1.f32',
  VOP3Op.V_CMPX_LE_F32: 'EXEC.u64[laneId] = S0.f32 <= S1.f32',
  VOP3Op.V_CMPX_GT_F32: 'EXEC.u64[laneId] = S0.f32 > S1.f32',
  VOP3Op.V_CMPX_LG_F32: 'EXEC.u64[laneId] = S0.f32 <> S1.f32',
  VOP3Op.V_CMPX_GE_F32: 'EXEC.u64[laneId] = S0.f32 >= S1.f32',
  VOP3Op.V_CMPX_O_F32: "EXEC.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)))",
  VOP3Op.V_CMPX_U_F32: "EXEC.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)))",
  VOP3Op.V_CMPX_NGE_F32: 'EXEC.u64[laneId] = !(S0.f32 >= S1.f32);\n// With NAN inputs this is not the same operation as <',
  VOP3Op.V_CMPX_NLG_F32: 'EXEC.u64[laneId] = !(S0.f32 <> S1.f32);\n// With NAN inputs this is not the same operation as ==',
  VOP3Op.V_CMPX_NGT_F32: 'EXEC.u64[laneId] = !(S0.f32 > S1.f32);\n// With NAN inputs this is not the same operation as <=',
  VOP3Op.V_CMPX_NLE_F32: 'EXEC.u64[laneId] = !(S0.f32 <= S1.f32);\n// With NAN inputs this is not the same operation as >',
  VOP3Op.V_CMPX_NEQ_F32: 'EXEC.u64[laneId] = !(S0.f32 == S1.f32);\n// With NAN inputs this is not the same operation as !=',
  VOP3Op.V_CMPX_NLT_F32: 'EXEC.u64[laneId] = !(S0.f32 < S1.f32);\n// With NAN inputs this is not the same operation as >=',
  VOP3Op.V_CMPX_T_F32: "EXEC.u64[laneId] = 1'1U",
  VOP3Op.V_CMPX_F_F64: "EXEC.u64[laneId] = 1'0U",
  VOP3Op.V_CMPX_LT_F64: 'EXEC.u64[laneId] = S0.f64 < S1.f64',
  VOP3Op.V_CMPX_EQ_F64: 'EXEC.u64[laneId] = S0.f64 == S1.f64',
  VOP3Op.V_CMPX_LE_F64: 'EXEC.u64[laneId] = S0.f64 <= S1.f64',
  VOP3Op.V_CMPX_GT_F64: 'EXEC.u64[laneId] = S0.f64 > S1.f64',
  VOP3Op.V_CMPX_LG_F64: 'EXEC.u64[laneId] = S0.f64 <> S1.f64',
  VOP3Op.V_CMPX_GE_F64: 'EXEC.u64[laneId] = S0.f64 >= S1.f64',
  VOP3Op.V_CMPX_O_F64: 'EXEC.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64))',
  VOP3Op.V_CMPX_U_F64: 'EXEC.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64))',
  VOP3Op.V_CMPX_NGE_F64: 'EXEC.u64[laneId] = !(S0.f64 >= S1.f64);\n// With NAN inputs this is not the same operation as <',
  VOP3Op.V_CMPX_NLG_F64: 'EXEC.u64[laneId] = !(S0.f64 <> S1.f64);\n// With NAN inputs this is not the same operation as ==',
  VOP3Op.V_CMPX_NGT_F64: 'EXEC.u64[laneId] = !(S0.f64 > S1.f64);\n// With NAN inputs this is not the same operation as <=',
  VOP3Op.V_CMPX_NLE_F64: 'EXEC.u64[laneId] = !(S0.f64 <= S1.f64);\n// With NAN inputs this is not the same operation as >',
  VOP3Op.V_CMPX_NEQ_F64: 'EXEC.u64[laneId] = !(S0.f64 == S1.f64);\n// With NAN inputs this is not the same operation as !=',
  VOP3Op.V_CMPX_NLT_F64: 'EXEC.u64[laneId] = !(S0.f64 < S1.f64);\n// With NAN inputs this is not the same operation as >=',
  VOP3Op.V_CMPX_T_F64: "EXEC.u64[laneId] = 1'1U",
  VOP3Op.V_CMPX_LT_I16: 'EXEC.u64[laneId] = S0.i16 < S1.i16',
  VOP3Op.V_CMPX_EQ_I16: 'EXEC.u64[laneId] = S0.i16 == S1.i16',
  VOP3Op.V_CMPX_LE_I16: 'EXEC.u64[laneId] = S0.i16 <= S1.i16',
  VOP3Op.V_CMPX_GT_I16: 'EXEC.u64[laneId] = S0.i16 > S1.i16',
  VOP3Op.V_CMPX_NE_I16: 'EXEC.u64[laneId] = S0.i16 <> S1.i16',
  VOP3Op.V_CMPX_GE_I16: 'EXEC.u64[laneId] = S0.i16 >= S1.i16',
  VOP3Op.V_CMPX_LT_U16: 'EXEC.u64[laneId] = S0.u16 < S1.u16',
  VOP3Op.V_CMPX_EQ_U16: 'EXEC.u64[laneId] = S0.u16 == S1.u16',
  VOP3Op.V_CMPX_LE_U16: 'EXEC.u64[laneId] = S0.u16 <= S1.u16',
  VOP3Op.V_CMPX_GT_U16: 'EXEC.u64[laneId] = S0.u16 > S1.u16',
  VOP3Op.V_CMPX_NE_U16: 'EXEC.u64[laneId] = S0.u16 <> S1.u16',
  VOP3Op.V_CMPX_GE_U16: 'EXEC.u64[laneId] = S0.u16 >= S1.u16',
  VOP3Op.V_CMPX_F_I32: "EXEC.u64[laneId] = 1'0U",
  VOP3Op.V_CMPX_LT_I32: 'EXEC.u64[laneId] = S0.i32 < S1.i32',
  VOP3Op.V_CMPX_EQ_I32: 'EXEC.u64[laneId] = S0.i32 == S1.i32',
  VOP3Op.V_CMPX_LE_I32: 'EXEC.u64[laneId] = S0.i32 <= S1.i32',
  VOP3Op.V_CMPX_GT_I32: 'EXEC.u64[laneId] = S0.i32 > S1.i32',
  VOP3Op.V_CMPX_NE_I32: 'EXEC.u64[laneId] = S0.i32 <> S1.i32',
  VOP3Op.V_CMPX_GE_I32: 'EXEC.u64[laneId] = S0.i32 >= S1.i32',
  VOP3Op.V_CMPX_T_I32: "EXEC.u64[laneId] = 1'1U",
  VOP3Op.V_CMPX_F_U32: "EXEC.u64[laneId] = 1'0U",
  VOP3Op.V_CMPX_LT_U32: 'EXEC.u64[laneId] = S0.u32 < S1.u32',
  VOP3Op.V_CMPX_EQ_U32: 'EXEC.u64[laneId] = S0.u32 == S1.u32',
  VOP3Op.V_CMPX_LE_U32: 'EXEC.u64[laneId] = S0.u32 <= S1.u32',
  VOP3Op.V_CMPX_GT_U32: 'EXEC.u64[laneId] = S0.u32 > S1.u32',
  VOP3Op.V_CMPX_NE_U32: 'EXEC.u64[laneId] = S0.u32 <> S1.u32',
  VOP3Op.V_CMPX_GE_U32: 'EXEC.u64[laneId] = S0.u32 >= S1.u32',
  VOP3Op.V_CMPX_T_U32: "EXEC.u64[laneId] = 1'1U",
  VOP3Op.V_CMPX_F_I64: "EXEC.u64[laneId] = 1'0U",
  VOP3Op.V_CMPX_LT_I64: 'EXEC.u64[laneId] = S0.i64 < S1.i64',
  VOP3Op.V_CMPX_EQ_I64: 'EXEC.u64[laneId] = S0.i64 == S1.i64',
  VOP3Op.V_CMPX_LE_I64: 'EXEC.u64[laneId] = S0.i64 <= S1.i64',
  VOP3Op.V_CMPX_GT_I64: 'EXEC.u64[laneId] = S0.i64 > S1.i64',
  VOP3Op.V_CMPX_NE_I64: 'EXEC.u64[laneId] = S0.i64 <> S1.i64',
  VOP3Op.V_CMPX_GE_I64: 'EXEC.u64[laneId] = S0.i64 >= S1.i64',
  VOP3Op.V_CMPX_T_I64: "EXEC.u64[laneId] = 1'1U",
  VOP3Op.V_CMPX_F_U64: "EXEC.u64[laneId] = 1'0U",
  VOP3Op.V_CMPX_LT_U64: 'EXEC.u64[laneId] = S0.u64 < S1.u64',
  VOP3Op.V_CMPX_EQ_U64: 'EXEC.u64[laneId] = S0.u64 == S1.u64',
  VOP3Op.V_CMPX_LE_U64: 'EXEC.u64[laneId] = S0.u64 <= S1.u64',
  VOP3Op.V_CMPX_GT_U64: 'EXEC.u64[laneId] = S0.u64 > S1.u64',
  VOP3Op.V_CMPX_NE_U64: 'EXEC.u64[laneId] = S0.u64 <> S1.u64',
  VOP3Op.V_CMPX_GE_U64: 'EXEC.u64[laneId] = S0.u64 >= S1.u64',
  VOP3Op.V_CMPX_T_U64: "EXEC.u64[laneId] = 1'1U",
  VOP3Op.V_CMPX_CLASS_F16: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f16)) then\nÊ   result = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f16)) then\nÊ   result = S1.u32[1]\nelsif exponent(S0.f16) == 31 then\nÊ   // +-INF\nÊ   result = S1.u32[sign(S0.f16) ? 2 : 9]\nelsif exponent(S0.f16) > 0 then\nÊ   // +-normal value\nÊ   result = S1.u32[sign(S0.f16) ? 3 : 8]\nelsif 64'F(abs(S0.f16)) > 0.0 then\nÊ   // +-denormal value\nÊ   result = S1.u32[sign(S0.f16) ? 4 : 7]\nelse\nÊ   // +-0.0\nÊ   result = S1.u32[sign(S0.f16) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOP3Op.V_CMPX_CLASS_F32: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f32)) then\nÊ   result = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f32)) then\nÊ   result = S1.u32[1]\nelsif exponent(S0.f32) == 255 then\nÊ   // +-INF\nÊ   result = S1.u32[sign(S0.f32) ? 2 : 9]\nelsif exponent(S0.f32) > 0 then\nÊ   // +-normal value\nÊ   result = S1.u32[sign(S0.f32) ? 3 : 8]\nelsif 64'F(abs(S0.f32)) > 0.0 then\nÊ   // +-denormal value\nÊ   result = S1.u32[sign(S0.f32) ? 4 : 7]\nelse\nÊ   // +-0.0\nÊ   result = S1.u32[sign(S0.f32) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOP3Op.V_CMPX_CLASS_F64: "declare result : 1'U;\nif isSignalNAN(S0.f64) then\nÊ   result = S1.u32[0]\nelsif isQuietNAN(S0.f64) then\nÊ   result = S1.u32[1]\nelsif exponent(S0.f64) == 2047 then\nÊ   // +-INF\nÊ   result = S1.u32[sign(S0.f64) ? 2 : 9]\nelsif exponent(S0.f64) > 0 then\nÊ   // +-normal value\nÊ   result = S1.u32[sign(S0.f64) ? 3 : 8]\nelsif abs(S0.f64) > 0.0 then\nÊ   // +-denormal value\nÊ   result = S1.u32[sign(S0.f64) ? 4 : 7]\nelse\nÊ   // +-0.0\nÊ   result = S1.u32[sign(S0.f64) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOP3Op.V_CNDMASK_B32: 'D0.u32 = VCC.u64[laneId] ? S1.u32 : S0.u32',
  VOP3Op.V_ADD_F32: 'D0.f32 = S0.f32 + S1.f32',
  VOP3Op.V_SUB_F32: 'D0.f32 = S0.f32 - S1.f32',
  VOP3Op.V_SUBREV_F32: 'D0.f32 = S1.f32 - S0.f32',
  VOP3Op.V_FMAC_DX9_ZERO_F32: "if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\nÊ   // DX9 rules, 0.0 * x = 0.0\nÊ   D0.f32 = S2.f32\nelse\nÊ   D0.f32 = fma(S0.f32, S1.f32, D0.f32)\nendif",
  VOP3Op.V_MUL_DX9_ZERO_F32: "if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\nÊ   // DX9 rules, 0.0 * x = 0.0\nÊ   D0.f32 = 0.0F\nelse\nÊ   D0.f32 = S0.f32 * S1.f32\nendif",
  VOP3Op.V_MUL_F32: 'D0.f32 = S0.f32 * S1.f32',
  VOP3Op.V_MUL_I32_I24: "D0.i32 = 32'I(S0.i24) * 32'I(S1.i24)",
  VOP3Op.V_MUL_HI_I32_I24: "D0.i32 = 32'I((64'I(S0.i24) * 64'I(S1.i24)) >> 32U)",
  VOP3Op.V_MUL_U32_U24: "D0.u32 = 32'U(S0.u24) * 32'U(S1.u24)",
  VOP3Op.V_MUL_HI_U32_U24: "D0.u32 = 32'U((64'U(S0.u24) * 64'U(S1.u24)) >> 32U)",
  VOP3Op.V_MIN_F32: "LT_NEG_ZERO = lambda(a, b) (\nÊ   ((a < b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nÊ   elsif isSignalNAN(64'F(S1.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nÊ   elsif isQuietNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isQuietNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif LT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif LT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.",
  VOP3Op.V_MAX_F32: "GT_NEG_ZERO = lambda(a, b) (\nÊ   ((a > b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nÊ   elsif isSignalNAN(64'F(S1.f32)) then\nÊ       D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nÊ   elsif isQuietNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isQuietNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif GT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f32)) then\nÊ       D0.f32 = S0.f32\nÊ   elsif isNAN(64'F(S0.f32)) then\nÊ       D0.f32 = S1.f32\nÊ   elsif GT_NEG_ZERO(S0.f32, S1.f32) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f32 = S0.f32\nÊ   else\nÊ       D0.f32 = S1.f32\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.",
  VOP3Op.V_MIN_I32: 'D0.i32 = S0.i32 < S1.i32 ? S0.i32 : S1.i32',
  VOP3Op.V_MAX_I32: 'D0.i32 = S0.i32 >= S1.i32 ? S0.i32 : S1.i32',
  VOP3Op.V_MIN_U32: 'D0.u32 = S0.u32 < S1.u32 ? S0.u32 : S1.u32',
  VOP3Op.V_MAX_U32: 'D0.u32 = S0.u32 >= S1.u32 ? S0.u32 : S1.u32',
  VOP3Op.V_LSHLREV_B32: 'D0.u32 = (S1.u32 << S0[4 : 0].u32)',
  VOP3Op.V_LSHRREV_B32: 'D0.u32 = (S1.u32 >> S0[4 : 0].u32)',
  VOP3Op.V_ASHRREV_I32: 'D0.i32 = (S1.i32 >> S0[4 : 0].u32)',
  VOP3Op.V_AND_B32: 'D0.u32 = (S0.u32 & S1.u32)',
  VOP3Op.V_OR_B32: 'D0.u32 = (S0.u32 | S1.u32)',
  VOP3Op.V_XOR_B32: 'D0.u32 = (S0.u32 ^ S1.u32)',
  VOP3Op.V_XNOR_B32: 'D0.u32 = ~(S0.u32 ^ S1.u32)',
  VOP3Op.V_ADD_NC_U32: 'D0.u32 = S0.u32 + S1.u32',
  VOP3Op.V_SUB_NC_U32: 'D0.u32 = S0.u32 - S1.u32',
  VOP3Op.V_SUBREV_NC_U32: 'D0.u32 = S1.u32 - S0.u32',
  VOP3Op.V_FMAC_F32: 'D0.f32 = fma(S0.f32, S1.f32, D0.f32)',
  VOP3Op.V_CVT_PK_RTZ_F16_F32: 'prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_TOWARD_ZERO;\ntmp[15 : 0].f16 = f32_to_f16(S0.f32);\ntmp[31 : 16].f16 = f32_to_f16(S1.f32);\nD0 = tmp.b32;\nROUND_MODE = prev_mode;\n// Round-toward-zero regardless of current round mode setting in hardware.',
  VOP3Op.V_ADD_F16: 'D0.f16 = S0.f16 + S1.f16',
  VOP3Op.V_SUB_F16: 'D0.f16 = S0.f16 - S1.f16',
  VOP3Op.V_SUBREV_F16: 'D0.f16 = S1.f16 - S0.f16',
  VOP3Op.V_MUL_F16: 'D0.f16 = S0.f16 * S1.f16',
  VOP3Op.V_FMAC_F16: 'D0.f16 = fma(S0.f16, S1.f16, D0.f16)',
  VOP3Op.V_MAX_F16: "GT_NEG_ZERO = lambda(a, b) (\nÊ   ((a > b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nÊ   elsif isSignalNAN(64'F(S1.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nÊ   elsif isQuietNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isQuietNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif GT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif GT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.",
  VOP3Op.V_MIN_F16: "LT_NEG_ZERO = lambda(a, b) (\nÊ   ((a < b) || ((64'F(abs(a)) == 0.0) && (64'F(abs(b)) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(64'F(S0.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nÊ   elsif isSignalNAN(64'F(S1.f16)) then\nÊ       D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nÊ   elsif isQuietNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isQuietNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif LT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nelse\nÊ   if isNAN(64'F(S1.f16)) then\nÊ       D0.f16 = S0.f16\nÊ   elsif isNAN(64'F(S0.f16)) then\nÊ       D0.f16 = S1.f16\nÊ   elsif LT_NEG_ZERO(S0.f16, S1.f16) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f16 = S0.f16\nÊ   else\nÊ       D0.f16 = S1.f16\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.",
  VOP3Op.V_LDEXP_F16: "D0.f16 = S0.f16 * 16'F(2.0F ** 32'I(S1.i16))\nldexp()",
  VOP3Op.V_MOV_B32: 'D0.b32 = S0.b32\nÊ   v_mov_b32 v0, v1    // Move into v0 from v1\nÊ   v_mov_b32 v0, -v1   // Set v0 to the negation of v1\nÊ   v_mov_b32 v0, abs(v1)   // Set v0 to the absolute value of v1',
  VOP3Op.V_READFIRSTLANE_B32: "declare lane : 32'U;\nif WAVE64 then\nÊ   // 64 lanes\nÊ   if EXEC == 0x0LL then\nÊ       lane = 0U;\nÊ       // Force lane 0 if all lanes are disabled\nÊ   else\nÊ       lane = 32'U(s_ff1_i32_b64(EXEC));\nÊ       // Lowest active lane\nÊ   endif\nelse\nÊ   // 32 lanes\nÊ   if EXEC_LO.i32 == 0 then\nÊ       lane = 0U;\nÊ       // Force lane 0 if all lanes are disabled\nÊ   else\nÊ       lane = 32'U(s_ff1_i32_b32(EXEC_LO));\nÊ       // Lowest active lane\nÊ   endif\nendif;\nD0.b32 = VGPR[lane][SRC0.u32]",
  VOP3Op.V_CVT_I32_F64: 'D0.i32 = f64_to_i32(S0.f64)',
  VOP3Op.V_CVT_F64_I32: 'D0.f64 = i32_to_f64(S0.i32)',
  VOP3Op.V_CVT_F32_I32: 'D0.f32 = i32_to_f32(S0.i32)',
  VOP3Op.V_CVT_F32_U32: 'D0.f32 = u32_to_f32(S0.u32)',
  VOP3Op.V_CVT_U32_F32: 'D0.u32 = f32_to_u32(S0.f32)',
  VOP3Op.V_CVT_I32_F32: 'D0.i32 = f32_to_i32(S0.f32)',
  VOP3Op.V_CVT_F16_F32: 'D0.f16 = f32_to_f16(S0.f32)',
  VOP3Op.V_CVT_F32_F16: 'D0.f32 = f16_to_f32(S0.f16)',
  VOP3Op.V_CVT_NEAREST_I32_F32: 'D0.i32 = f32_to_i32(floor(S0.f32 + 0.5F))',
  VOP3Op.V_CVT_FLOOR_I32_F32: 'D0.i32 = f32_to_i32(floor(S0.f32))',
  VOP3Op.V_CVT_OFF_F32_I4: "declare CVT_OFF_TABLE : 32'F[16];\nD0.f32 = CVT_OFF_TABLE[S0.u32[3 : 0]]",
  VOP3Op.V_CVT_F32_F64: 'D0.f32 = f64_to_f32(S0.f64)',
  VOP3Op.V_CVT_F64_F32: 'D0.f64 = f32_to_f64(S0.f32)',
  VOP3Op.V_CVT_F32_UBYTE0: 'D0.f32 = u32_to_f32(S0[7 : 0].u32)',
  VOP3Op.V_CVT_F32_UBYTE1: 'D0.f32 = u32_to_f32(S0[15 : 8].u32)',
  VOP3Op.V_CVT_F32_UBYTE2: 'D0.f32 = u32_to_f32(S0[23 : 16].u32)',
  VOP3Op.V_CVT_F32_UBYTE3: 'D0.f32 = u32_to_f32(S0[31 : 24].u32)',
  VOP3Op.V_CVT_U32_F64: 'D0.u32 = f64_to_u32(S0.f64)',
  VOP3Op.V_CVT_F64_U32: 'D0.f64 = u32_to_f64(S0.u32)',
  VOP3Op.V_TRUNC_F64: 'D0.f64 = trunc(S0.f64)',
  VOP3Op.V_CEIL_F64: 'D0.f64 = trunc(S0.f64);\nif ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then\nÊ   D0.f64 += 1.0\nendif',
  VOP3Op.V_RNDNE_F64: 'D0.f64 = floor(S0.f64 + 0.5);\nif (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then\nÊ   D0.f64 -= 1.0\nendif',
  VOP3Op.V_FLOOR_F64: 'D0.f64 = trunc(S0.f64);\nif ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then\nÊ   D0.f64 += -1.0\nendif',
  VOP3Op.V_MOV_B16: 'D0.b16 = S0.b16',
  VOP3Op.V_FRACT_F32: 'D0.f32 = S0.f32 + -floor(S0.f32)',
  VOP3Op.V_TRUNC_F32: 'D0.f32 = trunc(S0.f32)',
  VOP3Op.V_CEIL_F32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then\nÊ   D0.f32 += 1.0F\nendif',
  VOP3Op.V_RNDNE_F32: "D0.f32 = floor(S0.f32 + 0.5F);\nif (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then\nÊ   D0.f32 -= 1.0F\nendif",
  VOP3Op.V_FLOOR_F32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then\nÊ   D0.f32 += -1.0F\nendif',
  VOP3Op.V_EXP_F32: 'V_EXP_F32(0xff800000) => 0x00000000     // exp(-INF) = 0\nV_EXP_F32(0x80000000) => 0x3f800000     // exp(-0.0) = 1\nV_EXP_F32(0x7f800000) => 0x7f800000     // exp(+INF) = +INF\nD0.f32 = pow(2.0F, S0.f32)',
  VOP3Op.V_LOG_F32: 'D0.f32 = log2(S0.f32)\nV_LOG_F32(0xff800000) => 0xffc00000     // log(-INF) = NAN\nV_LOG_F32(0xbf800000) => 0xffc00000     // log(-1.0) = NAN\nV_LOG_F32(0x80000000) => 0xff800000     // log(-0.0) = -INF\nV_LOG_F32(0x00000000) => 0xff800000     // log(+0.0) = -INF\nV_LOG_F32(0x3f800000) => 0x00000000     // log(+1.0) = 0\nV_LOG_F32(0x7f800000) => 0x7f800000     // log(+INF) = +INF',
  VOP3Op.V_RCP_F32: 'D0.f32 = 1.0F / S0.f32\nV_RCP_F32(0xff800000) => 0x80000000     // rcp(-INF) = -0\nV_RCP_F32(0xc0000000) => 0xbf000000     // rcp(-2.0) = -0.5\nV_RCP_F32(0x80000000) => 0xff800000     // rcp(-0.0) = -INF\nV_RCP_F32(0x00000000) => 0x7f800000     // rcp(+0.0) = +INF\nV_RCP_F32(0x7f800000) => 0x00000000     // rcp(+INF) = +0',
  VOP3Op.V_RCP_IFLAG_F32: 'D0.f32 = 1.0F / S0.f32;\n// Can only raise integer DIV_BY_ZERO exception',
  VOP3Op.V_RSQ_F32: 'D0.f32 = 1.0F / sqrt(S0.f32)\nV_RSQ_F32(0xff800000) => 0xffc00000     // rsq(-INF) = NAN\nV_RSQ_F32(0x80000000) => 0xff800000     // rsq(-0.0) = -INF\nV_RSQ_F32(0x00000000) => 0x7f800000     // rsq(+0.0) = +INF\nV_RSQ_F32(0x40800000) => 0x3f000000     // rsq(+4.0) = +0.5\nV_RSQ_F32(0x7f800000) => 0x00000000     // rsq(+INF) = +0',
  VOP3Op.V_RCP_F64: 'D0.f64 = 1.0 / S0.f64',
  VOP3Op.V_RSQ_F64: 'D0.f64 = 1.0 / sqrt(S0.f64)',
  VOP3Op.V_SQRT_F32: 'D0.f32 = sqrt(S0.f32)\nV_SQRT_F32(0xff800000) => 0xffc00000     // sqrt(-INF) = NAN\nV_SQRT_F32(0x80000000) => 0x80000000     // sqrt(-0.0) = -0\nV_SQRT_F32(0x00000000) => 0x00000000     // sqrt(+0.0) = +0\nV_SQRT_F32(0x40800000) => 0x40000000     // sqrt(+4.0) = +2.0\nV_SQRT_F32(0x7f800000) => 0x7f800000     // sqrt(+INF) = +INF',
  VOP3Op.V_SQRT_F64: 'D0.f64 = sqrt(S0.f64)',
  VOP3Op.V_SIN_F32: "D0.f32 = sin(S0.f32 * 32'F(PI * 2.0))\nV_SIN_F32(0xff800000) => 0xffc00000     // sin(-INF) = NAN\nV_SIN_F32(0xff7fffff) => 0x00000000     // -MaxFloat, finite\nV_SIN_F32(0x80000000) => 0x80000000     // sin(-0.0) = -0\nV_SIN_F32(0x3e800000) => 0x3f800000     // sin(0.25) = 1\nV_SIN_F32(0x7f800000) => 0xffc00000     // sin(+INF) = NAN",
  VOP3Op.V_COS_F32: "V_COS_F32(0xff800000) => 0xffc00000     // cos(-INF) = NAN\nV_COS_F32(0xff7fffff) => 0x3f800000     // -MaxFloat, finite\nV_COS_F32(0x80000000) => 0x3f800000     // cos(-0.0) = 1\nV_COS_F32(0x3e800000) => 0x00000000     // cos(0.25) = 0\nV_COS_F32(0x7f800000) => 0xffc00000     // cos(+INF) = NAN\nD0.f32 = cos(S0.f32 * 32'F(PI * 2.0))",
  VOP3Op.V_NOT_B32: 'D0.u32 = ~S0.u32',
  VOP3Op.V_BFREV_B32: 'D0.u32[31 : 0] = S0.u32[0 : 31]',
  VOP3Op.V_CLZ_I32_U32: "V_CLZ_I32_U32(0x00000000) => 0xffffffff\nV_CLZ_I32_U32(0x800000ff) => 0\nV_CLZ_I32_U32(0x100000ff) => 3\nV_CLZ_I32_U32(0x0000ffff) => 16\nV_CLZ_I32_U32(0x00000001) => 31\nD0.i32 = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\nÊ   // Search from MSB\nÊ   if S0.u32[31 - i] == 1'1U then\nÊ       D0.i32 = i;\nÊ       break\nÊ   endif\nendfor",
  VOP3Op.V_CTZ_I32_B32: "D0.i32 = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\nÊ   // Search from LSB\nÊ   if S0.u32[i] == 1'1U then\nÊ       D0.i32 = i;\nÊ       break\nÊ   endif\nendfor\nV_CTZ_I32_B32(0x00000000) => 0xffffffff\nV_CTZ_I32_B32(0xff000001) => 0\nV_CTZ_I32_B32(0xff000008) => 3\nV_CTZ_I32_B32(0xffff0000) => 16\nV_CTZ_I32_B32(0x80000000) => 31",
  VOP3Op.V_CLS_I32: 'Ê   if S0.i32[31 - i] != S0.i32[31] then\nÊ       D0.i32 = i;\nÊ       break\nÊ   endif\nendfor\nV_CLS_I32(0x00000000) => 0xffffffff\nV_CLS_I32(0x40000000) => 1\nV_CLS_I32(0x80000000) => 1\nV_CLS_I32(0x0fffffff) => 4\nV_CLS_I32(0xffff0000) => 16\nV_CLS_I32(0xfffffffe) => 31\nV_CLS_I32(0xffffffff) => 0xffffffff\nD0.i32 = -1;\n// Set if all bits are the same\nfor i in 1 : 31 do\nÊ   // Search from MSB',
  VOP3Op.V_FREXP_EXP_I32_F64: 'if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nÊ   D0.i32 = 0\nelse\nÊ   D0.i32 = exponent(S0.f64) - 1023 + 1\nendif\nfrexp()',
  VOP3Op.V_FREXP_MANT_F64: 'endif\nfrexp()\nif ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nÊ   D0.f64 = S0.f64\nelse\nÊ   D0.f64 = mantissa(S0.f64)',
  VOP3Op.V_FRACT_F64: 'D0.f64 = S0.f64 + -floor(S0.f64)',
  VOP3Op.V_FREXP_EXP_I32_F32: "if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then\nÊ   D0.i32 = 0\nelse\nÊ   D0.i32 = exponent(S0.f32) - 127 + 1\nendif\nfrexp()",
  VOP3Op.V_FREXP_MANT_F32: "if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then\nÊ   D0.f32 = S0.f32\nelse\nÊ   D0.f32 = mantissa(S0.f32)\nendif\nfrexp()",
  VOP3Op.V_MOVRELD_B32: 'addr = DST.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nVGPR[laneId][addr].b32 = S0.b32\nÊ   s_mov_b32 m0, 10\nÊ   v_movreld_b32 v5, v7',
  VOP3Op.V_MOVRELS_B32: 'Ê   s_mov_b32 m0, 10\nÊ   v_movrels_b32 v5, v7\naddr = SRC0.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nD0.b32 = VGPR[laneId][addr].b32',
  VOP3Op.V_MOVRELSD_B32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[31 : 0];\naddrd += M0.u32[31 : 0];\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32\nÊ   s_mov_b32 m0, 10\nÊ   v_movrelsd_b32 v5, v7',
  VOP3Op.V_MOVRELSD_2_B32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[9 : 0].u32;\naddrd += M0.u32[25 : 16].u32;\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32\nÊ   s_mov_b32 m0, ((20 << 16) | 10)\nÊ   v_movrelsd_2_b32 v5, v7',
  VOP3Op.V_CVT_F16_U16: 'D0.f16 = u16_to_f16(S0.u16)',
  VOP3Op.V_CVT_F16_I16: 'D0.f16 = i16_to_f16(S0.i16)',
  VOP3Op.V_CVT_U16_F16: 'D0.u16 = f16_to_u16(S0.f16)',
  VOP3Op.V_CVT_I16_F16: 'D0.i16 = f16_to_i16(S0.f16)',
  VOP3Op.V_RCP_F16: "D0.f16 = 16'1.0 / S0.f16\nV_RCP_F16(0xfc00) => 0x8000     // rcp(-INF) = -0\nV_RCP_F16(0xc000) => 0xb800     // rcp(-2.0) = -0.5\nV_RCP_F16(0x8000) => 0xfc00     // rcp(-0.0) = -INF\nV_RCP_F16(0x0000) => 0x7c00     // rcp(+0.0) = +INF\nV_RCP_F16(0x7c00) => 0x0000     // rcp(+INF) = +0",
  VOP3Op.V_SQRT_F16: 'V_SQRT_F16(0x8000) => 0x8000     // sqrt(-0.0) = -0\nV_SQRT_F16(0x0000) => 0x0000     // sqrt(+0.0) = +0\nV_SQRT_F16(0x4400) => 0x4000     // sqrt(+4.0) = +2.0\nV_SQRT_F16(0x7c00) => 0x7c00     // sqrt(+INF) = +INF\nD0.f16 = sqrt(S0.f16)\nV_SQRT_F16(0xfc00) => 0xfe00     // sqrt(-INF) = NAN',
  VOP3Op.V_RSQ_F16: "D0.f16 = 16'1.0 / sqrt(S0.f16)\nV_RSQ_F16(0xfc00) => 0xfe00     // rsq(-INF) = NAN\nV_RSQ_F16(0x8000) => 0xfc00     // rsq(-0.0) = -INF\nV_RSQ_F16(0x0000) => 0x7c00     // rsq(+0.0) = +INF\nV_RSQ_F16(0x4400) => 0x3800     // rsq(+4.0) = +0.5\nV_RSQ_F16(0x7c00) => 0x0000     // rsq(+INF) = +0",
  VOP3Op.V_LOG_F16: 'D0.f16 = log2(S0.f16)\nV_LOG_F16(0xfc00) => 0xfe00     // log(-INF) = NAN\nV_LOG_F16(0xbc00) => 0xfe00     // log(-1.0) = NAN\nV_LOG_F16(0x8000) => 0xfc00     // log(-0.0) = -INF\nV_LOG_F16(0x0000) => 0xfc00     // log(+0.0) = -INF\nV_LOG_F16(0x3c00) => 0x0000     // log(+1.0) = 0\nV_LOG_F16(0x7c00) => 0x7c00     // log(+INF) = +INF',
  VOP3Op.V_EXP_F16: "D0.f16 = pow(16'2.0, S0.f16)\nV_EXP_F16(0xfc00) => 0x0000     // exp(-INF) = 0\nV_EXP_F16(0x8000) => 0x3c00     // exp(-0.0) = 1\nV_EXP_F16(0x7c00) => 0x7c00     // exp(+INF) = +INF",
  VOP3Op.V_FREXP_MANT_F16: "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nÊ   D0.f16 = S0.f16\nelse\nÊ   D0.f16 = mantissa(S0.f16)\nendif\nfrexp()",
  VOP3Op.V_FREXP_EXP_I16_F16: "frexp()\nif ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nÊ   D0.i16 = 16'0\nelse\nÊ   D0.i16 = 16'I(exponent(S0.f16) - 15 + 1)\nendif",
  VOP3Op.V_FLOOR_F16: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then\nÊ   D0.f16 += -16'1.0\nendif",
  VOP3Op.V_CEIL_F16: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then\nÊ   D0.f16 += 16'1.0\nendif",
  VOP3Op.V_TRUNC_F16: 'D0.f16 = trunc(S0.f16)',
  VOP3Op.V_RNDNE_F16: "endif\nD0.f16 = floor(S0.f16 + 16'0.5);\nif (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then\nÊ   D0.f16 -= 16'1.0",
  VOP3Op.V_FRACT_F16: 'D0.f16 = S0.f16 + -floor(S0.f16)',
  VOP3Op.V_SIN_F16: "D0.f16 = sin(S0.f16 * 16'F(PI * 2.0))\nV_SIN_F16(0xfc00) => 0xfe00     // sin(-INF) = NAN\nV_SIN_F16(0xfbff) => 0x0000     // Most negative finite FP16\nV_SIN_F16(0x8000) => 0x8000     // sin(-0.0) = -0\nV_SIN_F16(0x3400) => 0x3c00     // sin(0.25) = 1\nV_SIN_F16(0x7bff) => 0x0000     // Most positive finite FP16\nV_SIN_F16(0x7c00) => 0xfe00     // sin(+INF) = NAN",
  VOP3Op.V_COS_F16: "D0.f16 = cos(S0.f16 * 16'F(PI * 2.0))\nV_COS_F16(0xfc00) => 0xfe00     // cos(-INF) = NAN\nV_COS_F16(0xfbff) => 0x3c00     // Most negative finite FP16\nV_COS_F16(0x8000) => 0x3c00     // cos(-0.0) = 1\nV_COS_F16(0x3400) => 0x0000     // cos(0.25) = 0\nV_COS_F16(0x7bff) => 0x3c00     // Most positive finite FP16\nV_COS_F16(0x7c00) => 0xfe00     // cos(+INF) = NAN",
  VOP3Op.V_SAT_PK_U8_I16: "SAT8 = lambda(n) (\nÊ   if n.i32 <= 0 then\nÊ       return 8'0U\nÊ   elsif n >= 16'I(0xff) then\nÊ       return 8'255U\nÊ   else\nÊ       return n[7 : 0].u8\nÊ   endif);\nD0.b16 = { SAT8(S0[31 : 16].i16), SAT8(S0[15 : 0].i16) }",
  VOP3Op.V_CVT_NORM_I16_F16: 'D0.i16 = f16_to_snorm(S0.f16)',
  VOP3Op.V_CVT_NORM_U16_F16: 'D0.u16 = f16_to_unorm(S0.f16)',
  VOP3Op.V_NOT_B16: 'D0.u16 = ~S0.u16',
  VOP3Op.V_CVT_I32_I16: "D0.i32 = 32'I(signext(S0.i16))",
  VOP3Op.V_CVT_U32_U16: "D0 = { 16'0, S0.u16 }",
  VOP3Op.V_FMA_DX9_ZERO_F32: "if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\nÊ   // DX9 rules, 0.0 * x = 0.0\nÊ   D0.f32 = S2.f32\nelse\nÊ   D0.f32 = fma(S0.f32, S1.f32, S2.f32)\nendif",
  VOP3Op.V_MAD_I32_I24: "D0.i32 = 32'I(S0.i24) * 32'I(S1.i24) + S2.i32",
  VOP3Op.V_MAD_U32_U24: "D0.u32 = 32'U(S0.u24) * 32'U(S1.u24) + S2.u32",
  VOP3Op.V_CUBEID_F32: '// Set D0.f = cubemap face ID ({0.0, 1.0, ..., 5.0}).\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then\nÊ   if S2.f32 < 0.0F then\nÊ       D0.f32 = 5.0F\nÊ   else\nÊ       D0.f32 = 4.0F\nÊ   endif\nelsif abs(S1.f32) >= abs(S0.f32) then\nÊ   if S1.f32 < 0.0F then\nÊ       D0.f32 = 3.0F\nÊ   else\nÊ       D0.f32 = 2.0F\nÊ   endif\nelse\nÊ   if S0.f32 < 0.0F then\nÊ       D0.f32 = 1.0F\nÊ   else\nÊ       D0.f32 = 0.0F\nÊ   endif\nendif',
  VOP3Op.V_CUBESC_F32: 'Ê   else\nÊ       D0.f32 = -S2.f32\nÊ   endif\nendif\n// D0.f = cubemap S coordinate.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then\nÊ   if S2.f32 < 0.0F then\nÊ       D0.f32 = -S0.f32\nÊ   else\nÊ       D0.f32 = S0.f32\nÊ   endif\nelsif abs(S1.f32) >= abs(S0.f32) then\nÊ   D0.f32 = S0.f32\nelse\nÊ   if S0.f32 < 0.0F then\nÊ       D0.f32 = S2.f32',
  VOP3Op.V_CUBETC_F32: '// D0.f = cubemap T coordinate.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then\nÊ   D0.f32 = -S1.f32\nelsif abs(S1.f32) >= abs(S0.f32) then\nÊ   if S1.f32 < 0.0F then\nÊ       D0.f32 = -S2.f32\nÊ   else\nÊ       D0.f32 = S2.f32\nÊ   endif\nelse\nÊ   D0.f32 = -S1.f32\nendif',
  VOP3Op.V_CUBEMA_F32: '// D0.f = 2.0 * cubemap major axis.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then\nÊ   D0.f32 = S2.f32 * 2.0F\nelsif abs(S1.f32) >= abs(S0.f32) then\nÊ   D0.f32 = S1.f32 * 2.0F\nelse\nÊ   D0.f32 = S0.f32 * 2.0F\nendif',
  VOP3Op.V_BFE_U32: 'D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1U << S2[4 : 0].u32) - 1U))',
  VOP3Op.V_BFE_I32: 'tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S2[4 : 0].u32) - 1));\nD0.i32 = signext_from_bit(tmp.i32, S2[4 : 0].u32)',
  VOP3Op.V_BFI_B32: 'D0.u32 = ((S0.u32 & S1.u32) | (~S0.u32 & S2.u32))',
  VOP3Op.V_FMA_F32: 'D0.f32 = fma(S0.f32, S1.f32, S2.f32)',
  VOP3Op.V_FMA_F64: 'D0.f64 = fma(S0.f64, S1.f64, S2.f64)',
  VOP3Op.V_LERP_U8: 'tmp = ((S0.u32[31 : 24] + S1.u32[31 : 24] + S2.u32[24].u8) >> 1U << 24U);\ntmp += ((S0.u32[23 : 16] + S1.u32[23 : 16] + S2.u32[16].u8) >> 1U << 16U);\ntmp += ((S0.u32[15 : 8] + S1.u32[15 : 8] + S2.u32[8].u8) >> 1U << 8U);\ntmp += ((S0.u32[7 : 0] + S1.u32[7 : 0] + S2.u32[0].u8) >> 1U);\nD0.u32 = tmp.u32',
  VOP3Op.V_ALIGNBIT_B32: "D0.u32 = 32'U(({ S0.u32, S1.u32 } >> S2.u32[4 : 0].u32) & 0xffffffffLL)",
  VOP3Op.V_ALIGNBYTE_B32: "D0.u32 = 32'U(({ S0.u32, S1.u32 } >> (S2.u32[1 : 0].u32 * 8U)) & 0xffffffffLL)",
  VOP3Op.V_MULLIT_F32: "if ((S1.f32 == -MAX_FLOAT_F32) || (64'F(S1.f32) == -INF) || isNAN(64'F(S1.f32)) || (S2.f32 <= 0.0F) ||\nisNAN(64'F(S2.f32))) then\nÊ   D0.f32 = -MAX_FLOAT_F32\nelse\nÊ   D0.f32 = S0.f32 * S1.f32\nendif",
  VOP3Op.V_MIN3_F32: 'D0.f32 = v_min_f32(v_min_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MIN3_I32: 'D0.i32 = v_min_i32(v_min_i32(S0.i32, S1.i32), S2.i32)',
  VOP3Op.V_MIN3_U32: 'D0.u32 = v_min_u32(v_min_u32(S0.u32, S1.u32), S2.u32)',
  VOP3Op.V_MAX3_F32: 'D0.f32 = v_max_f32(v_max_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MAX3_I32: 'D0.i32 = v_max_i32(v_max_i32(S0.i32, S1.i32), S2.i32)',
  VOP3Op.V_MAX3_U32: 'D0.u32 = v_max_u32(v_max_u32(S0.u32, S1.u32), S2.u32)',
  VOP3Op.V_MED3_F32: "if (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)) || isNAN(64'F(S2.f32))) then\nÊ   D0.f32 = v_min3_f32(S0.f32, S1.f32, S2.f32)\nelsif v_max3_f32(S0.f32, S1.f32, S2.f32) == S0.f32 then\nÊ   D0.f32 = v_max_f32(S1.f32, S2.f32)\nelsif v_max3_f32(S0.f32, S1.f32, S2.f32) == S1.f32 then\nÊ   D0.f32 = v_max_f32(S0.f32, S2.f32)\nelse\nÊ   D0.f32 = v_max_f32(S0.f32, S1.f32)\nendif",
  VOP3Op.V_MED3_I32: 'if v_max3_i32(S0.i32, S1.i32, S2.i32) == S0.i32 then\nÊ   D0.i32 = v_max_i32(S1.i32, S2.i32)\nelsif v_max3_i32(S0.i32, S1.i32, S2.i32) == S1.i32 then\nÊ   D0.i32 = v_max_i32(S0.i32, S2.i32)\nelse\nÊ   D0.i32 = v_max_i32(S0.i32, S1.i32)\nendif',
  VOP3Op.V_MED3_U32: 'if v_max3_u32(S0.u32, S1.u32, S2.u32) == S0.u32 then\nÊ   D0.u32 = v_max_u32(S1.u32, S2.u32)\nelsif v_max3_u32(S0.u32, S1.u32, S2.u32) == S1.u32 then\nÊ   D0.u32 = v_max_u32(S0.u32, S2.u32)\nelse\nÊ   D0.u32 = v_max_u32(S0.u32, S1.u32)\nendif',
  VOP3Op.V_SAD_U8: "ABSDIFF = lambda(x, y) (\nÊ   x > y ? x - y : y - x);\n// UNSIGNED comparison\ntmp = S2.u32;\ntmp += 32'U(ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]));\ntmp += 32'U(ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]));\ntmp += 32'U(ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]));\ntmp += 32'U(ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]));\nD0.u32 = tmp",
  VOP3Op.V_SAD_HI_U8: "D0.u32 = (32'U(v_sad_u8(S0, S1, 0U)) << 16U) + S2.u32",
  VOP3Op.V_SAD_U16: 'ABSDIFF = lambda(x, y) (\nÊ   x > y ? x - y : y - x);\n// UNSIGNED comparison\ntmp = S2.u32;\ntmp += ABSDIFF(S0[15 : 0].u16, S1[15 : 0].u16);\ntmp += ABSDIFF(S0[31 : 16].u16, S1[31 : 16].u16);\nD0.u32 = tmp',
  VOP3Op.V_SAD_U32: 'ABSDIFF = lambda(x, y) (\nÊ   x > y ? x - y : y - x);\n// UNSIGNED comparison\nD0.u32 = ABSDIFF(S0.u32, S1.u32) + S2.u32',
  VOP3Op.V_CVT_PK_U8_F32: "tmp = (S2.u32 & 32'U(~(0xff << (S1.u32[1 : 0].u32 * 8U))));\ntmp = (tmp | ((32'U(f32_to_u8(S0.f32)) & 255U) << (S1.u32[1 : 0].u32 * 8U)));\nD0.u32 = tmp",
  VOP3Op.V_DIV_FIXUP_F32: "elsif isNAN(64'F(S1.f32)) then\nÊ   D0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nelsif ((64'F(S1.f32) == 0.0) && (64'F(S2.f32) == 0.0)) then\nÊ   // 0/0\nÊ   D0.f32 = 32'F(0xffc00000)\nelsif ((64'F(abs(S1.f32)) == +INF) && (64'F(abs(S2.f32)) == +INF)) then\nÊ   // inf/inf\nÊ   D0.f32 = 32'F(0xffc00000)\nelsif ((64'F(S1.f32) == 0.0) || (64'F(abs(S2.f32)) == +INF)) then\nÊ   // x/0, or inf/y\nÊ   D0.f32 = sign_out ? -INF.f32 : +INF.f32\nelsif ((64'F(abs(S1.f32)) == +INF) || (64'F(S2.f32) == 0.0)) then\nÊ   // x/inf, 0/y\nÊ   D0.f32 = sign_out ? -0.0F : 0.0F\nelsif exponent(S2.f32) - exponent(S1.f32) < -150 then\nÊ   D0.f32 = sign_out ? -UNDERFLOW_F32 : UNDERFLOW_F32\nelsif exponent(S1.f32) == 255 then\nÊ   D0.f32 = sign_out ? -OVERFLOW_F32 : OVERFLOW_F32\nelse\nÊ   D0.f32 = sign_out ? -abs(S0.f32) : abs(S0.f32)\nendif\nsign_out = (sign(S1.f32) ^ sign(S2.f32));\nif isNAN(64'F(S2.f32)) then\nÊ   D0.f32 = 32'F(cvtToQuietNAN(64'F(S2.f32)))",
  VOP3Op.V_DIV_FIXUP_F64: "Ê   D0.f64 = sign_out ? -0.0 : 0.0\nelsif exponent(S2.f64) - exponent(S1.f64) < -1075 then\nÊ   D0.f64 = sign_out ? -UNDERFLOW_F64 : UNDERFLOW_F64\nelsif exponent(S1.f64) == 2047 then\nÊ   D0.f64 = sign_out ? -OVERFLOW_F64 : OVERFLOW_F64\nelse\nÊ   D0.f64 = sign_out ? -abs(S0.f64) : abs(S0.f64)\nendif\nsign_out = (sign(S1.f64) ^ sign(S2.f64));\nif isNAN(S2.f64) then\nÊ   D0.f64 = cvtToQuietNAN(S2.f64)\nelsif isNAN(S1.f64) then\nÊ   D0.f64 = cvtToQuietNAN(S1.f64)\nelsif ((S1.f64 == 0.0) && (S2.f64 == 0.0)) then\nÊ   // 0/0\nÊ   D0.f64 = 64'F(0xfff8000000000000LL)\nelsif ((abs(S1.f64) == +INF) && (abs(S2.f64) == +INF)) then\nÊ   // inf/inf\nÊ   D0.f64 = 64'F(0xfff8000000000000LL)\nelsif ((S1.f64 == 0.0) || (abs(S2.f64) == +INF)) then\nÊ   // x/0, or inf/y\nÊ   D0.f64 = sign_out ? -INF : +INF\nelsif ((abs(S1.f64) == +INF) || (S2.f64 == 0.0)) then\nÊ   // x/inf, 0/y",
  VOP3Op.V_DIV_FMAS_F32: 'if VCC.u64[laneId] then\nÊ   D0.f32 = 2.0F ** 32 * fma(S0.f32, S1.f32, S2.f32)\nelse\nÊ   D0.f32 = fma(S0.f32, S1.f32, S2.f32)\nendif',
  VOP3Op.V_DIV_FMAS_F64: 'else\nÊ   D0.f64 = fma(S0.f64, S1.f64, S2.f64)\nendif\nif VCC.u64[laneId] then\nÊ   D0.f64 = 2.0 ** 64 * fma(S0.f64, S1.f64, S2.f64)',
  VOP3Op.V_MSAD_U8: "ABSDIFF = lambda(x, y) (\nÊ   x > y ? x - y : y - x);\n// UNSIGNED comparison\ntmp = S2.u32;\ntmp += S1.u32[7 : 0] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]));\ntmp += S1.u32[15 : 8] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]));\ntmp += S1.u32[23 : 16] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]));\ntmp += S1.u32[31 : 24] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]));\nD0.u32 = tmp",
  VOP3Op.V_QSAD_PK_U16_U8: "D0.b64 = tmp.b64\ntmp[63 : 48] = 16'B(v_sad_u8(S0[55 : 24], S1[31 : 0], S2[63 : 48].u32));\ntmp[47 : 32] = 16'B(v_sad_u8(S0[47 : 16], S1[31 : 0], S2[47 : 32].u32));\ntmp[31 : 16] = 16'B(v_sad_u8(S0[39 : 8], S1[31 : 0], S2[31 : 16].u32));\ntmp[15 : 0] = 16'B(v_sad_u8(S0[31 : 0], S1[31 : 0], S2[15 : 0].u32));",
  VOP3Op.V_MQSAD_PK_U16_U8: "tmp[63 : 48] = 16'B(v_msad_u8(S0[55 : 24], S1[31 : 0], S2[63 : 48].u32));\ntmp[47 : 32] = 16'B(v_msad_u8(S0[47 : 16], S1[31 : 0], S2[47 : 32].u32));\ntmp[31 : 16] = 16'B(v_msad_u8(S0[39 : 8], S1[31 : 0], S2[31 : 16].u32));\ntmp[15 : 0] = 16'B(v_msad_u8(S0[31 : 0], S1[31 : 0], S2[15 : 0].u32));\nD0.b64 = tmp.b64",
  VOP3Op.V_MQSAD_U32_U8: "tmp[127 : 96] = 32'B(v_msad_u8(S0[55 : 24], S1[31 : 0], S2[127 : 96].u32));\ntmp[95 : 64] = 32'B(v_msad_u8(S0[47 : 16], S1[31 : 0], S2[95 : 64].u32));\ntmp[63 : 32] = 32'B(v_msad_u8(S0[39 : 8], S1[31 : 0], S2[63 : 32].u32));\ntmp[31 : 0] = 32'B(v_msad_u8(S0[31 : 0], S1[31 : 0], S2[31 : 0].u32));\nD0.b128 = tmp.b128",
  VOP3Op.V_XOR3_B32: 'D0.u32 = (S0.u32 ^ S1.u32 ^ S2.u32)',
  VOP3Op.V_MAD_U16: 'D0.u16 = S0.u16 * S1.u16 + S2.u16',
  VOP3Op.V_PERM_B32: "BYTE_PERMUTE = lambda(data, sel) (\nÊ   declare in : 8'B[8];\nÊ   for i in 0 : 7 do\nÊ       in[i] = data[i * 8 + 7 : i * 8].b8\nÊ   endfor;\nÊ   if sel.u32 >= 13U then\nÊ       return 8'0xff\nÊ   elsif sel.u32 == 12U then\nÊ       return 8'0x0\nÊ   elsif sel.u32 == 11U then\nÊ       return in[7][7].b8 * 8'0xff\nÊ   elsif sel.u32 == 10U then\nÊ       return in[5][7].b8 * 8'0xff\nÊ   elsif sel.u32 == 9U then\nÊ       return in[3][7].b8 * 8'0xff\nÊ   elsif sel.u32 == 8U then\nÊ       return in[1][7].b8 * 8'0xff\nÊ   else\nÊ       return in[sel]\nÊ   endif);\nD0[31 : 24] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[31 : 24]);\nD0[23 : 16] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[23 : 16]);\nD0[15 : 8] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[15 : 8]);\nD0[7 : 0] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[7 : 0])",
  VOP3Op.V_XAD_U32: 'D0.u32 = (S0.u32 ^ S1.u32) + S2.u32',
  VOP3Op.V_LSHL_ADD_U32: 'D0.u32 = (S0.u32 << S1.u32[4 : 0].u32) + S2.u32',
  VOP3Op.V_ADD_LSHL_U32: 'D0.u32 = ((S0.u32 + S1.u32) << S2.u32[4 : 0].u32)',
  VOP3Op.V_FMA_F16: 'D0.f16 = fma(S0.f16, S1.f16, S2.f16)',
  VOP3Op.V_MIN3_F16: 'D0.f16 = v_min_f16(v_min_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MIN3_I16: 'D0.i16 = v_min_i16(v_min_i16(S0.i16, S1.i16), S2.i16)',
  VOP3Op.V_MIN3_U16: 'D0.u16 = v_min_u16(v_min_u16(S0.u16, S1.u16), S2.u16)',
  VOP3Op.V_MAX3_F16: 'D0.f16 = v_max_f16(v_max_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MAX3_I16: 'D0.i16 = v_max_i16(v_max_i16(S0.i16, S1.i16), S2.i16)',
  VOP3Op.V_MAX3_U16: 'D0.u16 = v_max_u16(v_max_u16(S0.u16, S1.u16), S2.u16)',
  VOP3Op.V_MED3_F16: "if (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)) || isNAN(64'F(S2.f16))) then\nÊ   D0.f16 = v_min3_f16(S0.f16, S1.f16, S2.f16)\nelsif v_max3_f16(S0.f16, S1.f16, S2.f16) == S0.f16 then\nÊ   D0.f16 = v_max_f16(S1.f16, S2.f16)\nelsif v_max3_f16(S0.f16, S1.f16, S2.f16) == S1.f16 then\nÊ   D0.f16 = v_max_f16(S0.f16, S2.f16)\nelse\nÊ   D0.f16 = v_max_f16(S0.f16, S1.f16)\nendif",
  VOP3Op.V_MED3_I16: 'if v_max3_i16(S0.i16, S1.i16, S2.i16) == S0.i16 then\nÊ   D0.i16 = v_max_i16(S1.i16, S2.i16)\nelsif v_max3_i16(S0.i16, S1.i16, S2.i16) == S1.i16 then\nÊ   D0.i16 = v_max_i16(S0.i16, S2.i16)\nelse\nÊ   D0.i16 = v_max_i16(S0.i16, S1.i16)\nendif',
  VOP3Op.V_MED3_U16: 'if v_max3_u16(S0.u16, S1.u16, S2.u16) == S0.u16 then\nÊ   D0.u16 = v_max_u16(S1.u16, S2.u16)\nelsif v_max3_u16(S0.u16, S1.u16, S2.u16) == S1.u16 then\nÊ   D0.u16 = v_max_u16(S0.u16, S2.u16)\nelse\nÊ   D0.u16 = v_max_u16(S0.u16, S1.u16)\nendif',
  VOP3Op.V_MAD_I16: 'D0.i16 = S0.i16 * S1.i16 + S2.i16',
  VOP3Op.V_DIV_FIXUP_F16: "sign_out = (sign(S1.f16) ^ sign(S2.f16));\nif isNAN(64'F(S2.f16)) then\nÊ   D0.f16 = 16'F(cvtToQuietNAN(64'F(S2.f16)))\nelsif isNAN(64'F(S1.f16)) then\nÊ   D0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif ((64'F(S1.f16) == 0.0) && (64'F(S2.f16) == 0.0)) then\nÊ   // 0/0\nÊ   D0.f16 = 16'F(0xfe00)\nelsif ((64'F(abs(S1.f16)) == +INF) && (64'F(abs(S2.f16)) == +INF)) then\nÊ   // inf/inf\nÊ   D0.f16 = 16'F(0xfe00)\nelsif ((64'F(S1.f16) == 0.0) || (64'F(abs(S2.f16)) == +INF)) then\nÊ   // x/0, or inf/y\nÊ   D0.f16 = sign_out ? -INF.f16 : +INF.f16\nelsif ((64'F(abs(S1.f16)) == +INF) || (64'F(S2.f16) == 0.0)) then\nÊ   // x/inf, 0/y\nÊ   D0.f16 = sign_out ? -16'0.0 : 16'0.0\nelse\nÊ   D0.f16 = sign_out ? -abs(S0.f16) : abs(S0.f16)\nendif",
  VOP3Op.V_ADD3_U32: 'D0.u32 = S0.u32 + S1.u32 + S2.u32',
  VOP3Op.V_LSHL_OR_B32: 'D0.u32 = ((S0.u32 << S1.u32[4 : 0].u32) | S2.u32)',
  VOP3Op.V_AND_OR_B32: 'D0.u32 = ((S0.u32 & S1.u32) | S2.u32)',
  VOP3Op.V_OR3_B32: 'D0.u32 = (S0.u32 | S1.u32 | S2.u32)',
  VOP3Op.V_MAD_U32_U16: "D0.u32 = 32'U(S0.u16) * 32'U(S1.u16) + S2.u32",
  VOP3Op.V_MAD_I32_I16: "D0.i32 = 32'I(S0.i16) * 32'I(S1.i16) + S2.i32",
  VOP3Op.V_PERMLANE16_B32: "// ...\n// v1.lane[14] <- v0.lane[15]\n// v1.lane[15] <- v0.lane[0]\n//\n// ROW 1:\n// v1.lane[16] <- v0.lane[17]\n// v1.lane[17] <- v0.lane[18]\n// ...\n// v1.lane[30] <- v0.lane[31]\n// v1.lane[31] <- v0.lane[16]\ndeclare tmp : 32'B[64];\nlanesel = { S2.u32, S1.u32 };\n// Concatenate lane select bits\nfor i in 0 : WAVE32 ? 31 : 63 do\nÊ   // Copy original S0 in case D==S0\nÊ   tmp[i] = VGPR[i][SRC0.u32]\nendfor;\nfor row in 0 : WAVE32 ? 1 : 3 do\nÊ   // Implement arbitrary swizzle within each row\nÊ   for i in 0 : 15 do\nÊ       if EXEC[row * 16 + i].u1 then\nÊ           VGPR[row * 16 + i][VDST.u32] = tmp[64'B(row * 16) + lanesel[i * 4 + 3 : i * 4]]\nÊ       endif\nÊ   endfor\nendfor\nv_mov_b32 s0, 0x87654321;\nv_mov_b32 s1, 0x0fedcba9;\nv_permlane16_b32 v1, v0, s0, s1;\n// ROW 0:\n// v1.lane[0] <- v0.lane[1]\n// v1.lane[1] <- v0.lane[2]",
  VOP3Op.V_PERMLANEX16_B32: "Ê// Enable only the threads that get data from their own row.\nv_mov_b32 exec_lo, 0x7fff7fff; // Lanes getting data from their own row\nv_mov_b32 s0, 0x87654321;\nv_mov_b32 s1, 0x0fedcba9;\nv_permlane16_b32 v1, v0, s0, s1 fi; // FI bit needed for lanes 14 and 30\n// ROW 0:\n// v1.lane[0] <- v0.lane[1]\n// v1.lane[1] <- v0.lane[2]\n// ...\n// v1.lane[14] <- v0.lane[15] (needs FI to read)\n// v1.lane[15] unset\n//\n// ROW 1:\n// v1.lane[16] <- v0.lane[17]\n// v1.lane[17] <- v0.lane[18]\n// ...\n// v1.lane[30] <- v0.lane[31] (needs FI to read)\n// v1.lane[31] unset\n// Enable only the threads that get data from the other row.\nv_mov_b32 exec_lo, 0x80008000; // Lanes getting data from the other row\nv_permlanex16_b32 v1, v0, s0, s1 fi; // FI bit needed for lanes 15 and 31\n// v1.lane[15] <- v0.lane[16]\n// v1.lane[31] <- v0.lane[0]\ndeclare tmp : 32'B[64];\nlanesel = { S2.u32, S1.u32 };\n// Concatenate lane select bits\nfor i in 0 : WAVE32 ? 31 : 63 do\nÊ   // Copy original S0 in case D==S0\nÊ   tmp[i] = VGPR[i][SRC0.u32]\nendfor;\nfor row in 0 : WAVE32 ? 1 : 3 do\nÊ   // Implement arbitrary swizzle across two rows\nÊ   altrow = { row[1], ~row[0] };\nÊ   // 1<->0, 3<->2\nÊ   for i in 0 : 15 do\nÊ       if EXEC[row * 16 + i].u1 then\nÊ           VGPR[row * 16 + i][VDST.u32] = tmp[64'B(altrow.i32 * 16) + lanesel[i * 4 + 3 : i * 4]]\nÊ       endif\nÊ   endfor\nendfor\n// Note for this to work, source and destination VGPRs must be different.\n// For this rotation, lane 15 gets data from lane 16, lane 31 gets data from lane 0.\n// These are the only two lanes that need to use v_permlanex16_b32.",
  VOP3Op.V_CNDMASK_B16: 'D0.u16 = VCC.u64[laneId] ? S1.u16 : S0.u16',
  VOP3Op.V_MAXMIN_F32: 'D0.f32 = v_min_f32(v_max_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MINMAX_F32: 'D0.f32 = v_max_f32(v_min_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MAXMIN_F16: 'D0.f16 = v_min_f16(v_max_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MINMAX_F16: 'D0.f16 = v_max_f16(v_min_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MAXMIN_U32: 'D0.u32 = v_min_u32(v_max_u32(S0.u32, S1.u32), S2.u32)',
  VOP3Op.V_MINMAX_U32: 'D0.u32 = v_max_u32(v_min_u32(S0.u32, S1.u32), S2.u32)',
  VOP3Op.V_MAXMIN_I32: 'D0.i32 = v_min_i32(v_max_i32(S0.i32, S1.i32), S2.i32)',
  VOP3Op.V_MINMAX_I32: 'D0.i32 = v_max_i32(v_min_i32(S0.i32, S1.i32), S2.i32)',
  VOP3Op.V_DOT2_F16_F16: 'tmp = S2.f16;\ntmp += S0[15 : 0].f16 * S1[15 : 0].f16;\ntmp += S0[31 : 16].f16 * S1[31 : 16].f16;\nD0.f16 = tmp',
  VOP3Op.V_DOT2_BF16_BF16: 'tmp = S2.bf16;\ntmp += S0[15 : 0].bf16 * S1[15 : 0].bf16;\ntmp += S0[31 : 16].bf16 * S1[31 : 16].bf16;\nD0.bf16 = tmp',
  VOP3Op.V_ADD_NC_U16: 'D0.u16 = S0.u16 + S1.u16',
  VOP3Op.V_SUB_NC_U16: 'D0.u16 = S0.u16 - S1.u16',
  VOP3Op.V_MUL_LO_U16: 'D0.u16 = S0.u16 * S1.u16',
  VOP3Op.V_CVT_PK_I16_F32: "declare tmp : 32'B;\ntmp[31 : 16] = 16'B(v_cvt_i16_f32(S1.f32));\ntmp[15 : 0] = 16'B(v_cvt_i16_f32(S0.f32));\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_U16_F32: "declare tmp : 32'B;\ntmp[31 : 16] = 16'B(v_cvt_u16_f32(S1.f32));\ntmp[15 : 0] = 16'B(v_cvt_u16_f32(S0.f32));\nD0 = tmp.b32",
  VOP3Op.V_MAX_U16: 'D0.u16 = S0.u16 >= S1.u16 ? S0.u16 : S1.u16',
  VOP3Op.V_MAX_I16: 'D0.i16 = S0.i16 >= S1.i16 ? S0.i16 : S1.i16',
  VOP3Op.V_MIN_U16: 'D0.u16 = S0.u16 < S1.u16 ? S0.u16 : S1.u16',
  VOP3Op.V_MIN_I16: 'D0.i16 = S0.i16 < S1.i16 ? S0.i16 : S1.i16',
  VOP3Op.V_ADD_NC_I16: 'D0.i16 = S0.i16 + S1.i16',
  VOP3Op.V_SUB_NC_I16: 'D0.i16 = S0.i16 - S1.i16',
  VOP3Op.V_PACK_B32_F16: 'D0[31 : 16].f16 = S1.f16;\nD0[15 : 0].f16 = S0.f16',
  VOP3Op.V_CVT_PK_NORM_I16_F16: "declare tmp : 32'B;\ntmp[15 : 0].i16 = f16_to_snorm(S0.f16);\ntmp[31 : 16].i16 = f16_to_snorm(S1.f16);\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_NORM_U16_F16: "declare tmp : 32'B;\ntmp[15 : 0].u16 = f16_to_unorm(S0.f16);\ntmp[31 : 16].u16 = f16_to_unorm(S1.f16);\nD0 = tmp.b32",
  VOP3Op.V_LDEXP_F32: 'D0.f32 = S0.f32 * 2.0F ** S1.i32\nldexp()',
  VOP3Op.V_BFM_B32: 'D0.u32 = (((1U << S0[4 : 0].u32) - 1U) << S1[4 : 0].u32)',
  VOP3Op.V_BCNT_U32_B32: "tmp = S1.u32;\nfor i in 0 : 31 do\nÊ   tmp += S0[i].u32;\nÊ   // count i'th bit\nendfor;\nD0.u32 = tmp",
  VOP3Op.V_MBCNT_LO_U32_B32: "ThreadMask = (1LL << laneId.u32) - 1LL;\nMaskedValue = (S0.u32 & ThreadMask[31 : 0].u32);\ntmp = S1.u32;\nfor i in 0 : 31 do\nÊ   tmp += MaskedValue[i] == 1'1U ? 1U : 0U\nendfor;\nD0.u32 = tmp",
  VOP3Op.V_MBCNT_HI_U32_B32: "ThreadMask = (1LL << laneId.u32) - 1LL;\nMaskedValue = (S0.u32 & ThreadMask[63 : 32].u32);\ntmp = S1.u32;\nfor i in 0 : 31 do\nÊ   tmp += MaskedValue[i] == 1'1U ? 1U : 0U\nendfor;\nD0.u32 = tmp\nÊ   v_mbcnt_lo_u32_b32 v0, -1, 0\nÊ   v_mbcnt_hi_u32_b32 v0, -1, v0\nÊ   // v0 now contains laneId\nÊ   v_mbcnt_lo_u32_b32 v0, vcc_lo, 0\nÊ   v_mbcnt_hi_u32_b32 v0, vcc_hi, v0 // Note vcc_hi is passed in for second instruction\nÊ   // v0 now contains position among lanes with VCC=1",
  VOP3Op.V_CVT_PK_NORM_I16_F32: "declare tmp : 32'B;\ntmp[15 : 0].i16 = f32_to_snorm(S0.f32);\ntmp[31 : 16].i16 = f32_to_snorm(S1.f32);\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_NORM_U16_F32: "declare tmp : 32'B;\ntmp[15 : 0].u16 = f32_to_unorm(S0.f32);\ntmp[31 : 16].u16 = f32_to_unorm(S1.f32);\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_U16_U32: "declare tmp : 32'B;\ntmp[15 : 0].u16 = u32_to_u16(S0.u32);\ntmp[31 : 16].u16 = u32_to_u16(S1.u32);\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_I16_I32: "D0 = tmp.b32\ndeclare tmp : 32'B;\ntmp[15 : 0].i16 = i32_to_i16(S0.i32);\ntmp[31 : 16].i16 = i32_to_i16(S1.i32);",
  VOP3Op.V_SUB_NC_I32: 'D0.i32 = S0.i32 - S1.i32',
  VOP3Op.V_ADD_NC_I32: 'D0.i32 = S0.i32 + S1.i32',
  VOP3Op.V_ADD_F64: 'D0.f64 = S0.f64 + S1.f64',
  VOP3Op.V_MUL_F64: 'D0.f64 = S0.f64 * S1.f64',
  VOP3Op.V_MIN_F64: 'LT_NEG_ZERO = lambda(a, b) (\nÊ   ((a < b) || ((abs(a) == 0.0) && (abs(b) == 0.0) && sign(a) && !sign(b))));\n// Version of comparison where -0.0 < +0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(S0.f64) then\nÊ       D0.f64 = cvtToQuietNAN(S0.f64)\nÊ   elsif isSignalNAN(S1.f64) then\nÊ       D0.f64 = cvtToQuietNAN(S1.f64)\nÊ   elsif isQuietNAN(S1.f64) then\nÊ       D0.f64 = S0.f64\nÊ   elsif isQuietNAN(S0.f64) then\nÊ       D0.f64 = S1.f64\nÊ   elsif LT_NEG_ZERO(S0.f64, S1.f64) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f64 = S0.f64\nÊ   else\nÊ       D0.f64 = S1.f64\nÊ   endif\nelse\nÊ   if isNAN(S1.f64) then\nÊ       D0.f64 = S0.f64\nÊ   elsif isNAN(S0.f64) then\nÊ       D0.f64 = S1.f64\nÊ   elsif LT_NEG_ZERO(S0.f64, S1.f64) then\nÊ       // NOTE: -0<+0 is TRUE in this comparison\nÊ       D0.f64 = S0.f64\nÊ   else\nÊ       D0.f64 = S1.f64\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.',
  VOP3Op.V_MAX_F64: 'GT_NEG_ZERO = lambda(a, b) (\nÊ   ((a > b) || ((abs(a) == 0.0) && (abs(b) == 0.0) && !sign(a) && sign(b))));\n// Version of comparison where +0.0 > -0.0, differs from IEEE\nif WAVE_MODE.IEEE then\nÊ   if isSignalNAN(S0.f64) then\nÊ       D0.f64 = cvtToQuietNAN(S0.f64)\nÊ   elsif isSignalNAN(S1.f64) then\nÊ       D0.f64 = cvtToQuietNAN(S1.f64)\nÊ   elsif isQuietNAN(S1.f64) then\nÊ       D0.f64 = S0.f64\nÊ   elsif isQuietNAN(S0.f64) then\nÊ       D0.f64 = S1.f64\nÊ   elsif GT_NEG_ZERO(S0.f64, S1.f64) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f64 = S0.f64\nÊ   else\nÊ       D0.f64 = S1.f64\nÊ   endif\nelse\nÊ   if isNAN(S1.f64) then\nÊ       D0.f64 = S0.f64\nÊ   elsif isNAN(S0.f64) then\nÊ       D0.f64 = S1.f64\nÊ   elsif GT_NEG_ZERO(S0.f64, S1.f64) then\nÊ       // NOTE: +0>-0 is TRUE in this comparison\nÊ       D0.f64 = S0.f64\nÊ   else\nÊ       D0.f64 = S1.f64\nÊ   endif\nendif;\n// Inequalities in the above pseudocode behave differently from IEEE\n// when both inputs are +-0.',
  VOP3Op.V_LDEXP_F64: 'D0.f64 = S0.f64 * 2.0 ** S1.i32\nldexp()',
  VOP3Op.V_MUL_LO_U32: 'D0.u32 = S0.u32 * S1.u32',
  VOP3Op.V_MUL_HI_U32: "D0.u32 = 32'U((64'U(S0.u32) * 64'U(S1.u32)) >> 32U)",
  VOP3Op.V_MUL_HI_I32: "D0.i32 = 32'I((64'I(S0.i32) * 64'I(S1.i32)) >> 32U)",
  VOP3Op.V_TRIG_PREOP_F64: "shift = 32'I(S1[4 : 0].u32) * 53;\nif exponent(S0.f64) > 1077 then\nÊ   shift += exponent(S0.f64) - 1077\nendif;\n// (2.0/PI) == 0.{b_1200, b_1199, b_1198, ..., b_1, b_0}\n// b_1200 is the MSB of the fractional part of 2.0/PI\n// Left shift operation indicates which bits are brought\n// into the whole part of the number.\n// Only whole part of result is kept.\nresult = 64'F((1201'B(2.0 / PI)[1200 : 0] << shift.u32) & 1201'0x1fffffffffffff);\nscale = -53 - shift;\nif exponent(S0.f64) >= 1968 then\nÊ   scale += 128\nendif;\nD0.f64 = ldexp(result, scale)",
  VOP3Op.V_LSHLREV_B16: 'D0.u16 = (S1.u16 << S0[3 : 0].u32)',
  VOP3Op.V_LSHRREV_B16: 'D0.u16 = (S1.u16 >> S0[3 : 0].u32)',
  VOP3Op.V_ASHRREV_I16: 'D0.i16 = (S1.i16 >> S0[3 : 0].u32)',
  VOP3Op.V_LSHLREV_B64: 'D0.u64 = (S1.u64 << S0[5 : 0].u32)',
  VOP3Op.V_LSHRREV_B64: 'D0.u64 = (S1.u64 >> S0[5 : 0].u32)',
  VOP3Op.V_ASHRREV_I64: 'D0.i64 = (S1.i64 >> S0[5 : 0].u32)',
  VOP3Op.V_READLANE_B32: "declare lane : 32'U;\nif WAVE32 then\nÊ   lane = S1.u32[4 : 0].u32;\nÊ   // Lane select for wave32\nelse\nÊ   lane = S1.u32[5 : 0].u32;\nÊ   // Lane select for wave64\nendif;\nD0.b32 = VGPR[lane][SRC0.u32]",
  VOP3Op.V_WRITELANE_B32: "declare lane : 32'U;\nif WAVE32 then\nÊ   lane = S1.u32[4 : 0].u32;\nÊ   // Lane select for wave32\nelse\nÊ   lane = S1.u32[5 : 0].u32;\nÊ   // Lane select for wave64\nendif;\nVGPR[lane][VDST.u32] = S0.b32",
  VOP3Op.V_AND_B16: 'D0.u16 = (S0.u16 & S1.u16)',
  VOP3Op.V_OR_B16: 'D0.u16 = (S0.u16 | S1.u16)',
  VOP3Op.V_XOR_B16: 'D0.u16 = (S0.u16 ^ S1.u16)',
}

VOP3POp_PCODE = {
  VOP3POp.V_PK_MAD_I16: 'tmp[31 : 16].i16 = S0[31 : 16].i16 * S1[31 : 16].i16 + S2[31 : 16].i16;\ntmp[15 : 0].i16 = S0[15 : 0].i16 * S1[15 : 0].i16 + S2[15 : 0].i16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MUL_LO_U16: 'tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16;\ntmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_ADD_I16: 'tmp[31 : 16].i16 = S0[31 : 16].i16 + S1[31 : 16].i16;\ntmp[15 : 0].i16 = S0[15 : 0].i16 + S1[15 : 0].i16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_SUB_I16: 'D0.b32 = tmp.b32\ntmp[31 : 16].i16 = S0[31 : 16].i16 - S1[31 : 16].i16;\ntmp[15 : 0].i16 = S0[15 : 0].i16 - S1[15 : 0].i16;',
  VOP3POp.V_PK_LSHLREV_B16: 'tmp[31 : 16].u16 = (S1[31 : 16].u16 << S0.u32[19 : 16].u32);\ntmp[15 : 0].u16 = (S1[15 : 0].u16 << S0.u32[3 : 0].u32);\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_LSHRREV_B16: 'tmp[31 : 16].u16 = (S1[31 : 16].u16 >> S0.u32[19 : 16].u32);\ntmp[15 : 0].u16 = (S1[15 : 0].u16 >> S0.u32[3 : 0].u32);\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_ASHRREV_I16: 'tmp[31 : 16].i16 = (S1[31 : 16].i16 >> S0.u32[19 : 16].u32);\ntmp[15 : 0].i16 = (S1[15 : 0].i16 >> S0.u32[3 : 0].u32);\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MAX_I16: 'tmp[31 : 16].i16 = S0[31 : 16].i16 >= S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;\ntmp[15 : 0].i16 = S0[15 : 0].i16 >= S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MIN_I16: 'tmp[31 : 16].i16 = S0[31 : 16].i16 < S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;\ntmp[15 : 0].i16 = S0[15 : 0].i16 < S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MAD_U16: 'tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16 + S2[31 : 16].u16;\ntmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16 + S2[15 : 0].u16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_ADD_U16: 'tmp[31 : 16].u16 = S0[31 : 16].u16 + S1[31 : 16].u16;\ntmp[15 : 0].u16 = S0[15 : 0].u16 + S1[15 : 0].u16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_SUB_U16: 'tmp[31 : 16].u16 = S0[31 : 16].u16 - S1[31 : 16].u16;\ntmp[15 : 0].u16 = S0[15 : 0].u16 - S1[15 : 0].u16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MAX_U16: 'tmp[31 : 16].u16 = S0[31 : 16].u16 >= S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;\ntmp[15 : 0].u16 = S0[15 : 0].u16 >= S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MIN_U16: 'tmp[31 : 16].u16 = S0[31 : 16].u16 < S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;\ntmp[15 : 0].u16 = S0[15 : 0].u16 < S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_FMA_F16: "declare tmp : 32'B;\ntmp[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16);\ntmp[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16);\nD0.b32 = tmp",
  VOP3POp.V_PK_ADD_F16: 'tmp[31 : 16].f16 = S0[31 : 16].f16 + S1[31 : 16].f16;\ntmp[15 : 0].f16 = S0[15 : 0].f16 + S1[15 : 0].f16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MUL_F16: 'tmp[15 : 0].f16 = S0[15 : 0].f16 * S1[15 : 0].f16;\nD0.b32 = tmp.b32\ntmp[31 : 16].f16 = S0[31 : 16].f16 * S1[31 : 16].f16;',
  VOP3POp.V_PK_MIN_F16: 'tmp[31 : 16].f16 = v_min_f16(S0[31 : 16].f16, S1[31 : 16].f16);\ntmp[15 : 0].f16 = v_min_f16(S0[15 : 0].f16, S1[15 : 0].f16);\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MAX_F16: 'tmp[31 : 16].f16 = v_max_f16(S0[31 : 16].f16, S1[31 : 16].f16);\ntmp[15 : 0].f16 = v_max_f16(S0[15 : 0].f16, S1[15 : 0].f16);\nD0.b32 = tmp.b32',
  VOP3POp.V_DOT2_F32_F16: 'tmp = S2.f32;\ntmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16);\ntmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16);\nD0.f32 = tmp',
  VOP3POp.V_DOT4_I32_IU8: "declare B : 32'I[4];\n// Figure out whether inputs are signed/unsigned.\nfor i in 0 : 3 do\nÊ   A8 = S0[i * 8 + 7 : i * 8];\nÊ   B8 = S1[i * 8 + 7 : i * 8];\nÊ   A[i] = NEG[0].u1 ? 32'I(signext(A8.i8)) : 32'I(32'U(A8.u8));\nÊ   B[i] = NEG[1].u1 ? 32'I(signext(B8.i8)) : 32'I(32'U(B8.u8))\nendfor;\nC = S2.i32;\n// Signed multiplier/adder. Extend unsigned inputs with leading 0.\ntmp = C.i32;\ntmp += A[0] * B[0];\ntmp += A[1] * B[1];\ntmp += A[2] * B[2];\ntmp += A[3] * B[3];\nD0.i32 = tmp\ndeclare A : 32'I[4];",
  VOP3POp.V_DOT4_U32_U8: 'tmp = S2.u32;\ntmp += u8_to_u32(S0[7 : 0].u8) * u8_to_u32(S1[7 : 0].u8);\ntmp += u8_to_u32(S0[15 : 8].u8) * u8_to_u32(S1[15 : 8].u8);\ntmp += u8_to_u32(S0[23 : 16].u8) * u8_to_u32(S1[23 : 16].u8);\ntmp += u8_to_u32(S0[31 : 24].u8) * u8_to_u32(S1[31 : 24].u8);\nD0.u32 = tmp',
  VOP3POp.V_DOT8_I32_IU4: "for i in 0 : 7 do\nÊ   A4 = S0[i * 4 + 3 : i * 4];\nÊ   B4 = S1[i * 4 + 3 : i * 4];\nÊ   A[i] = NEG[0].u1 ? 32'I(signext(A4.i4)) : 32'I(32'U(A4.u4));\nÊ   B[i] = NEG[1].u1 ? 32'I(signext(B4.i4)) : 32'I(32'U(B4.u4))\nendfor;\nC = S2.i32;\n// Signed multiplier/adder. Extend unsigned inputs with leading 0.\ntmp = C.i32;\ntmp += A[0] * B[0];\ntmp += A[1] * B[1];\ntmp += A[2] * B[2];\ntmp += A[3] * B[3];\ntmp += A[4] * B[4];\ntmp += A[5] * B[5];\ntmp += A[6] * B[6];\ntmp += A[7] * B[7];\nD0.i32 = tmp\ndeclare A : 32'I[8];\ndeclare B : 32'I[8];\n// Figure out whether inputs are signed/unsigned.",
  VOP3POp.V_DOT8_U32_U4: 'tmp = S2.u32;\ntmp += u4_to_u32(S0[3 : 0].u4) * u4_to_u32(S1[3 : 0].u4);\ntmp += u4_to_u32(S0[7 : 4].u4) * u4_to_u32(S1[7 : 4].u4);\ntmp += u4_to_u32(S0[11 : 8].u4) * u4_to_u32(S1[11 : 8].u4);\ntmp += u4_to_u32(S0[15 : 12].u4) * u4_to_u32(S1[15 : 12].u4);\ntmp += u4_to_u32(S0[19 : 16].u4) * u4_to_u32(S1[19 : 16].u4);\ntmp += u4_to_u32(S0[23 : 20].u4) * u4_to_u32(S1[23 : 20].u4);\ntmp += u4_to_u32(S0[27 : 24].u4) * u4_to_u32(S1[27 : 24].u4);\ntmp += u4_to_u32(S0[31 : 28].u4) * u4_to_u32(S1[31 : 28].u4);\nD0.u32 = tmp',
  VOP3POp.V_DOT2_F32_BF16: 'tmp = S2.f32;\ntmp += bf16_to_f32(S0[15 : 0].bf16) * bf16_to_f32(S1[15 : 0].bf16);\ntmp += bf16_to_f32(S0[31 : 16].bf16) * bf16_to_f32(S1[31 : 16].bf16);\nD0.f32 = tmp',
  VOP3POp.V_FMA_MIX_F32: "{ OPSEL_HI[i], OPSEL[i] }\n2=src[15:0]\n1=src[31:0]\n0=src[31:0]\n3=src[31:16]\ndeclare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nÊ   if !OPSEL_HI.u3[i] then\nÊ       in[i] = S[i].f32\nÊ   elsif OPSEL.u3[i] then\nÊ       in[i] = f16_to_f32(S[i][31 : 16].f16)\nÊ   else\nÊ       in[i] = f16_to_f32(S[i][15 : 0].f16)\nÊ   endif\nendfor;\nD0[31 : 0].f32 = fma(in[0], in[1], in[2])",
  VOP3POp.V_FMA_MIXLO_F16: "{ OPSEL_HI[i], OPSEL[i] }\n2=src[15:0]\n1=src[31:0]\n0=src[31:0]\n3=src[31:16]\ndeclare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nÊ   if !OPSEL_HI.u3[i] then\nÊ       in[i] = S[i].f32\nÊ   elsif OPSEL.u3[i] then\nÊ       in[i] = f16_to_f32(S[i][31 : 16].f16)\nÊ   else\nÊ       in[i] = f16_to_f32(S[i][15 : 0].f16)\nÊ   endif\nendfor;\nD0[15 : 0].f16 = f32_to_f16(fma(in[0], in[1], in[2]))",
  VOP3POp.V_FMA_MIXHI_F16: "{ OPSEL_HI[i], OPSEL[i] }\n2=src[15:0]\n1=src[31:0]\n0=src[31:0]\n3=src[31:16]\ndeclare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nÊ   if !OPSEL_HI.u3[i] then\nÊ       in[i] = S[i].f32\nÊ   elsif OPSEL.u3[i] then\nÊ       in[i] = f16_to_f32(S[i][31 : 16].f16)\nÊ   else\nÊ       in[i] = f16_to_f32(S[i][15 : 0].f16)\nÊ   endif\nendfor;\nD0[31 : 16].f16 = f32_to_f16(fma(in[0], in[1], in[2]))",
  VOP3POp.V_WMMA_F32_16X16X16_F16: 'D = A (16x16) * B (16x16) + C (16x16)\nsaved_exec = EXEC;\nEXEC = 64\'B(-1);\neval "D0.f32(16x16) = S0.f16(16x16) * S1.f16(16x16) + S2.f32(16x16)";\nEXEC = saved_exec',
  VOP3POp.V_WMMA_F32_16X16X16_BF16: 'saved_exec = EXEC;\nEXEC = 64\'B(-1);\neval "D0.f32(16x16) = S0.bf16(16x16) * S1.bf16(16x16) + S2.f32(16x16)";\nEXEC = saved_exec\nD = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_F16_16X16X16_F16: 'D = A (16x16) * B (16x16) + C (16x16)\nsaved_exec = EXEC;\nEXEC = 64\'B(-1);\neval "D0.f16(16x16) = S0.f16(16x16) * S1.f16(16x16) + S2.f16(16x16)";\nEXEC = saved_exec',
  VOP3POp.V_WMMA_BF16_16X16X16_BF16: 'EXEC = saved_exec\nD = A (16x16) * B (16x16) + C (16x16)\nsaved_exec = EXEC;\nEXEC = 64\'B(-1);\neval "D0.bf16(16x16) = S0.bf16(16x16) * S1.bf16(16x16) + S2.bf16(16x16)";',
  VOP3POp.V_WMMA_I32_16X16X16_IU8: 'D = A (16x16) * B (16x16) + C (16x16)\nsaved_exec = EXEC;\nEXEC = 64\'B(-1);\neval "D0.i32(16x16) = S0.iu8(16x16) * S1.iu8(16x16) + S2.i32(16x16)";\nEXEC = saved_exec',
  VOP3POp.V_WMMA_I32_16X16X16_IU4: 'D = A (16x16) * B (16x16) + C (16x16)\nsaved_exec = EXEC;\nEXEC = 64\'B(-1);\neval "D0.i32(16x16) = S0.iu4(16x16) * S1.iu4(16x16) + S2.i32(16x16)";\nEXEC = saved_exec',
}

VOP3SDOp_PCODE = {
  VOP3SDOp.V_ADD_CO_CI_U32: "tmp = 64'U(S0.u32) + 64'U(S1.u32) + VCC.u64[laneId].u64;\nVCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_ADD_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_SUB_CO_CI_U32: "tmp = S0.u32 - S1.u32 - VCC.u64[laneId].u32;\nVCC.u64[laneId] = 64'U(S1.u32) + VCC.u64[laneId].u64 > 64'U(S0.u32) ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_SUBREV_CO_CI_U32: "tmp = S1.u32 - S0.u32 - VCC.u64[laneId].u32;\nVCC.u64[laneId] = 64'U(S0.u32) + VCC.u64[laneId].u64 > 64'U(S1.u32) ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_DIV_SCALE_F32: "Ê       // Only scale the numerator\nÊ       D0.f32 = ldexp(S0.f32, 64)\nÊ   endif\nelsif exponent(S2.f32) <= 23 then\nÊ   // Numerator is tiny\nÊ   D0.f32 = ldexp(S0.f32, 64)\nendif\nVCC = 0x0LL;\nif ((64'F(S2.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\nÊ   D0.f32 = NAN.f32\nelsif exponent(S2.f32) - exponent(S1.f32) >= 96 then\nÊ   // N/D near MAX_FLOAT_F32\nÊ   VCC = 0x1LL;\nÊ   if S0.f32 == S1.f32 then\nÊ       // Only scale the denominator\nÊ       D0.f32 = ldexp(S0.f32, 64)\nÊ   endif\nelsif S1.f32 == DENORM.f32 then\nÊ   D0.f32 = ldexp(S0.f32, 64)\nelsif ((1.0 / 64'F(S1.f32) == DENORM.f64) && (S2.f32 / S1.f32 == DENORM.f32)) then\nÊ   VCC = 0x1LL;\nÊ   if S0.f32 == S1.f32 then\nÊ       // Only scale the denominator\nÊ       D0.f32 = ldexp(S0.f32, 64)\nÊ   endif\nelsif 1.0 / 64'F(S1.f32) == DENORM.f64 then\nÊ   D0.f32 = ldexp(S0.f32, -64)\nelsif S2.f32 / S1.f32 == DENORM.f32 then\nÊ   VCC = 0x1LL;\nÊ   if S0.f32 == S2.f32 then",
  VOP3SDOp.V_DIV_SCALE_F64: 'Ê       D0.f64 = ldexp(S0.f64, 128)\nÊ   endif\nelsif exponent(S2.f64) <= 53 then\nÊ   // Numerator is tiny\nÊ   D0.f64 = ldexp(S0.f64, 128)\nendif\nVCC = 0x0LL;\nif ((S2.f64 == 0.0) || (S1.f64 == 0.0)) then\nÊ   D0.f64 = NAN.f64\nelsif exponent(S2.f64) - exponent(S1.f64) >= 768 then\nÊ   // N/D near MAX_FLOAT_F64\nÊ   VCC = 0x1LL;\nÊ   if S0.f64 == S1.f64 then\nÊ       // Only scale the denominator\nÊ       D0.f64 = ldexp(S0.f64, 128)\nÊ   endif\nelsif S1.f64 == DENORM.f64 then\nÊ   D0.f64 = ldexp(S0.f64, 128)\nelsif ((1.0 / S1.f64 == DENORM.f64) && (S2.f64 / S1.f64 == DENORM.f64)) then\nÊ   VCC = 0x1LL;\nÊ   if S0.f64 == S1.f64 then\nÊ       // Only scale the denominator\nÊ       D0.f64 = ldexp(S0.f64, 128)\nÊ   endif\nelsif 1.0 / S1.f64 == DENORM.f64 then\nÊ   D0.f64 = ldexp(S0.f64, -128)\nelsif S2.f64 / S1.f64 == DENORM.f64 then\nÊ   VCC = 0x1LL;\nÊ   if S0.f64 == S2.f64 then\nÊ       // Only scale the numerator',
  VOP3SDOp.V_MAD_U64_U32: "{ D1.u1, D0.u64 } = 65'B(65'U(S0.u32) * 65'U(S1.u32) + 65'U(S2.u64))",
  VOP3SDOp.V_MAD_I64_I32: "{ D1.i1, D0.i64 } = 65'B(65'I(S0.i32) * 65'I(S1.i32) + 65'I(S2.i64))",
  VOP3SDOp.V_ADD_CO_U32: "VCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_ADD_CO_CI_U32.\nD0.u32 = tmp.u32\ntmp = 64'U(S0.u32) + 64'U(S1.u32);",
  VOP3SDOp.V_SUB_CO_U32: "tmp = S0.u32 - S1.u32;\nVCC.u64[laneId] = S1.u32 > S0.u32 ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_SUBREV_CO_U32: "tmp = S1.u32 - S0.u32;\nVCC.u64[laneId] = S0.u32 > S1.u32 ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
}

PSEUDOCODE_STRINGS = {
  DSOp: DSOp_PCODE,
  FLATOp: FLATOp_PCODE,
  GLOBALOp: GLOBALOp_PCODE,
  MIMGOp: MIMGOp_PCODE,
  MTBUFOp: MTBUFOp_PCODE,
  MUBUFOp: MUBUFOp_PCODE,
  SCRATCHOp: SCRATCHOp_PCODE,
  SMEMOp: SMEMOp_PCODE,
  SOP1Op: SOP1Op_PCODE,
  SOP2Op: SOP2Op_PCODE,
  SOPCOp: SOPCOp_PCODE,
  SOPKOp: SOPKOp_PCODE,
  SOPPOp: SOPPOp_PCODE,
  VINTERPOp: VINTERPOp_PCODE,
  VOP1Op: VOP1Op_PCODE,
  VOP2Op: VOP2Op_PCODE,
  VOP3Op: VOP3Op_PCODE,
  VOP3POp: VOP3POp_PCODE,
  VOP3SDOp: VOP3SDOp_PCODE,
}