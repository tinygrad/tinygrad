from enum import IntEnum

# *** enum definitions ***

class SrcEnum(IntEnum):
  """Table 65. SOP2 Fields: SSRC encoding"""

  FLAT_SCRATCH_LO = 102; FLAT_SCRATCH_HI = 103 # CDNA only
  XNACK_MASK_LO = 104; XNACK_MASK_HI = 105 # CDNA only

  VCC_LO = 106; VCC_HI = 107

  # TTMP0 - TTMP15

  NULL    = 124  # M0 on CDNA4
  M0      = 125
  EXEC_LO = 126; EXEC_HI = 127

  ZERO = 128  # 0
  # 129–192: +1..+64
  # 193–208: -1..-16

  DPP8    = 233  # VOp only
  DPP8FI  = 234  # VOp only

  SHARED_BASE   = 235; SHARED_LIMIT  = 236
  PRIVATE_BASE  = 237; PRIVATE_LIMIT = 238

  POS_HALF = 240; NEG_HALF = 241
  POS_ONE  = 242; NEG_ONE  = 243
  POS_TWO  = 244; NEG_TWO  = 245
  POS_FOUR = 246; NEG_FOUR = 247

  INV_2PI = 248
  DPP16   = 250  # VOp only

  VCCZ    = 251 # CDNA only
  EXECZ   = 252 # CDNA only

  SCC     = 253
  LITERAL = 255

class SOP2Op(IntEnum):
  """Table 66. SOP2 Opcodes"""

  # Integer add/sub
  S_ADD_U32 = 0; S_SUB_U32 = 1; S_ADD_I32 = 2; S_SUB_I32 = 3
  S_ADDC_U32 = 4; S_SUBB_U32 = 5; S_ABSDIFF_I32 = 6

  # Shifts / shift-add
  S_LSHL_B32 = 8; S_LSHL_B64 = 9; S_LSHR_B32 = 10; S_LSHR_B64 = 11
  S_ASHR_I32 = 12; S_ASHR_I64 = 13
  S_LSHL1_ADD_U32 = 14; S_LSHL2_ADD_U32 = 15
  S_LSHL3_ADD_U32 = 16; S_LSHL4_ADD_U32 = 17

  # Integer min/max
  S_MIN_I32 = 18; S_MIN_U32 = 19; S_MAX_I32 = 20; S_MAX_U32 = 21

  # Bitwise logic
  S_AND_B32 = 22; S_AND_B64 = 23; S_OR_B32 = 24; S_OR_B64 = 25
  S_XOR_B32 = 26; S_XOR_B64 = 27; S_NAND_B32 = 28; S_NAND_B64 = 29
  S_NOR_B32 = 30; S_NOR_B64 = 31; S_XNOR_B32 = 32; S_XNOR_B64 = 33
  S_AND_NOT1_B32 = 34; S_AND_NOT1_B64 = 35
  S_OR_NOT1_B32 = 36; S_OR_NOT1_B64 = 37

  # Bitfield extract / mask
  S_BFE_U32 = 38; S_BFE_I32 = 39; S_BFE_U64 = 40; S_BFE_I64 = 41
  S_BFM_B32 = 42; S_BFM_B64 = 43

  # Integer multiply
  S_MUL_I32 = 44; S_MUL_HI_U32 = 45; S_MUL_HI_I32 = 46

  # Conditional select
  S_CSELECT_B32 = 48; S_CSELECT_B64 = 49

  # Pack
  S_PACK_LL_B32_B16 = 50; S_PACK_LH_B32_B16 = 51
  S_PACK_HH_B32_B16 = 52; S_PACK_HL_B32_B16 = 53

  # Scalar float32
  S_ADD_F32 = 64; S_SUB_F32 = 65; S_MIN_F32 = 66; S_MAX_F32 = 67
  S_MUL_F32 = 68; S_FMAAK_F32 = 69; S_FMAMK_F32 = 70; S_FMAC_F32 = 71
  S_CVT_PK_RTZ_F16_F32 = 72

  # Scalar float16
  S_ADD_F16 = 73; S_SUB_F16 = 74; S_MIN_F16 = 75; S_MAX_F16 = 76
  S_MUL_F16 = 77; S_FMAC_F16 = 78

class SOP1Op(IntEnum):
  """Table 70. SOP1 Opcodes"""

  # Move / conditional move
  S_MOV_B32 = 0; S_MOV_B64 = 1; S_CMOV_B32 = 2; S_CMOV_B64 = 3
  S_BREV_B32 = 4; S_BREV_B64 = 5

  # Count / leading / trailing / sign-extend
  S_CTZ_I32_B32 = 8; S_CTZ_I32_B64 = 9
  S_CLZ_I32_U32 = 10; S_CLZ_I32_U64 = 11
  S_CLS_I32 = 12; S_CLS_I32_I64 = 13
  S_SEXT_I32_I8 = 14; S_SEXT_I32_I16 = 15

  # Bit set / replicate
  S_BITSET0_B32 = 16; S_BITSET0_B64 = 17
  S_BITSET1_B32 = 18; S_BITSET1_B64 = 19
  S_BITREPLICATE_B64_B32 = 20

  # Integer abs
  S_ABS_I32 = 21

  # Bit counts
  S_BCNT0_I32_B32 = 22; S_BCNT0_I32_B64 = 23
  S_BCNT1_I32_B32 = 24; S_BCNT1_I32_B64 = 25

  # Quad / WQM / NOT
  S_QUADMASK_B32 = 26; S_QUADMASK_B64 = 27
  S_WQM_B32 = 28; S_WQM_B64 = 29
  S_NOT_B32 = 30; S_NOT_B64 = 31

  # Exec mask logic (SAVEEXEC)
  S_AND_SAVEEXEC_B32 = 32; S_AND_SAVEEXEC_B64 = 33
  S_OR_SAVEEXEC_B32 = 34; S_OR_SAVEEXEC_B64 = 35
  S_XOR_SAVEEXEC_B32 = 36; S_XOR_SAVEEXEC_B64 = 37
  S_NAND_SAVEEXEC_B32 = 38; S_NAND_SAVEEXEC_B64 = 39
  S_NOR_SAVEEXEC_B32 = 40; S_NOR_SAVEEXEC_B64 = 41
  S_XNOR_SAVEEXEC_B32 = 42; S_XNOR_SAVEEXEC_B64 = 43
  S_AND_NOT0_SAVEEXEC_B32 = 44; S_AND_NOT0_SAVEEXEC_B64 = 45
  S_OR_NOT0_SAVEEXEC_B32 = 46; S_OR_NOT0_SAVEEXEC_B64 = 47
  S_AND_NOT1_SAVEEXEC_B32 = 48; S_AND_NOT1_SAVEEXEC_B64 = 49
  S_OR_NOT1_SAVEEXEC_B32 = 50; S_OR_NOT1_SAVEEXEC_B64 = 51

  # Exec mask logic (WREXEC)
  S_AND_NOT0_WREXEC_B32 = 52; S_AND_NOT0_WREXEC_B64 = 53
  S_AND_NOT1_WREXEC_B32 = 54; S_AND_NOT1_WREXEC_B64 = 55

  # MOVREL* / PC / MSG
  S_MOVRELS_B32 = 64; S_MOVRELS_B64 = 65
  S_MOVRELD_B32 = 66; S_MOVRELD_B64 = 67
  S_MOVRELSD_2_B32 = 68
  S_GETPC_B64 = 71; S_SETPC_B64 = 72; S_SWAPPC_B64 = 73; S_RFE_B64 = 74
  S_SENDMSG_RTN_B32 = 76; S_SENDMSG_RTN_B64 = 77

  # Scalar float33
  S_CEIL_F32 = 96; S_FLOOR_F32 = 97; S_TRUNC_F32 = 98; S_RNDNE_F32 = 99
  S_CVT_F32_I32 = 100; S_CVT_F32_U32 = 101; S_CVT_I32_F32 = 102; S_CVT_U32_F32 = 103
  S_CVT_F16_F32 = 104; S_CVT_F32_F16 = 105; S_CVT_HI_F32_F16 = 106

  # Scalar float16
  S_CEIL_F16 = 107; S_FLOOR_F16 = 108; S_TRUNC_F16 = 109; S_RNDNE_F16 = 110

class SMEMOp(IntEnum):
  """Table 76. SMEM Opcodes"""

  S_LOAD_B32 = 0; S_LOAD_B64 = 1; S_LOAD_B128 = 2
  S_LOAD_B256 = 3; S_LOAD_B512 = 4

  S_BUFFER_LOAD_B32 = 8; S_BUFFER_LOAD_B64 = 9; S_BUFFER_LOAD_B128 = 10
  S_BUFFER_LOAD_B256 = 11; S_BUFFER_LOAD_B512 = 12

  S_GL1_INV = 32; S_DCACHE_INV = 33

class VOP2Op(IntEnum):
  """Table 78. VOP2 Opcodes"""

  # Conditional / dot / basic float add/sub
  V_CNDMASK_B32 = 1; V_DOT2ACC_F32_F16 = 2
  V_ADD_F32 = 3; V_SUB_F32 = 4; V_SUBREV_F32 = 5

  # DX9-style FMAC/MUL
  V_FMAC_DX9_ZERO_F32 = 6; V_MUL_DX9_ZERO_F32 = 7

  # Float / int multiplies
  V_MUL_F32 = 8
  V_MUL_I32_I24 = 9; V_MUL_HI_I32_I24 = 10
  V_MUL_U32_U24 = 11; V_MUL_HI_U32_U24 = 12

  # Float min/max
  V_MIN_F32 = 15; V_MAX_F32 = 16

  # Integer min/max
  V_MIN_I32 = 17; V_MAX_I32 = 18; V_MIN_U32 = 19; V_MAX_U32 = 20

  # Shifts / logic
  V_LSHLREV_B32 = 24; V_LSHRREV_B32 = 25; V_ASHRREV_I32 = 26
  V_AND_B32 = 27; V_OR_B32 = 28; V_XOR_B32 = 29; V_XNOR_B32 = 30

  # Add/sub with carry-in/carry-out
  V_ADD_CO_CI_U32 = 32; V_SUB_CO_CI_U32 = 33; V_SUBREV_CO_CI_U32 = 34

  # Add/sub “no carry”
  V_ADD_NC_U32 = 37; V_SUB_NC_U32 = 38; V_SUBREV_NC_U32 = 39

  # Fused FP32 / pack
  V_FMAC_F32 = 43; V_FMAMK_F32 = 44; V_FMAAK_F32 = 45
  V_CVT_PK_RTZ_F16_F32 = 47

  # FP16 basic / fused
  V_ADD_F16 = 50; V_SUB_F16 = 51; V_SUBREV_F16 = 52; V_MUL_F16 = 53
  V_FMAC_F16 = 54; V_FMAMK_F16 = 55; V_FMAAK_F16 = 56
  V_MAX_F16 = 57; V_MIN_F16 = 58; V_LDEXP_F16 = 59; V_PK_FMAC_F16 = 60
